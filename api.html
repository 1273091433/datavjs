<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>datavjs Documentation</title>
    <meta name="keywords" content="DataV" />
    <meta name="description" content="DataV.js is a JavaScript library for data visualization" />
    <script src="assets/prettify.js"></script>
    <script src="assets/jquery-1.8.2.min.js"></script>
    <script src="bootstrap/js/bootstrap.js"></script>
    <link rel="stylesheet" type="text/css" href="bootstrap/css/bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="bootstrap/css/bootstrap-responsive.min.css" />
    <link rel="stylesheet" type="text/css" href="assets/base.css" />
  </head>
  <body>
    <div class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="./index.html">datavjs</a>
          <div class="nav-collapse collapse">
            <ul class="nav">
            
              <li>
                <a href="./api.html">API Docs</a>
              </li>
            
              <li>
                <a href="./Architecture.html">Architecture</a>
              </li>
            
              <li>
                <a href="./chord文档.html">chord文档</a>
              </li>
            
              <li>
                <a href="./CodingStyle.html">CodingStyle</a>
              </li>
            
              <li>
                <a href="./dataFormat.html">dataFormat</a>
              </li>
            
              <li>
                <a href="./changelog.html">changelog</a>
              </li>
            
              <li>
                <a href="./Getting Start.html">Getting Start</a>
              </li>
            
            
              <li class="dropdown">
                <a class="dropdown-toggle" data-toggle="dropdown" href="#">更多 <b class="caret"></b></a>
                <ul class="dropdown-menu" role="menu">
                
                  <li>
                    <a href="./Load DataV.html">Load DataV</a>
                  </li>
                
                  <li>
                    <a href="./parallel文档.html">parallel文档</a>
                  </li>
                
                  <li>
                    <a href="./Pie文档.html">Pie文档</a>
                  </li>
                
                  <li>
                    <a href="./stream文档.html">stream文档</a>
                  </li>
                
                  <li>
                    <a href="./butterfly.html">butterfly</a>
                  </li>
                
                  <li>
                    <a href="./treemap文档.html">treemap文档</a>
                  </li>
                
                  <li>
                    <a href="./bullet文档.html">bullet文档</a>
                  </li>
                
                  <li>
                    <a href="./服务器配置.html">服务器配置</a>
                  </li>
                
                  <li>
                    <a href="./force文档.html">force文档</a>
                  </li>
                
                </ul>
              </li>
            
            </ul>
          </div>
        </div>
      </div>
    </div>
    <header class="jumbotron subhead">
      <div class="container">
        <h1>datavjs <small>Version: 0.0.1 By @DataV</small></h1>
        <p class="lead">
          DataV.js is a JavaScript library for data visualization
        </p>
      </div>
    </header>
<div class="container content">
  <div class="row">
    <div class="span3 bs-docs-sidebar">
      <ul class="nav nav-list bs-docs-sidenav affix">

  <li>
    <a href="#api_datav"><i class="icon-chevron-right"></i>datav</a>
  </li>

  <li>
    <a href="#api_charts/axis"><i class="icon-chevron-right"></i>charts/axis</a>
  </li>

  <li>
    <a href="#api_charts/brush"><i class="icon-chevron-right"></i>charts/brush</a>
  </li>

  <li>
    <a href="#api_charts/bubble"><i class="icon-chevron-right"></i>charts/bubble</a>
  </li>

  <li>
    <a href="#api_charts/bullet"><i class="icon-chevron-right"></i>charts/bullet</a>
  </li>

  <li>
    <a href="#api_charts/bundle"><i class="icon-chevron-right"></i>charts/bundle</a>
  </li>

  <li>
    <a href="#api_charts/chord"><i class="icon-chevron-right"></i>charts/chord</a>
  </li>

  <li>
    <a href="#api_charts/diff"><i class="icon-chevron-right"></i>charts/diff</a>
  </li>

  <li>
    <a href="#api_charts/flow"><i class="icon-chevron-right"></i>charts/flow</a>
  </li>

  <li>
    <a href="#api_charts/force"><i class="icon-chevron-right"></i>charts/force</a>
  </li>

  <li>
    <a href="#api_charts/histogram"><i class="icon-chevron-right"></i>charts/histogram</a>
  </li>

  <li>
    <a href="#api_charts/line"><i class="icon-chevron-right"></i>charts/line</a>
  </li>

  <li>
    <a href="#api_charts/matrix"><i class="icon-chevron-right"></i>charts/matrix</a>
  </li>

  <li>
    <a href="#api_charts/parallel"><i class="icon-chevron-right"></i>charts/parallel</a>
  </li>

  <li>
    <a href="#api_charts/pie"><i class="icon-chevron-right"></i>charts/pie</a>
  </li>

  <li>
    <a href="#api_charts/scatterplotMatrix"><i class="icon-chevron-right"></i>charts/scatterplotMatrix</a>
  </li>

  <li>
    <a href="#api_charts/stream"><i class="icon-chevron-right"></i>charts/stream</a>
  </li>

  <li>
    <a href="#api_charts/tree"><i class="icon-chevron-right"></i>charts/tree</a>
  </li>

  <li>
    <a href="#api_charts/treemap"><i class="icon-chevron-right"></i>charts/treemap</a>
  </li>

</ul>

    </div>
    <div class="span9">
      
        <section id="api_datav" class="api">
  <h2>datav: API索引</h2>
  <ul class="indexs">
  
    <li>
      <a href="#_DataV">DataV</a>
    </li>

    <li>
      <a href="#DataV_version">version</a>
    </li>

    <li>
      <a href="#DataV_Themes">Themes</a>
    </li>

    <li>
      <a href="#DataV.Themes_get">get</a>
    </li>

    <li>
      <a href="#DataV.Themes_add">add</a>
    </li>

    <li>
      <a href="#DataV_changeTheme">changeTheme</a>
    </li>

    <li>
      <a href="#DataV_getColor">getColor</a>
    </li>

    <li>
      <a href="#DataV_getDiscreteColor">getDiscreteColor</a>
    </li>

    <li>
      <a href="#DataV_gradientColor">gradientColor</a>
    </li>

    <li>
      <a href="#DataV_json">json</a>
    </li>

    <li>
      <a href="#DataV_csv">csv</a>
    </li>

    <li>
      <a href="#DataV_isNumeric">isNumeric</a>
    </li>

    <li>
      <a href="#DataV_extend">extend</a>
    </li>

    <li>
      <a href="#_Chart">Chart</a>
    </li>

    <li>
      <a href="#_getType">getType</a>
    </li>

    <li>
      <a href="#_checkContainer">checkContainer</a>
    </li>

    <li>
      <a href="#_setOptions">setOptions</a>
    </li>

    <li>
      <a href="#_plug">plug</a>
    </li>

    <li>
      <a href="#_unplug">unplug</a>
    </li>

    <li>
      <a href="#DataV_FloatTag">FloatTag</a>
    </li>

  </ul>
  <hr />

  

  <table class="table">
  

  
  </table>
  
  
  <h3 id="_DataV">
    DataV
  </h3>
  

  <p>DataV全局命名空间对象定义</p>

  <table class="table">
  
    <tr>
      <td>函数</td>
      <td>DataV()</td> 
      <td></td>
      <td>DataV</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>var DataV = function () {};</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="DataV_version">
    version
  </h3>
  

  <p>版本号</p>

  <table class="table">
  
    <tr>
      <td>属性</td>
      <td>DataV.version</td> 
      <td>DataV</td>
      <td>version</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>DataV.version = &quot;0.0.1&quot;;</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="DataV_Themes">
    Themes
  </h3>
  

  <p>全局主题对象</p>

  <table class="table">
  
    <tr>
      <td>属性</td>
      <td>DataV.Themes</td> 
      <td>DataV</td>
      <td>Themes</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>DataV.Themes = {};</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="DataV.Themes_get">
    get
  </h3>
  

  <p>获取当前主题的属性</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>DataV.Themes.get()</td> 
      <td>DataV.Themes</td>
      <td>get</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>Mix</td>
      <td colspan="2">返回当前主题的属性值</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>DataV.Themes.get = function (key) {
        var themeName = DataV.Themes.current || &quot;default&quot;;
        if (!DataV.Themes._currentTheme) {
            DataV.Themes._currentTheme = DataV.Themes[themeName];
        }
        return DataV.Themes._currentTheme[key];
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="DataV.Themes_add">
    add
  </h3>
  

  <p>添加自定义主题</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>DataV.Themes.add()</td> 
      <td>DataV.Themes</td>
      <td>add</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>themeName(String)</td>
      <td colspan="2">主题名称</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>theme(Object)</td>
      <td colspan="2">主题对象json, contain attribute &quot;COLOR_ARGS&quot;, theme.COLOR_ARGS is a 2-d array;</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>DataV.Themes.add = function () {
        var args = [].slice.call(arguments, 0);
        theme = args.pop();
        if (arguments.length &lt; 2) {
            throw new Error(&quot;Arguments format error. should be: (themsName, theme)&quot;);
        } else if (typeof theme !== &quot;object&quot;) {
            throw new Error(&quot;second argument theme should be a json object&quot;);
        } else if (!theme[&quot;COLOR_ARGS&quot;]) {
            throw new Error(&quot;theme.COLOR_ARGS needed&quot;);
        } else if (!theme[&quot;COLOR_ARGS&quot;] instanceof Array) {
            throw new Error(&quot;theme.COLOR_ARGS should be an array&quot;);
        } else if (!(theme[&quot;COLOR_ARGS&quot;][0] instanceof Array)) {
            throw new Error(&quot;theme.COLOR_ARGS[0] should be an array&quot;);
        }
        for (var i = 0, l = args.length; i &lt; l; i++) {
            var _themeName = args[i];
            if (DataV.Themes.hasOwnProperty(_themeName)) {
                throw new Error(&quot;The &quot; + _themeName + &quot; has been defined&quot;);
            }
            DataV.Themes[_themeName] = theme;
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="DataV_changeTheme">
    changeTheme
  </h3>
  

  <p>切换当前主题</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>DataV.changeTheme()</td> 
      <td>DataV</td>
      <td>changeTheme</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>themeName(String)</td>
      <td colspan="2">主题名称</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>Boolean</td>
      <td colspan="2">返回是否切换成功</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>DataV.changeTheme = function (themeName) {
        var ret = DataV.Themes[themeName];
        if (ret) {
            DataV.Themes.current = themeName;
            DataV.Themes._currentTheme = null;
        }
        return !!ret;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="DataV_getColor">
    getColor
  </h3>
  

  <p>获取当前主题的颜色配置</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>DataV.getColor()</td> 
      <td>DataV</td>
      <td>getColor</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>Array</td>
      <td colspan="2">颜色参数列表</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>DataV.getColor = function () {
        var theme = DataV.Themes;
        var color = theme.get(&quot;COLOR_ARGS&quot;);
        return color;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="DataV_getDiscreteColor">
    getDiscreteColor
  </h3>
  

  <p>根据当前主题的颜色配置方案，获取生成离散颜色的函数</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>DataV.getDiscreteColor()</td> 
      <td>DataV</td>
      <td>getDiscreteColor</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>Function</td>
      <td colspan="2">离散函数</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>DataV.getDiscreteColor = function () {
        var color = DataV.getColor();
        if (!_.isArray(color)) {
            throw new Error(&quot;The color should be Array&quot;);
        }
        var colorCount = color.length;
        var gotColor = [];

        if (_.isArray(color[0])) {
            for (var i = 0; i &lt; colorLineCount ; i++) {
                getColor.push(color[i][0]);
            }
        } else {
            gotColor = color;
        }

        return function (num) {
            var thisColor = gotColor;
            var thisColorCount = colorCount;

            return thisColor[num % thisolorCount];
        };
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="DataV_gradientColor">
    gradientColor
  </h3>
  

  <p>获取渐变颜色，用于生成渐变效果</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>DataV.gradientColor()</td> 
      <td>DataV</td>
      <td>gradientColor</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>color(Array)</td>
      <td colspan="2">颜色数组</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>method(String)</td>
      <td colspan="2">生成渐变色的方法，默认值为normal。如果为normal将采用D3的interpolateRgb算法，如果为special，则用Rapheal的HSB算法</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>Function</td>
      <td colspan="2">返回生成算法</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>DataV.gradientColor = function (color, method) {
        if (!_.isArray(color)) {
            throw new Error(&quot;The color should be Array&quot;);
        }

        var startColor = color[0];
        var colorColor;
        var colorCount = color.length;

        var hsb;
        if (colorCount === 1) {
            hsb = Raphael.color(color[0]);
            endColor = Raphael.hsb(hsb.h / 360, (hsb.s -30) / 100, 1);
        } else {
            endColor = color[colorCount - 1];
        }

        method = method || &quot;normal &quot;;

        if (method === &quot;special&quot;) {
            return function (num) {
                var startHSB = Raphael.color(startColor);
                var endHSB = Raphael.color(endColor);
                var startH = startHSB.h * 360;
                var endH = endHSB.h * 360;
                var startNum = startHSB.h * 20;
                var endNum = endHSB.h * 20;

                var dH;
                var dNum;
                if (startNum &gt;= endNum) {
                    dH = 360 - startH + endH;
                    dNum = colorCount - startNum + endNum;
                } else {
                    dH = endH - startH;
                    dNum = endNum - startNum;
                }
                
                var h = (startH + dH * num) / 360;
                var s = (70 + Math.abs(4 - (startNum + dNum * num) % 8) * 5) / 100;
                var b = (100 - Math.abs(4 - (startNum + dNum * num) % 8) * 5) / 100;

                return Raphael.hsb(h, s, b);
            };
        } else {
            return d3.interpolateRgb.apply(null, [startColor, endColor]);
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="DataV_json">
    json
  </h3>
  

  <p>请求一个JSON文件</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>DataV.json()</td> 
      <td>DataV</td>
      <td>json</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>url(String)</td>
      <td colspan="2">JSON文件地址</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>callback(Function)</td>
      <td colspan="2">回调函数</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>DataV.json = function (url, callback) {
        d3.json(url, callback);
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="DataV_csv">
    csv
  </h3>
  

  <p>请求一个CSV文件，并解析</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>DataV.csv()</td> 
      <td>DataV</td>
      <td>csv</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>url(String)</td>
      <td colspan="2">CSV文件地址</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>callback(Function)</td>
      <td colspan="2">回调函数，得到解析后的结果</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>DataV.csv = function (url, callback) {
        d3.text(url, &quot;text/csv&quot;, function (text) {
            callback(text &amp;&amp; d3.csv.parseRows(text));
        });
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="DataV_isNumeric">
    isNumeric
  </h3>
  

  <p>判断输入是否是数字</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>DataV.isNumeric()</td> 
      <td>DataV</td>
      <td>isNumeric</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>obj(Mix)</td>
      <td colspan="2">输入内容</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>Boolean</td>
      <td colspan="2">返回输入是否是数字</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>DataV.isNumeric = function (obj) {
        return !isNaN(parseFloat(obj)) &amp;&amp; isFinite(obj);
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="DataV_extend">
    extend
  </h3>
  

  <p>继承</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>DataV.extend()</td> 
      <td>DataV</td>
      <td>extend</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>parent(Function)</td>
      <td colspan="2">父类</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>properties(Object)</td>
      <td colspan="2">新属性</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>Function</td>
      <td colspan="2">新的子类</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>DataV.extend = function (parent, properties) {
        if (typeof parent !== &quot;function&quot;) {
            properties = parent;
            parent = function () {};
        }

        properties = properties || {};
        var sub = function () {
            // Call the parent constructor.
            parent.apply(this, arguments);
            // Only call initialize in self constructor.
            if (this.constructor === parent &amp;&amp; this.initialize) {
                this.initialize.apply(this, arguments);
            }
        };
        sub.prototype = new parent();
        sub.prototype.constructor = parent;
        $.extend(sub.prototype, properties);
        return sub;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_Chart">
    Chart
  </h3>
  

  <p>所有Chart的源定义</p>

<h2>Examples</h2>

<div class="highlight"><pre lang="">   var Stream = DataV.extend(DataV.Chart, {
       initialize: function () {
           this.type = "Stream";
       },
       clearCanvas: function () {
           this.canvas.clear();
           this.legend.innerHTML = "";
       }
   });
</pre></div>

  <table class="table">
  
    <tr>
      <td>声明</td>
      <td>Chart</td> 
      <td></td>
      <td>Chart</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>var Chart = DataV.extend(EventProxy, {
        type: &quot;Chart&quot;,
        initialize: function (node, options) {
            this.defaults = {};
            this.plugins = {};
        }
    });</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_getType">
    getType
  </h3>
  

  <p>返回当前Chart的类型</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Chart.prototype.getType()</td> 
      <td></td>
      <td>getType</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>String</td>
      <td colspan="2">Chart类型</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Chart.prototype.getType = function () {
        return this.type;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_checkContainer">
    checkContainer
  </h3>
  

  <p>如果node是字符串，会当作ID进行查找。<br />如果是DOM元素，直接返回该元素。<br />如果是jQuery对象，返回对象中的第一个元素。<br />如果节点不存在，则抛出异常</p>

<h2>Examples</h2>

<div class="highlight"><pre lang="">chart.checkContainer("id");
chart.checkContainer(document.getElementById("id"));
chart.checkContainer($("#id"));
</pre></div>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Chart.prototype.checkContainer()</td> 
      <td></td>
      <td>checkContainer</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>node(Mix)</td>
      <td colspan="2">The element Id or Dom element</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>Object</td>
      <td colspan="2">返回找到的DOM节点</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Chart.prototype.checkContainer = function (node) {
        var ret = null;

        if (typeof node === &quot;string&quot;) {
            ret = document.getElementById(node);
        } else if (node.nodeName) { //DOM-element
            ret = node;
        } else if (node instanceof jQuery &amp;&amp; node.size() &gt; 0) {
            ret = node[0];
        }
        if (!ret) {
            throw new Error(&quot;Please specify which node to render.&quot;);
        }
        return ret;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setOptions">
    setOptions
  </h3>
  

  <p>设置自定义选项</p>

<h2>Examples</h2>

<p>Set width 500px, height 600px;</p>

<div class="highlight"><pre lang="">{"width": 500, "height": 600}
</pre></div>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Chart.prototype.setOptions()</td> 
      <td></td>
      <td>setOptions</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>options(Object)</td>
      <td colspan="2">自定义选项对象</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>Object</td>
      <td colspan="2">覆盖后的图表选项对象</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Chart.prototype.setOptions = function (options) {
        return _.extend(this.defaults, options);
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_plug">
    plug
  </h3>
  

  <p>添加插件方法到实例对象上</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Chart.prototype.plug()</td> 
      <td></td>
      <td>plug</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>name(String)</td>
      <td colspan="2">plugin name</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>fn(Function)</td>
      <td colspan="2">plugin function</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>Object</td>
      <td colspan="2">A reference to the host object</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Chart.prototype.plug = function (name, fn) {
        this[name] = fn;
        this.plugins[name] = fn;
        return this;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_unplug">
    unplug
  </h3>
  

  <p>从实例上移除插件方法</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Chart.prototype.unplug()</td> 
      <td></td>
      <td>unplug</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>plugin(String)</td>
      <td colspan="2">The namespace of the plugin</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>Object</td>
      <td colspan="2">A reference to the host object</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Chart.prototype.unplug = function (name) {
        if (this.plugins.hasOwnProperty(name)) {
            delete this.plugins[name];
            delete this[name];
        }
        return this;
    };

    DataV.Chart = Chart;</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="DataV_FloatTag">
    FloatTag
  </h3>
  

  <p>浮动标签</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>DataV.FloatTag()</td> 
      <td>DataV</td>
      <td>FloatTag</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>DataV.FloatTag = function () {
        var _mousemove = function (e) {
            var jqNode = e.data.jqNode;
            var container = e.data.container;
            var mouseToFloatTag = {x: 20, y: 20};
            var offset = $(container).offset();
            if (!(e.pageX &amp;&amp; e.pageY)) {return false;}
            var x = e.pageX - offset.left,
                y = e.pageY - offset.top;
            var position = $(container).position();

            setContent.call(this);

            //set floatTag location
            floatTagWidth = jqNode.outerWidth();
            floatTagHeight = jqNode.outerHeight();
            if (floatTagWidth + x + 2 * mouseToFloatTag.x &lt;=  $(container).width()) {
                x += mouseToFloatTag.x;
            } else {
                x = x - floatTagWidth - mouseToFloatTag.x;
            }
            if (y &gt;= floatTagHeight + mouseToFloatTag.y) {
                y = y - mouseToFloatTag.y - floatTagHeight;
            } else {
                y += mouseToFloatTag.y;
            }
            jqNode.css(&quot;left&quot;,  x  + &quot;px&quot;);
            jqNode.css(&quot;top&quot;,  y + &quot;px&quot;);
        };

        var setContent = function () {};

        function floatTag(cont) {
            var container = cont;
            var jqNode = $(&quot;&lt;div/&gt;&quot;).css({
                &quot;border&quot;: &quot;1px solid&quot;,
                &quot;border-color&quot;: $.browser.msie ? &quot;rgb(0, 0, 0)&quot; : &quot;rgba(0, 0, 0, 0.8)&quot;,
                &quot;background-color&quot;: $.browser.msie ? &quot;rgb(0, 0, 0)&quot; : &quot;rgba(0, 0, 0, 0.75)&quot;,
                &quot;color&quot;: &quot;white&quot;,
                &quot;border-radius&quot;: &quot;2px&quot;,
                &quot;padding&quot;: &quot;12px 8px&quot;,
                //&quot;line-height&quot;: &quot;170%&quot;,
                //&quot;opacity&quot;: 0.7,
                &quot;font-size&quot;: &quot;12px&quot;,
                &quot;box-shadow&quot;: &quot;3px 3px 6px 0px rgba(0,0,0,0.58)&quot;,
                &quot;font-familiy&quot;: &quot;宋体&quot;,
                &quot;z-index&quot;: 10000,
                &quot;text-align&quot;: &quot;center&quot;,
                &quot;visibility&quot;: &quot;hidden&quot;,
                &quot;position&quot;: &quot;absolute&quot;
            });
            $(container).append(jqNode)
                .mousemove({&quot;jqNode&quot;: jqNode, &quot;container&quot;: container}, _mousemove);
            return jqNode;
        }

        floatTag.setContent = function (sc) {
            if (arguments.length === 0) {
                return setContent;
            }
            setContent = sc;
        };
        return floatTag;
    };

    DataV.sum = function (list, iterator) {
        var count = 0;
        var i, l;
        if (typeof iterator === 'undefined') {
            for (i = 0, l = list.length; i &lt; l; i++) {
                count += list[i];
            }
        } else if (typeof iterator === &quot;function&quot;) {
            for (i = 0, l = list.length; i &lt; l; i++) {
                count += iterator(list[i]);
            }
        } else if (typeof iterator === &quot;string&quot; || typeof iterator === 'number') {
            for (i = 0, l = list.length; i &lt; l; i++) {
                count += iterator(list[i][iterator]);
            }
        } else {
            throw new Error(&quot;iterator error&quot;);
        }
        return count;
    };

    return DataV;
});</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/axis" class="api">
  <h2>charts/axis: API索引</h2>
  <ul class="indexs">
  
    <li>
      <a href="#_d3_scaleExtent">d3_scaleExtent</a>
    </li>

    <li>
      <a href="#_d3_scaleRange">d3_scaleRange</a>
    </li>

    <li>
      <a href="#_d3_svg_axisSubdivide">d3_svg_axisSubdivide</a>
    </li>

    <li>
      <a href="#_axis">axis</a>
    </li>

    <li>
      <a href="#axis_scale">scale</a>
    </li>

    <li>
      <a href="#axis_orient">orient</a>
    </li>

    <li>
      <a href="#axis_ticks">ticks</a>
    </li>

    <li>
      <a href="#axis_tickFormat">tickFormat</a>
    </li>

    <li>
      <a href="#axis_tickSize">tickSize</a>
    </li>

    <li>
      <a href="#axis_tickPadding">tickPadding</a>
    </li>

    <li>
      <a href="#axis_tickSubdivide">tickSubdivide</a>
    </li>

    <li>
      <a href="#axis_tickAttr">tickAttr</a>
    </li>

    <li>
      <a href="#axis_tickTextAttr">tickTextAttr</a>
    </li>

    <li>
      <a href="#axis_minorTickAttr">minorTickAttr</a>
    </li>

    <li>
      <a href="#axis_domainAttr">domainAttr</a>
    </li>

  </ul>
  <hr />

  

  <table class="table">
  

  
  </table>
  
  
  <h3 id="_d3_scaleExtent">
    d3_scaleExtent
  </h3>
  

  <p>function from d3, get scaleRange of an ordinal scale</p>

  <table class="table">
  
    <tr>
      <td>函数</td>
      <td>d3_scaleExtent()</td> 
      <td></td>
      <td>d3_scaleExtent</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>domain(Array)</td>
      <td colspan="2">ordinal scale's range</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>function d3_scaleExtent(domain) {
        var start = domain[0], stop = domain[domain.length - 1];
        return start &lt; stop ? [start, stop] : [stop, start];
    }</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_d3_scaleRange">
    d3_scaleRange
  </h3>
  

  <p>function from d3, get scaleRange of a scale</p>

  <table class="table">
  
    <tr>
      <td>函数</td>
      <td>d3_scaleRange()</td> 
      <td></td>
      <td>d3_scaleRange</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>function d3_scaleRange(scale) {
        return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
    }</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_d3_svg_axisSubdivide">
    d3_svg_axisSubdivide
  </h3>
  

  <p>function from d3, get subticks</p>

  <table class="table">
  
    <tr>
      <td>函数</td>
      <td>d3_svg_axisSubdivide()</td> 
      <td></td>
      <td>d3_svg_axisSubdivide</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>scale(scale,)</td>
      <td colspan="2"></td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>major(ticks,)</td>
      <td colspan="2">ticks of scale</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>number(m,)</td>
      <td colspan="2">of subdivide</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>function d3_svg_axisSubdivide(scale, ticks, m) {
        var subticks = [];
        if (m &amp;&amp; ticks.length &gt; 1) {
            var extent = d3_scaleExtent(scale.domain()),
                i = -1,
                n = ticks.length,
                d = (ticks[1] - ticks[0]) / ++m,
                j,
                v;
            while (++i &lt; n) {
                for (j = m; --j &gt; 0;) {
                    if ((v = +ticks[i] - j * d) &gt;= extent[0]) {
                        subticks.push(v);
                    }
                }
            }
            for (--i, j = 0; ++j &lt; m &amp;&amp; (v = +ticks[i] + j * d) &lt; extent[1];) {
                subticks.push(v);
            }
        }
        return subticks;
    }

    var Axis = function () {
        var scale = d3.scale.linear(),
            orient = &quot;bottom&quot;,
            tickMajorSize = 6,
            tickMinorSize = 6,
            tickEndSize = 6,
            tickPadding = 3,
            tickArguments_ = [10],
            tickFormat_,
            tickSubdivide = 0,

            tickAttr_ = {},
            tickTextAttr_ = {},
            minorTickAttr_ = {},
            domainAttr_ = {};</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_axis">
    axis
  </h3>
  

  <p>@param paper: raphael's paper object.</p>

  <table class="table">
  
    <tr>
      <td>函数</td>
      <td>axis()</td> 
      <td></td>
      <td>axis</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>axisSet:</td>
      <td colspan="2">raphael's set object.</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>function axis(paper) {
            // Ticks for quantitative scale, or domain values for ordinal scale.
            var ticks = scale.ticks ? scale.ticks.apply(scale, tickArguments_) : scale.domain(),
                tickFormat = tickFormat_ === undefined ?
                    (scale.tickFormat ?
                        scale.tickFormat.apply(scale, tickArguments_)
                        : String)
                    : tickFormat_;

            var subticks = d3_svg_axisSubdivide(scale, ticks, tickSubdivide);
            var range = d3_scaleRange(scale);
        
            var axisSet = paper.set();

            switch (orient) {
            case &quot;bottom&quot;:
                subticks.forEach(function (d, i, arr) {
                    var tickX = scale.ticks ? scale(d) : scale(d) + scale.rangeBand() / 2;
                    axisSet.push(paper
                        .path(&quot;M&quot; + tickX + &quot;,&quot; + tickMinorSize + &quot;V0&quot;)
                        .attr(minorTickAttr_));
                });
                ticks.forEach(function (d, i, arr) {
                    var tickX = scale.ticks ? scale(d) : scale(d) + scale.rangeBand() / 2;
                    axisSet.push(paper
                        .path(&quot;M&quot; + tickX + &quot;,&quot; + tickMajorSize + &quot;V0&quot;)
                        .attr(tickAttr_));
                    axisSet.push(paper
                        .text(tickX,  Math.max(tickMajorSize, 0) + tickPadding + 2,
                            typeof tickFormat === &quot;function&quot; ? tickFormat(d) : tickFormat)
                        .attr({&quot;text-anchor&quot;: &quot;middle&quot;})
                        .attr(tickTextAttr_));
                });
                axisSet.push(paper
                    .path(&quot;M&quot; + range[0] + &quot;,&quot; + tickEndSize + &quot;V0H&quot; + range[1] + &quot;V&quot; + tickEndSize)
                    .attr(domainAttr_));
                break;

            case &quot;top&quot;:
                subticks.forEach(function (d, i, arr) {
                    var tickX = scale.ticks ? scale(d) : scale(d) + scale.rangeBand() / 2;
                    axisSet.push(paper
                        .path(&quot;M&quot; + tickX + &quot;,&quot; + -tickMinorSize + &quot;V0&quot;)
                        .attr(minorTickAttr_));
                });
                ticks.forEach(function (d, i, arr) {
                    var tickX = scale.ticks ? scale(d) : scale(d) + scale.rangeBand() / 2;
                    axisSet.push(paper
                        .path(&quot;M&quot; + tickX + &quot;,&quot; + -tickMajorSize + &quot;V0&quot;)
                        .attr(tickAttr_));
                    axisSet.push(paper
                        .text(tickX,  -(Math.max(tickMajorSize, 0) + tickPadding + 2),
                            typeof tickFormat === &quot;function&quot; ? tickFormat(d) : tickFormat)
                        .attr({&quot;text-anchor&quot;: &quot;middle&quot;})
                        .attr(tickTextAttr_));
                });
                axisSet.push(paper
                    .path(&quot;M&quot; + range[0] + &quot;,&quot; + -tickEndSize + &quot;V0H&quot; + range[1] + &quot;V&quot; + -tickEndSize)
                    .attr(domainAttr_));
                break;

            case &quot;left&quot;:
                subticks.forEach(function (d, i, arr) {
                    var tickY = scale.ticks ? scale(d) : scale(d) + scale.rangeBand() / 2;
                    axisSet.push(paper
                        .path(&quot;M&quot; + -tickMinorSize + &quot;,&quot; + tickY + &quot;H0&quot;)
                        .attr(minorTickAttr_));
                });
                ticks.forEach(function (d, i, arr) {
                    var tickY = scale.ticks ? scale(d) : scale(d) + scale.rangeBand() / 2;
                    axisSet.push(paper
                        .path(&quot;M&quot; + -tickMajorSize + &quot;,&quot; + tickY + &quot;H0&quot;)
                        .attr(tickAttr_));
                    axisSet.push(paper
                        .text(-(Math.max(tickMajorSize, 0) + tickPadding),  tickY,
                            typeof tickFormat === &quot;function&quot; ? tickFormat(d) : tickFormat)
                        .attr({&quot;text-anchor&quot;: &quot;end&quot;})
                        .attr(tickTextAttr_));
                });
                axisSet.push(paper
                    .path(&quot;M&quot; + -tickEndSize + &quot;,&quot; + range[0] + &quot;H0V&quot; + range[1] + &quot;H&quot; + -tickEndSize)
                    .attr(domainAttr_));
                break;

            case &quot;right&quot;:
                subticks.forEach(function (d, i, arr) {
                    var tickY = scale.ticks ? scale(d) : scale(d) + scale.rangeBand() / 2;
                    axisSet.push(paper
                        .path(&quot;M&quot; + tickMinorSize + &quot;,&quot; + tickY + &quot;H0&quot;)
                        .attr(minorTickAttr_));
                });
                ticks.forEach(function (d, i, arr) {
                    var tickY = scale.ticks ? scale(d) : scale(d) + scale.rangeBand() / 2;
                    axisSet.push(paper
                        .path(&quot;M&quot; + tickMajorSize + &quot;,&quot; + tickY + &quot;H0&quot;)
                        .attr(tickAttr_));
                    axisSet.push(paper
                        .text(Math.max(tickMajorSize, 0) + tickPadding,  tickY,
                            typeof tickFormat === &quot;function&quot; ? tickFormat(d) : tickFormat)
                        .attr({&quot;text-anchor&quot;: &quot;start&quot;})
                        .attr(tickTextAttr_));
                });
                axisSet.push(paper
                    .path(&quot;M&quot; + tickEndSize + &quot;,&quot; + range[0] + &quot;H0V&quot; + range[1] + &quot;H&quot; + tickEndSize)
                    .attr(domainAttr_));
                break;
            }

            return axisSet;
        }</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="axis_scale">
    scale
  </h3>
  

  <p>get or set axis' scale.</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>axis.scale()</td> 
      <td>axis</td>
      <td>scale</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>axis.scale = function (x) {
            if (!arguments.length) {
                return scale;
            }
            scale = x;
            return axis;
        };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="axis_orient">
    orient
  </h3>
  

  <p>get or set axis' orinet: "bottom", "top", "left", "right", default orient is bottom.</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>axis.orient()</td> 
      <td>axis</td>
      <td>orient</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>axis.orient = function (x) {
            if (!arguments.length) {
                return orient;
            }
            orient = x;
            return axis;
        };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="axis_ticks">
    ticks
  </h3>
  

  <p>get or set axis' ticks number.</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>axis.ticks()</td> 
      <td>axis</td>
      <td>ticks</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>axis.ticks = function () {
            if (!arguments.length) {
                return tickArguments_;
            }
            tickArguments_ = arguments;
            return axis;
        };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="axis_tickFormat">
    tickFormat
  </h3>
  

  <p>get or set axis' ticks format function, it's a function change format style.<br />from one string format to another string format.</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>axis.tickFormat()</td> 
      <td>axis</td>
      <td>tickFormat</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>axis.tickFormat = function (x) {
            if (!arguments.length) {
                return tickFormat_;
            }
            tickFormat_ = x;
            return axis;
        };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="axis_tickSize">
    tickSize
  </h3>
  

  <p>get or set axis' tick size(length of tick line, unit: px).</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>axis.tickSize()</td> 
      <td>axis</td>
      <td>tickSize</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>===(arguments.length)</td>
      <td colspan="2">0, get axis' major tick size.</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>===(arguments.length)</td>
      <td colspan="2">1, set axis' all tick sizes as x.</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>===(arguments.length)</td>
      <td colspan="2">2, get axis' major tick size as x, minor and end size as y.</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>===(arguments.length)</td>
      <td colspan="2">3, get axis' major tick size as x, minor size as y, end size as z.</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>axis.tickSize = function (x, y, z) {
            if (!arguments.length) {
                return tickMajorSize;
            }
            var n = arguments.length - 1;
            tickMajorSize = +x;
            tickMinorSize = n &gt; 1 ? +y : tickMajorSize;
            tickEndSize = n &gt; 0 ? +arguments[n] : tickMajorSize;
            return axis;
        };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="axis_tickPadding">
    tickPadding
  </h3>
  

  <p>get or set axis' tick padding(the distance between tick text and axis).</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>axis.tickPadding()</td> 
      <td>axis</td>
      <td>tickPadding</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>is(x)</td>
      <td colspan="2">a number, unit is px;</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>axis.tickPadding = function (x) {
            if (!arguments.length) {
                return tickPadding;
            }
            tickPadding = +x;
            return axis;
        };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="axis_tickSubdivide">
    tickSubdivide
  </h3>
  

  <p>get or set axis' sub tick divide number(divide number between two major ticks).</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>axis.tickSubdivide()</td> 
      <td>axis</td>
      <td>tickSubdivide</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>axis.tickSubdivide = function (x) {
            if (!arguments.length) {
                return tickSubdivide;
            }
            tickSubdivide = +x;
            return axis;
        };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="axis_tickAttr">
    tickAttr
  </h3>
  

  <p>get or set axis' tick attribute(Raphael format).</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>axis.tickAttr()</td> 
      <td>axis</td>
      <td>tickAttr</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>axis.tickAttr = function (x) {
            if (!arguments.length) {
                return tickAttr_;
            }
            tickAttr_ = x;
            return axis;
        };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="axis_tickTextAttr">
    tickTextAttr
  </h3>
  

  <p>get or set axis' tick text attribute(Raphael format).</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>axis.tickTextAttr()</td> 
      <td>axis</td>
      <td>tickTextAttr</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>axis.tickTextAttr = function (x) {
            if (!arguments.length) {
                return tickTextAttr_;
            }
            tickTextAttr_ = x;
            return axis;
        };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="axis_minorTickAttr">
    minorTickAttr
  </h3>
  

  <p>get or set axis' minor tick attribute(Raphael format).</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>axis.minorTickAttr()</td> 
      <td>axis</td>
      <td>minorTickAttr</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>axis.minorTickAttr = function (x) {
            if (!arguments.length) {
                return minorTickAttr_;
            }
            minorTickAttr_ = x;
            return axis;
        };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="axis_domainAttr">
    domainAttr
  </h3>
  

  <p>get or set axis' domain(axis line) attribute(Raphael format).</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>axis.domainAttr()</td> 
      <td>axis</td>
      <td>domainAttr</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>axis.domainAttr = function (x) {
            if (!arguments.length) {
                return domainAttr_;
            }
            domainAttr_ = x;
            return axis;
        };
      
        return axis;
    };

    return Axis;
});</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/brush" class="api">
  <h2>charts/brush: API索引</h2>
  <ul class="indexs">
  
    <li>
      <a href="#_d3_svg_brushRedrawX">d3_svg_brushRedrawX</a>
    </li>

    <li>
      <a href="#_d3_svg_brushRedrawY">d3_svg_brushRedrawY</a>
    </li>

    <li>
      <a href="#_d3_scaleExtent">d3_scaleExtent</a>
    </li>

    <li>
      <a href="#_d3_scaleRange">d3_scaleRange</a>
    </li>

    <li>
      <a href="#_d3_svg_brushMove1">d3_svg_brushMove1</a>
    </li>

    <li>
      <a href="#_d3_svg_brushMove">d3_svg_brushMove</a>
    </li>

    <li>
      <a href="#_d3_svg_brushKeydown">d3_svg_brushKeydown</a>
    </li>

    <li>
      <a href="#_d3_svg_brushKeyup">d3_svg_brushKeyup</a>
    </li>

    <li>
      <a href="#_d3_svg_brushUp">d3_svg_brushUp</a>
    </li>

  </ul>
  <hr />

  

  <table class="table">
  

  
  </table>
  
  
  <h3 id="_d3_svg_brushRedrawX">
    d3_svg_brushRedrawX
  </h3>
  

  <p>set foreground and resizers' x and width;</p>

  <table class="table">
  
    <tr>
      <td>函数</td>
      <td>d3_svg_brushRedrawX()</td> 
      <td></td>
      <td>d3_svg_brushRedrawX</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>function d3_svg_brushRedrawX(brushEls, extent) {
        brushEls.fg.attr({&quot;x&quot;: extent[0][0],
                        &quot;width&quot;: extent[1][0] - extent[0][0] });
        brushEls.resizerSet.forEach(function (el) {
            var orient = el.data(&quot;resizeOrient&quot;);

            if (orient === &quot;n&quot; ||
                    orient === &quot;s&quot; ||
                    orient === &quot;w&quot; ||
                    orient === &quot;nw&quot; ||
                    orient === &quot;sw&quot;) {
                el.attr({&quot;x&quot;: extent[0][0] - 2});
            } else { // &quot;e&quot; &quot;ne&quot; &quot;se&quot;
                el.attr({&quot;x&quot;: extent[1][0] - 2});
            }
            if (orient === &quot;n&quot; || orient === &quot;s&quot;) {
                el.attr({&quot;width&quot;: extent[1][0] - extent[0][0]});
            }
        });
    }</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_d3_svg_brushRedrawY">
    d3_svg_brushRedrawY
  </h3>
  

  <p>set foreground and resizers' y and height;</p>

  <table class="table">
  
    <tr>
      <td>函数</td>
      <td>d3_svg_brushRedrawY()</td> 
      <td></td>
      <td>d3_svg_brushRedrawY</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>function d3_svg_brushRedrawY(brushEls, extent) {
        brushEls.fg.attr({&quot;y&quot;: extent[0][1],
                        &quot;height&quot;: extent[1][1] - extent[0][1] });
        brushEls.resizerSet.forEach(function (el) {
            var orient = el.data(&quot;resizeOrient&quot;);
            if (orient === &quot;n&quot; ||
                    orient === &quot;e&quot; ||
                    orient === &quot;w&quot; ||
                    orient === &quot;nw&quot; ||
                    orient === &quot;ne&quot;) {
                el.attr({&quot;y&quot;: extent[0][1] - 3});
            } else { // &quot;s&quot; &quot;se&quot; &quot;sw&quot;
                el.attr({&quot;y&quot;: extent[1][1] - 4});
            }
            if (orient === &quot;e&quot; || orient === &quot;w&quot;) {
                el.attr({&quot;height&quot;: extent[1][1] - extent[0][1]});
            }
        });
    }</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_d3_scaleExtent">
    d3_scaleExtent
  </h3>
  

  <p>function from d3, get scaleRange of an ordinal scale</p>

  <table class="table">
  
    <tr>
      <td>函数</td>
      <td>d3_scaleExtent()</td> 
      <td></td>
      <td>d3_scaleExtent</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>ordinal(domain,)</td>
      <td colspan="2">scale's range</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>function d3_scaleExtent(domain) {
        var start = domain[0], stop = domain[domain.length - 1];
        return start &lt; stop ? [start, stop] : [stop, start];
    }</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_d3_scaleRange">
    d3_scaleRange
  </h3>
  

  <p>function from d3, get scaleRange of a scale</p>

  <table class="table">
  
    <tr>
      <td>函数</td>
      <td>d3_scaleRange()</td> 
      <td></td>
      <td>d3_scaleRange</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>function d3_scaleRange(scale) {
        return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
    }</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_d3_svg_brushMove1">
    d3_svg_brushMove1
  </h3>
  

  <p>function from d3, called by d3_svg_brushMove, compute new brush extent after brush moved</p>

  <table class="table">
  
    <tr>
      <td>函数</td>
      <td>d3_svg_brushMove1()</td> 
      <td></td>
      <td>d3_svg_brushMove1</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>function d3_svg_brushMove1(mouse, scale, i) {
        var range = d3_scaleRange(scale),
            r0 = range[0],
            r1 = range[1],
            offset = d3_svg_brushOffset[i],
            size = d3_svg_brushExtent[1][i] - d3_svg_brushExtent[0][i],
            min,
            max;
      
        // When dragging, reduce the range by the extent size and offset.
        if (d3_svg_brushDrag) {
            r0 -= offset;
            r1 -= size + offset;
        }
      
        // Clamp the mouse so that the extent fits within the range extent.
        min = Math.max(r0, Math.min(r1, mouse[i]));
      
        // Compute the new extent bounds.
        if (d3_svg_brushDrag) {
            max = (min += offset) + size;
        } else {
            // If the ALT key is pressed, then preserve the center of the extent.
            if (d3_svg_brushCenter) {
                offset = Math.max(r0, Math.min(r1, 2 * d3_svg_brushCenter[i] - min));
            }
        
            // Compute the min and max of the offset and mouse.
            if (offset &lt; min) {
                max = min;
                min = offset;
            } else {
                max = offset;
            }
        }

        // Update the stored bounds.
        d3_svg_brushExtent[0][i] = min;
        d3_svg_brushExtent[1][i] = max;
    }</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_d3_svg_brushMove">
    d3_svg_brushMove
  </h3>
  

  <p>function from d3, after brush moved, compute new brush extent<br />and redraw foreground and resizer.</p>

  <table class="table">
  
    <tr>
      <td>函数</td>
      <td>d3_svg_brushMove()</td> 
      <td></td>
      <td>d3_svg_brushMove</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>function d3_svg_brushMove(e) {
        if (d3_svg_brushOffset) {
            var bgOffset = $(d3_svg_brushTarget).offset();
            var mouse = [e.pageX - bgOffset.left, e.pageY - bgOffset.top];
            
            if (!d3_svg_brushDrag) {
                // If needed, determine the center from the current extent.
                if (e.altKey) {
                    if (!d3_svg_brushCenter) {
                        d3_svg_brushCenter = [
                            (d3_svg_brushExtent[0][0] + d3_svg_brushExtent[1][0]) / 2,
                            (d3_svg_brushExtent[0][1] + d3_svg_brushExtent[1][1]) / 2
                        ];
                    }
            
                    // Update the offset, for when the ALT key is released.
                    d3_svg_brushOffset[0] = d3_svg_brushExtent[+(mouse[0] &lt; d3_svg_brushCenter[0])][0];
                    d3_svg_brushOffset[1] = d3_svg_brushExtent[+(mouse[1] &lt; d3_svg_brushCenter[1])][1];
                } else {
                    // When the ALT key is released, we clear the center.
                    d3_svg_brushCenter = null;
                }
            }
        
            // Update the brush extent for each dimension.
            if (d3_svg_brushX) {
                d3_svg_brushMove1(mouse, d3_svg_brushX, 0);
                d3_svg_brushRedrawX(d3_svg_brushEls, d3_svg_brushExtent);
            }
            if (d3_svg_brushY) {
                d3_svg_brushMove1(mouse, d3_svg_brushY, 1);
                d3_svg_brushRedrawY(d3_svg_brushEls, d3_svg_brushExtent);
            }
        
            // Notify listeners.
            d3_svg_brushDispatch(&quot;brush&quot;);
        }
    }</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_d3_svg_brushKeydown">
    d3_svg_brushKeydown
  </h3>
  

  <p>function from d3,<br />reset brush offset if user presses "space" key while brushing a new area,<br />to ensure foreground's size unchanged while position changing.</p>

  <table class="table">
  
    <tr>
      <td>函数</td>
      <td>d3_svg_brushKeydown()</td> 
      <td></td>
      <td>d3_svg_brushKeydown</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>function d3_svg_brushKeydown(e) {
        if (e.keyCode === 32 &amp;&amp; d3_svg_brushTarget &amp;&amp; !d3_svg_brushDrag) {
            d3_svg_brushCenter = null;
            d3_svg_brushOffset[0] -= d3_svg_brushExtent[1][0];
            d3_svg_brushOffset[1] -= d3_svg_brushExtent[1][1];
            d3_svg_brushDrag = 2;
            e.stopPropagation();
        }
    }</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_d3_svg_brushKeyup">
    d3_svg_brushKeyup
  </h3>
  

  <p>function from d3,<br />reset brush offset if "space" key up to restore normal drush state.</p>

  <table class="table">
  
    <tr>
      <td>函数</td>
      <td>d3_svg_brushKeyup()</td> 
      <td></td>
      <td>d3_svg_brushKeyup</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>function d3_svg_brushKeyup(e) {
        if (e.keyCode === 32 &amp;&amp; d3_svg_brushDrag === 2) {
            d3_svg_brushOffset[0] += d3_svg_brushExtent[1][0];
            d3_svg_brushOffset[1] += d3_svg_brushExtent[1][1];
            d3_svg_brushDrag = 0;
            e.stopPropagation();
        }
    }</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_d3_svg_brushUp">
    d3_svg_brushUp
  </h3>
  

  <p>function from d3,<br />mouse up and stop brushing.</p>

  <table class="table">
  
    <tr>
      <td>函数</td>
      <td>d3_svg_brushUp()</td> 
      <td></td>
      <td>d3_svg_brushUp</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>function d3_svg_brushUp(e) {
        if (d3_svg_brushOffset) {
            d3_svg_brushMove(e);
            d3_svg_brushEls.resizerSet.forEach(function (resizer) {
                //adjust all resizers
                var orient = resizer.data(&quot;resizeOrient&quot;);
                var size = d3_svg_brush.empty() ? 0 : 6;
                if (orient === &quot;n&quot; || orient === &quot;s&quot;) {
                    resizer.attr({&quot;height&quot;: size});
                } else {
                    resizer.attr({&quot;width&quot;: size});
                }
            });
            d3_svg_brushDispatch(&quot;brushend&quot;);
            d3_svg_brush =
                d3_svg_brushDispatch =
                d3_svg_brushTarget =
                d3_svg_brushX =
                d3_svg_brushY =
                d3_svg_brushExtent =
                d3_svg_brushDrag =
                d3_svg_brushResize =
                d3_svg_brushCenter =
                d3_svg_brushOffset =
                d3_svg_brushEls = null;
            e.stopPropagation();
        }
    }
    
    var d3_svg_brushCursor = {
        n: &quot;ns-resize&quot;,
        e: &quot;ew-resize&quot;,
        s: &quot;ns-resize&quot;,
        w: &quot;ew-resize&quot;,
        nw: &quot;nwse-resize&quot;,
        ne: &quot;nesw-resize&quot;,
        se: &quot;nwse-resize&quot;,
        sw: &quot;nesw-resize&quot;
    };
    var vml_brushCursor = {
        n: &quot;row-resize&quot;,
        e: &quot;col-resize&quot;,
        s: &quot;row-resize&quot;,
        w: &quot;col-resize&quot;,
        nw: &quot;all-scroll&quot;,
        ne: &quot;all-scroll&quot;,
        se: &quot;all-scroll&quot;,
        sw: &quot;all-scroll&quot;
    };

    var Brush  = function () {
        var event = d3.dispatch(&quot;brushstart&quot;, &quot;brush&quot;, &quot;brushend&quot;),
            x, // x-scale, optional
            y, // y-scale, optional
            extent = [[0, 0], [0, 0]], // [x0, y0], [x1, y1]
            e,
            left,
            top,
            width,
            height,
            backgroundAttr = {
                &quot;fill&quot;: &quot;#dddddd&quot;,
                &quot;stroke&quot;: &quot;none&quot;,
                &quot;cursor&quot;: &quot;crosshair&quot;
            },
            foregroundAttr = {
                &quot;fill&quot;: &quot;steelblue&quot;,
                &quot;stroke&quot;: &quot;none&quot;,
                &quot;cursor&quot;: &quot;move&quot;
            },
            brushStart = function () {},
            brushing = function () {},
            brushEnd = function () {},

            brushEls = {},
            brushClass;</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/bubble" class="api">
  <h2>charts/bubble: API索引</h2>
  <ul class="indexs">
  
    <li>
      <a href="#_Bubble">Bubble</a>
    </li>

    <li>
      <a href="#_createCanvas">createCanvas</a>
    </li>

    <li>
      <a href="#_chooseDimensions">chooseDimensions</a>
    </li>

    <li>
      <a href="#_setSource">setSource</a>
    </li>

    <li>
      <a href="#_getScale">getScale</a>
    </li>

    <li>
      <a href="#_renderAxis">renderAxis</a>
    </li>

    <li>
      <a href="#_colorDB">colorDB</a>
    </li>

    <li>
      <a href="#_generatePaths">generatePaths</a>
    </li>

    <li>
      <a href="#_getKeyData">getKeyData</a>
    </li>

    <li>
      <a href="#_getColorData">getColorData</a>
    </li>

    <li>
      <a href="#_initControls">initControls</a>
    </li>

    <li>
      <a href="#_interpolateData">interpolateData</a>
    </li>

    <li>
      <a href="#_uniq">uniq</a>
    </li>

    <li>
      <a href="#_clearAnimation">clearAnimation</a>
    </li>

    <li>
      <a href="#_pause">pause</a>
    </li>

    <li>
      <a href="#_render">render</a>
    </li>

  </ul>
  <hr />

  

  <table class="table">
  

  
  </table>
  
  
  <h3 id="_Bubble">
    Bubble
  </h3>
  

  <p>Recently, bubble graph can represent five dimensions by xaxis,yaxis,size,color and time.<br />You can stop animation by pause() method, start animation by initControls method;<br />you can change animation start time by using global variable  this.startTime;<br />you can visualize a time point's data by generatePaths(time point) method;<br />an inside method drawAllTime(key) is designed for interaction.</p>

  <table class="table">
  
    <tr>
      <td>声明</td>
      <td>Bubble</td> 
      <td></td>
      <td>Bubble</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>var Bubble = DataV.extend(DataV.Chart, {
        initialize: function (node, options) {
            this.type = &quot;Bubble&quot;;
            this.node = this.checkContainer(node);

            // setting display width and height, also they can be changed by options
            this.defaults.width = 800;
            this.defaults.height = 600;
            this.defaults.minRadius = 10;
            this.defaults.maxRadius = 40;
            this.defaults.meshInterval = 20;
            // margin order: left, top, right, bottom
            this.defaults.borderMargin = [200, 30, 0, 80];
            this.defaults.allDimensions = [];
            this.defaults.dimensions = [];
            this.defaults.dimensionType = {};
            this.defaults.dimensionDomain = {};
            this.defaults.dotStrokeColor = {&quot;stroke&quot;: &quot;#fff&quot;};
            this.defaults.colorBarWidth = 40;
            this.defaults.colorBarHeight = 27;
            this.defaults.colorBarBorder = 10;
            this.defaults.skeletonCircleAttr = {
                &quot;fill&quot;: &quot;#000&quot;,
                &quot;fill-opacity&quot;: 0.6,
                &quot;stroke-width&quot;: 0
            };
            this.defaults.skeletonLineAttr = {
                &quot;stroke&quot;: &quot;#000&quot;,
                &quot;stroke-width&quot;: 0.5,
                &quot;stroke-opacity&quot;: 0.5
            };
            this.defaults.colorBarAttr = {
                &quot;stroke&quot;: &quot;#C9C9C9&quot;,
                &quot;stroke-opacity&quot;: 0,
                &quot;r&quot;: 5
            };
            this.defaults.textAttr = {
                &quot;fill&quot;: &quot;#000&quot;,
                &quot;fill-opacity&quot;: 1,
                &quot;font-family&quot;: &quot;雅黑&quot;,
                &quot;font-size&quot;: 12
            };

            this.setOptions(options);
            this.createCanvas();
        }
    });</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_createCanvas">
    createCanvas
  </h3>
  

  <p>create a backCanvas for the visualization</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Bubble.prototype.createCanvas()</td> 
      <td></td>
      <td>createCanvas</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Bubble.prototype.createCanvas = function () {
        var conf = this.defaults;
            m = conf.borderMargin;
        this.backCanvas = new Raphael(this.node, conf.width, conf.height);
        this.foreCanvas = Raphael(this.node, conf.width, conf.height);

        $(this.node).css(&quot;position&quot;, &quot;relative&quot;);
        $(this.foreCanvas.canvas).css({&quot;position&quot;: &quot;absolute&quot;,
            &quot;zIndex&quot;: 2, &quot;left&quot;: m[0], &quot;top&quot;: m[1]});

        canvasStyle = this.node.style;
        canvasStyle.position = &quot;relative&quot;;
        this.floatTag = DataV.FloatTag()(this.node);

        this.floatTag.css({&quot;visibility&quot;: &quot;hidden&quot;});

        $(this.node).append(this.floatTag);
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_chooseDimensions">
    chooseDimensions
  </h3>
  

  <p>choose bubble graph setted visualization dimens orderly</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Bubble.prototype.chooseDimensions()</td> 
      <td></td>
      <td>chooseDimensions</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Bubble.prototype.chooseDimensions = function (dimen) {
        var conf = this.defaults;
        conf.dimensions = [];
        var strInArray = function (str, array) {
            for (var i = 0, l = array.length; i &lt; l; i++){
                if (array[i] === str) {
                    return true;
                }
            }
            return false;
        };

        for(var i = 0, l = dimen.length; i &lt; l; i++){
            if(strInArray(dimen[i], conf.allDimensions)) {
                conf.dimensions.push(dimen[i]);
            }
        }

        this.timeDimen = conf.dimensions[0];
        this.keyDimen = conf.dimensions[1];
        this.xDimen = conf.dimensions[2];
        this.yDimen = conf.dimensions[3];
        this.sizeDimen = conf.dimensions[4];
        this.colorDimen = conf.dimensions[5];

        this.keys = [];
        this.times = [];
        this.timeKeys = [];
        for (var i = 0, l = this.source.length; i &lt; l; i++) {
            this.keys.push(this.source[i][this.keyDimen]);
            this.times.push(this.source[i][this.timeDimen]);
        }

        this.times.uniq();
        this.keys.uniq();
        for (var i = 0, l = this.times.length; i &lt; l; i++) {
            this.timeKeys.push(i);
        }
        this.startTime = 0;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setSource">
    setSource
  </h3>
  

  <p>set source, get dimensions data, dimension type, and dimension domain<br />default visualization dimension is setted here</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Bubble.prototype.setSource()</td> 
      <td></td>
      <td>setSource</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Bubble.prototype.setSource = function (source) {
        var conf = this.defaults;
        conf.allDimensions = source[0];
        // by default all dimensions show
        conf.dimensions = source[0];

        this.source = [];
        for(var i = 1, l = source.length; i &lt; l; i++){
            var dot = {},
                dimen = conf.allDimensions;
            for(var j=0, ll=dimen.length; j &lt; ll; j++){
                dot[dimen[j]] = source[i][j];
            }
            this.source.push(dot);
        }

        // judge dimesions type auto
        conf.dimensionType = {};
        function isNumber(n) {
            return !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);
        }
        for(var i = 0, l = conf.allDimensions.length; i &lt; l; i++){
            var type = &quot;quantitative&quot;;
            for(var j = 1, ll = source.length; j &lt; ll; j++){
                var d = source[j][i];
                if(d &amp;&amp; (! isNumber(d))){
                    type = &quot;ordinal&quot;;
                    break;
                }
            }
            conf.dimensionType[conf.allDimensions[i]] = type;
        }

        // set default dimensionDomain
        for(var i = 0, l = conf.allDimensions.length; i &lt; l; i++){
            var dimen = conf.allDimensions[i];
            if(conf.dimensionType[dimen] === &quot;quantitative&quot;){
                conf.dimensionDomain[dimen] = d3.extent(this.source,
                     function(p){return Math.abs(p[dimen])});
            }else{
                conf.dimensionDomain[dimen] =
                    this.source.map(function(p){return p[dimen]});
            }
        }

        this.timeDimen = conf.dimensions[0];
        this.keyDimen = conf.dimensions[1];
        this.xDimen = conf.dimensions[2];
        this.yDimen = conf.dimensions[3];
        this.sizeDimen = conf.dimensions[4];
        this.colorDimen = conf.dimensions[5];

        this.keys = [];
        this.times = [];
        this.timeKeys = [];
        for (var i = 0, l = this.source.length; i &lt; l; i++) {
            this.keys.push(this.source[i][this.keyDimen]);
            this.times.push(this.source[i][this.timeDimen]);
        }

        this.times.uniq();
        this.keys.uniq();
        for (var i = 0, l = this.times.length; i &lt; l; i++) {
            this.timeKeys.push(i);
        }
        this.startTime = 0;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_getScale">
    getScale
  </h3>
  

  <p>different visualization scale is defined here</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Bubble.prototype.getScale()</td> 
      <td></td>
      <td>getScale</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Bubble.prototype.getScale = function() {
        var conf = this.defaults;
            m = conf.borderMargin,
            w = conf.width - m[0] - m[2],
            h = conf.height - m[1] - m[3],
            colorData = [],
            maxRadius = conf.maxRadius,
            minRadius = conf.minRadius,
            backCanvas = this.backCanvas,
            xDimen = this.xDimen,
            yDimen = this.yDimen,
            sizeDimen = this.sizeDimen,
            colorDimen = this.colorDimen,
            timeDimen = this.timeDimen,
            xMin = conf.dimensionDomain[xDimen][0],
            yMin = conf.dimensionDomain[yDimen][0],
            xMax = conf.dimensionDomain[xDimen][1],
            yMax = conf.dimensionDomain[yDimen][1],
            xBorder = (maxRadius + 30) * (xMax - xMin)/w,
            yBorder = (maxRadius + 30) * (yMax - yMin)/h,
            xDomain = [xMin - xBorder, xMax + xBorder],
            yDomain = [yMin - yBorder, yMax + yBorder];

        this.x = {};
        this.x[xDimen] = d3.scale.linear()
            .domain(xDomain).range([m[0], m[0] + w]);
        this.y = {};
        this.y[yDimen] = d3.scale.linear()
            .domain(yDomain).range([h, 0]);
        this.z = {};
        this.z[sizeDimen] = d3.scale.linear()
            .domain(conf.dimensionDomain[sizeDimen]).range([minRadius, maxRadius]);
        this.c = {};
        this.c[colorDimen] = this.colorDB({mode: &quot;random&quot;, ratio: 0.5});

        for (var i = 0, l = this.keys.length; i &lt; l; i++) {
            c0 = this.getColorData(this.keys[i]);
            colorData.push(c0);
        }
        colorData.uniq();

        // draw colorbar
        var tagArea = [20, (conf.height - m[3] - colorData.length * 23), 200, 220],
            rectBn = backCanvas.set(),
            underBn = [];
        for (var i = 0, l = colorData.length; i &lt; l; i++) {
            var c = this.c[colorDimen](colorData[i]);
            // background to add interaction
            underBn.push(backCanvas.rect(tagArea[0] + 10, tagArea[1] + 10 + (20 + 3) * i, 120, 20)
                .attr({&quot;fill&quot;: &quot;#ebebeb&quot;, &quot;stroke&quot;: &quot;none&quot;}).hide());
            // real colorbar
            backCanvas.rect(tagArea[0] + 10 + 3, tagArea[1] + 10 + (20 + 3) * i + 6, 16, 8)
                .attr({&quot;fill&quot;: c, &quot;stroke&quot;: &quot;none&quot;});
            // colorbar text
            backCanvas.text(tagArea[0] + 10 + 3 + 16 + 8, tagArea[1] + 10 + (20 + 3) * i + 10, colorData[i])
                .attr({&quot;fill&quot;: &quot;black&quot;, &quot;fill-opacity&quot;: 1, &quot;font-family&quot;: &quot;Verdana&quot;, &quot;font-size&quot;: 12})
                .attr({&quot;text-anchor&quot;: &quot;start&quot;});
            // just for interaction -- selction
            rectBn.push(backCanvas.rect(tagArea[0] + 10, tagArea[1] + 10 + (20 + 3) * i, 50, 20)
                .attr({&quot;fill&quot;: &quot;white&quot;, &quot;fill-opacity&quot;: 0, &quot;stroke&quot;: &quot;none&quot;})
                .data(&quot;type&quot;, i).data(&quot;colorType&quot;, colorData[i]));
        }

        // add interaction for colorbar
        this.interactionType = null;
        that = this;
        rectBn.forEach(function (d) {
            d.hover(function () {
                if (!that.interval) {
                    for (var i = 0, l = underBn.length; i &lt; l; i++) {
                        if (i === d.data(&quot;type&quot;)) {
                            underBn[i].show();
                            that.interactionType = d.data(&quot;colorType&quot;);
                            that.generatePaths(Math.ceil(that.startTime));
                        }
                    }
                }
            },
            function () {
                for (var i = 0, l = underBn.length; i &lt; l; i++) {
                    if (i === d.data(&quot;type&quot;)) {
                        underBn[i].hide();
                        that.interactionType = null;
                    }
                }
            });
        });

        // pause, restart and related control function
        // var restart = backCanvas.rect(m[0] - conf.colorBarHeight - 2, m[1] + h + 30, conf.colorBarHeight,
        //     conf.colorBarHeight).attr({&quot;fill&quot;: &quot;#aaa&quot;, &quot;fill-opacity&quot;: 0.9}).attr(conf.dotStrokeColor);
        // var playButtonShadow = backCanvas.rect(0,0,15,15,2).attr({&quot;stroke&quot;: &quot;none&quot;,&quot;fill&quot;: &quot;#606060&quot;, &quot;fill-opacity&quot;:0.4});
        var playButtonBack = backCanvas.rect(0,0,24,24,2).attr({&quot;stroke&quot;: &quot;none&quot;,&quot;fill&quot;: &quot;#d6d6d6&quot;});
        var startPatternPath = &quot;M7,18L19,12L7,6V18z&quot;;
        var stopPatternPathL = &quot;M7,7sh4v10sh-4z&quot;;
        var stopPatternPathR = &quot;M13,7sh4v10sh-4z&quot;;
        // var buttonBack = backCanvas.rect(0,0,24,24).attr({&quot;fill&quot;: &quot;#606060&quot;});
        var startPattern = backCanvas.path(startPatternPath).attr({&quot;stroke-width&quot;: 0, &quot;stroke-linejoin&quot;: &quot;round&quot;, &quot;fill&quot;: &quot;#606060&quot;});
        var stopPattern = backCanvas.set();
        stopPattern.push(backCanvas.path(stopPatternPathL));
        stopPattern.push(backCanvas.path(stopPatternPathR));
        stopPattern.attr({&quot;stroke-width&quot;: 0, &quot;stroke-linejoin&quot;: &quot;round&quot;, &quot;fill&quot;: &quot;#606060&quot;});

        // playButtonShadow.transform(&quot;t&quot; + (m[0] - conf.colorBarHeight + 3 + 4) + &quot;,&quot; + (m[1] + h + 33 + 4));
        playButtonBack.transform(&quot;t&quot; + (m[0] - conf.colorBarHeight) + &quot;,&quot; + (m[1] + h + 33));
        startPattern.transform(&quot;t&quot; + (m[0] - conf.colorBarHeight) + &quot;,&quot; + (m[1] + h + 33));
        stopPattern.transform(&quot;t&quot; + (m[0] - conf.colorBarHeight) + &quot;,&quot; + (m[1] + h + 33));
        startPattern.attr({&quot;stroke-width&quot;: 0, &quot;stroke-linejoin&quot;: &quot;round&quot;, &quot;fill-opacity&quot;: 0});

        var playButton = backCanvas.set();
        playButton.push(playButtonBack);
        playButton.push(startPattern);
        playButton.push(stopPattern);

        // var reTest = backCanvas.path(startPattern).attr({&quot;stroke-linejoin&quot;: &quot;round&quot;}).transform(&quot;t&quot; + (m[0] - conf.colorBarHeight + 3) + &quot;,&quot; + (m[1] + h + 33));
        // backCanvas.path(stopPatternL).attr({&quot;stroke-linejoin&quot;: &quot;round&quot;}).transform(&quot;t&quot; + (m[0] - conf.colorBarHeight + 3) + &quot;,&quot; + (m[1] + h + 33));
        // backCanvas.path(stopButtonL).attr({&quot;stroke-linejoin&quot;: &quot;round&quot;}).transform(&quot;t&quot; + (m[0] - conf.colorBarHeight + 3 + 6) + &quot;,&quot; + (m[1] + h + 33));

        playButton.dblclick(
            function() {
                that.clearAnimation();
                that.render();
            }
        );
        playButton.click(function() {
            if (that.interval) {
                stopPattern.attr({&quot;fill-opacity&quot;: 0});
                startPattern.attr({&quot;fill-opacity&quot;: 1});
                that.pause();
            } else {
                startPattern.attr({&quot;fill-opacity&quot;: 0});
                stopPattern.attr({&quot;fill-opacity&quot;: 1});
                that.initControls();
            }
        });
        playButton.hover(
            function() {
                startPattern.attr({&quot;fill&quot;: &quot;#ffffff&quot;});
                stopPattern.attr({&quot;fill&quot;: &quot;#ffffff&quot;});
            },
            function() {
                startPattern.attr({&quot;fill&quot;: &quot;#606060&quot;});
                stopPattern.attr({&quot;fill&quot;: &quot;#606060&quot;});
            }
        );

    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_renderAxis">
    renderAxis
  </h3>
  

  <p>draw x-axis, y-axis and related parts</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Bubble.prototype.renderAxis()</td> 
      <td></td>
      <td>renderAxis</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Bubble.prototype.renderAxis = function () {
        var conf = this.defaults;
            m = conf.borderMargin,
            w = conf.width - m[0] - m[2],
            h = conf.height - m[1] - m[3],
            colorData = [],
            maxRadius = conf.maxRadius,
            minRadius = conf.minRadius,
            yaxis = Axis().orient(&quot;left&quot;),
            xaxis = Axis().orient(&quot;bottom&quot;),
            backCanvas = this.backCanvas,
            xDimen = this.xDimen,
            yDimen = this.yDimen,
            xMin = conf.dimensionDomain[xDimen][0],
            yMin = conf.dimensionDomain[yDimen][0],
            xMax = conf.dimensionDomain[xDimen][1],
            yMax = conf.dimensionDomain[yDimen][1],
            xBorder = (maxRadius + 30) * (xMax - xMin)/w,
            yBorder = (maxRadius + 30) * (yMax - yMin)/h,
            xDomain = [xMin - xBorder, xMax + xBorder],
            yDomain = [yMin - yBorder, yMax + yBorder],
            axixX = d3.scale.linear().domain(xDomain).range([0, w]),
            axixY = d3.scale.linear().domain(yDomain).range([h, 0]);

        backCanvas.clear();

        xaxis.scale(axixX)
            .tickSubdivide(1)
            .tickSize(6, 3, 0)
            .tickPadding(5)
            .tickAttr({&quot;stroke&quot;: &quot;#929292&quot;})
            .tickTextAttr({&quot;font-size&quot;: &quot;10px&quot;, &quot;fill&quot;: &quot;#929292&quot;})
            .minorTickAttr({&quot;stroke&quot;: &quot;#929292&quot;})
            .domainAttr({&quot;stroke-width&quot;: 1, &quot;stroke&quot;: &quot;#929292&quot;})
            (backCanvas).attr({transform: &quot;t&quot; + m[0] + &quot;,&quot; + (m[1] + h)});

        yaxis.scale(axixY)
            .tickSubdivide(1)
            .tickSize(6, 3, 0)
            .tickPadding(5)
            .tickAttr({&quot;stroke&quot;: &quot;#929292&quot;})
            .tickTextAttr({&quot;font-size&quot;: &quot;10px&quot;, &quot;fill&quot;: &quot;#929292&quot;})
            .minorTickAttr({&quot;stroke&quot;: &quot;#929292&quot;})
            .domainAttr({&quot;stroke-width&quot;: 1, &quot;stroke&quot;: &quot;#929292&quot;})
            (backCanvas).attr({transform: &quot;t&quot; + m[0] + &quot;,&quot; + m[1]});

        var xText = backCanvas.text(m[0] + w/2, m[1] + h + 40, this.xDimen);
        xText.attr({&quot;font-size&quot;: &quot;15px&quot;, &quot;font-family&quot;: &quot;Arial&quot;, &quot;fill&quot;: &quot;#000000&quot;});
        var yText = backCanvas.text(m[0] - 50, m[1] + h/2, this.yDimen);
        yText.attr({&quot;font-size&quot;: &quot;15px&quot;, &quot;font-family&quot;: &quot;Arial&quot;, &quot;fill&quot;: &quot;#000000&quot;}).transform(&quot;r-90&quot;);
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_colorDB">
    colorDB
  </h3>
  

  <p>color database</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Bubble.prototype.colorDB()</td> 
      <td></td>
      <td>colorDB</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Bubble.prototype.colorDB = function (colorJson) {
        var colorMatrix = DataV.getColor();
        var color;
        var colorStyle = colorJson || {};
        var colorMode = colorStyle.mode || 'default';
        var i, l;

        switch (colorMode) {
        case &quot;gradient&quot;:
            var index = colorJson.index || 0;
            index = index &lt; 0 ? 0 : Math.min(index, colorMatrix.length - 1);
            color = d3.interpolateRgb.apply(null, [colorMatrix[index][0], colorMatrix[index][1]]);
            break;
        case &quot;random&quot;:
        case &quot;default&quot;:
            var ratio = colorStyle.ratio || 0;
            if (ratio &lt; 0) { ratio = 0; }
            if (ratio &gt; 1) { ratio = 1; }
            var colorArray = [];
            for (i = 0, l = colorMatrix.length; i &lt; l; i++) {
                var colorFunc = d3.interpolateRgb.apply(null, [colorMatrix[i][0], colorMatrix[i][1]]);
                colorArray.push(colorFunc(ratio));
            }
            color = d3.scale.ordinal().range(colorArray);
            break;
        }
        return color;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_generatePaths">
    generatePaths
  </h3>
  

  <p>main visualization method where bubble is drawed inside<br />a time point is the method's only parameter</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Bubble.prototype.generatePaths()</td> 
      <td></td>
      <td>generatePaths</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Bubble.prototype.generatePaths = function (time) {
        var conf = this.defaults,
            m = conf.borderMargin,
            meshInterval = conf.meshInterval,
            realWidth = conf.width - m[0] - m[2],
            realHeight = conf.height - m[1] - m[3],
            labelSize = 18,
            labelXDistance = realHeight * 0.86,
            foreCanvas = this.foreCanvas,
            x0, y0, r0, c0,
            x, y, r, c, skeletonRadius = 2,
            timeKeys = this.timeKeys,
            keys = this.keys,
            dots = [],
            dotBubbleSet = [];

        // $(&quot;#&quot; + this.node).append(this.floatTag);

        if (time &lt; this.times.length - 1) {
            this.startTime = time;
        } else {
            this.startTime = 0;
        }
        
        foreCanvas.clear();

        // draw mesh
        var meshes = foreCanvas.set(),
            verticleMeshNum = realWidth / meshInterval,
            horizontalMeshNUm = realHeight / meshInterval;
        for (var i = 1;i &lt; verticleMeshNum;i++) {
            meshes.push(foreCanvas.path(&quot;M&quot;+(i * meshInterval)+&quot; &quot;+0+&quot;L&quot;+(i * meshInterval)+
                &quot; &quot;+(realHeight-1)).attr({&quot;stroke&quot;: &quot;#ebebeb&quot;, &quot;stroke-width&quot;: 1}));
        }
        for (var i = 1; i &lt; horizontalMeshNUm; i++) {
            meshes.push(foreCanvas.path(&quot;M&quot;+1+&quot; &quot;+(realHeight - (i * meshInterval))+&quot;L&quot;+realWidth+
                &quot; &quot;+(realHeight - (i * meshInterval))).attr({&quot;stroke&quot;: &quot;#ebebeb&quot;, &quot;stroke-dasharray&quot;: &quot;-&quot;, &quot;stroke-width&quot;: 0.5}));
        }

        // get all data by time and key dimension data
        for (var i = 0, l = keys.length; i &lt; l; i++) {
            x0 = this.interpolateData(time, timeKeys, this.getKeyData(xDimen, keys[i]));
            y0 = this.interpolateData(time, timeKeys, this.getKeyData(yDimen, keys[i]));
            r0 = this.interpolateData(time, timeKeys, this.getKeyData(sizeDimen, keys[i]));
            c0 = this.getColorData(keys[i]);

            var dot = {key: keys[i], x0: x0, y0: y0, r0: r0, c0: c0, year: this.times[time.toFixed(0)]};
            dots.push(dot);
        }

        var floatTag = this.floatTag;
        var tip = '&lt;b&gt;' + that.keyDimen + ':{key}&lt;/b&gt;&lt;br/&gt;&lt;b&gt;' +
            that.xDimen + ':{xDimen}&lt;/b&gt;&lt;br/&gt;&lt;b&gt;' +
            that.yDimen + ':{yDimen}&lt;/b&gt;&lt;br/&gt;&lt;b&gt;' +
            that.sizeDimen + ':{sizeDimen}&lt;/b&gt;&lt;br/&gt;&lt;b&gt;' +
            that.colorDimen + ':{colorDimen}&lt;/b&gt;&lt;br/&gt;&lt;b&gt;' +
            that.timeDimen + ':{timeDimen}&lt;/b&gt;';

        // control the time label
        var label = foreCanvas.text(20, m[1] + h + 15, this.times[time.toFixed(0)]);
        label.attr({&quot;font-size&quot;: labelSize, &quot;fill&quot;: &quot;#606060&quot;, &quot;text-anchor&quot;: &quot;start&quot;});

        dots.sort(function(b,a) { return a.r0 &lt; b.r0 ? -1 : a.r0 &gt; b.r0 ? 1 : 0; });

        // draw the circles
        for (var i = 0, l = dots.length; i &lt; l; i++) {
            var dot = dots[i],
                x = this.x[xDimen](dot.x0) - m[0],
                y = this.y[yDimen](dot.y0),
                r = this.z[sizeDimen](dot.r0),
                c = this.c[colorDimen](dot.c0),
                dotBubble = foreCanvas.circle(x, y, r);
            dotBubble.attr({&quot;stroke-width&quot;:0, &quot;fill&quot;: c, &quot;fill-opacity&quot;: 0.5})
                .data(&quot;key&quot;, dot.key).data(&quot;colorType&quot;, dot.c0);
            dotBubbleSet.push(dotBubble);
        }

        // add hover and click effect for all circles
        dotBubbleSet.forEach(function (d, i) {
            tip = tip.replace('{key}', dots[i].key);
                    tip = tip.replace('{xDimen}', dots[i].x0);
                    tip = tip.replace('{yDimen}', dots[i].y0);
                    tip = tip.replace('{sizeDimen}', dots[i].r0);
                    tip = tip.replace('{colorDimen}', dots[i].c0);
                    tip = tip.replace('{timeDimen}', time);
            d.hover(
                function () {
                    floatTag.html('&lt;div style=&quot;text-align: left;margin:auto;color:#ffffff&quot;&gt;' + tip + '&lt;/div&gt;');
                    floatTag.css({&quot;visibility&quot; : &quot;visible&quot;});
                    if (!that.choose) {
                        d.attr({&quot;stroke-width&quot;: 1, &quot;stroke&quot;: &quot;#f00&quot;, &quot;fill-opacity&quot;: 0.8});
                        meshes.attr({&quot;stroke&quot;: &quot;#d6d6d6&quot;, &quot;stroke-dasharray&quot;: &quot;-&quot;, &quot;stroke-width&quot;: 1});
                        for (var j = 0, l = dotBubbleSet.length; j &lt; l ; j++) {
                            if (j != i) {
                               dotBubbleSet[j].attr({&quot;stroke-width&quot;: 0, &quot;fill-opacity&quot;: 0.2});
                            }
                        }
                    }
                },
                function () {
                    floatTag.css({&quot;visibility&quot; : &quot;hidden&quot;});
                    if (!that.choose) {
                        d.attr({&quot;stroke-width&quot;: 0, &quot;fill-opacity&quot;: 0.5});
                        meshes.attr({&quot;stroke&quot;: &quot;#ebebeb&quot;, &quot;stroke-dasharray&quot;: &quot;-&quot;, &quot;stroke-width&quot;: 1});
                        for (var j = 0, l = dotBubbleSet.length; j &lt; l ; j++) {
                            if (j != i) {
                               dotBubbleSet[j].attr({&quot;stroke-width&quot;: 0, &quot;fill-opacity&quot;: 0.5});
                            }
                        }
                    }
                }
            );

            d.click(
                function() {
                    if (time == Math.ceil(time)) {
                        drawAllTime(this.data(&quot;key&quot;), i);
                    } else {
                        drawAllTime(this.data(&quot;key&quot;), i);
                        this.remove();
                    }
                }
            );
        });

        // colorbar interaction for showing all same color history data
        that = this;
        if (this.interactionType) {
            dotBubbleSet.forEach(function (d) {
                if (d.data(&quot;colorType&quot;) == that.interactionType) {
                    drawAllTime(d.data(&quot;key&quot;));
                }
            });
        }

        // an inside method to visualize a key's all time data
        function drawAllTime (key, num) {
            if (!that.interval) {
                that.choose = true;
                var floatTag = that.floatTag;

                for (var j = 0, l = dotBubbleSet.length; j &lt; l ; j++) {
                    if (j != num) {
                        dotBubbleSet[j].attr({&quot;stroke-width&quot;: 0, &quot;fill-opacity&quot;: 0.2});
                    }
                }

                meshes.attr({&quot;stroke&quot;: &quot;#d6d6d6&quot;, &quot;stroke-dasharray&quot;: &quot;-&quot;});

                var tip = '&lt;b&gt;' + that.keyDimen + ':{key}&lt;/b&gt;&lt;br/&gt;&lt;b&gt;'
                    + that.xDimen + ':{xDimen}&lt;/b&gt;&lt;br/&gt;&lt;b&gt;'
                    + that.yDimen + ':{yDimen}&lt;/b&gt;&lt;br/&gt;&lt;b&gt;'
                    + that.sizeDimen + ':{sizeDimen}&lt;/b&gt;&lt;br/&gt;&lt;b&gt;'
                    + that.colorDimen + ':{colorDimen}&lt;/b&gt;&lt;br/&gt;&lt;b&gt;'
                    + that.timeDimen + ':{timeDimen}&lt;/b&gt;';

                for (var i = 0, l = timeKeys.length; i &lt; l; i++) {
                    var x0 = that.interpolateData(timeKeys[i], timeKeys, that.getKeyData(xDimen, key)),
                        y0 = that.interpolateData(timeKeys[i], timeKeys, that.getKeyData(yDimen, key)),
                        r0 = that.interpolateData(timeKeys[i], timeKeys, that.getKeyData(sizeDimen, key)),
                        c0 = that.getColorData(key),
                        x = that.x[xDimen](x0) - m[0],
                        y = that.y[yDimen](y0),
                        r = that.z[sizeDimen](r0),
                        c = that.c[colorDimen](c0),
                        fOpacity = 0.1 + Math.pow(1.5, i)/Math.pow(1.5, l);
                        historyBubble = foreCanvas.circle(x, y, r);
                        historyBubble.attr({&quot;stroke-width&quot;: 0, &quot;fill&quot;: c, &quot;fill-opacity&quot;: fOpacity});

                    tip = tip.replace('{key}', key);
                    tip = tip.replace('{xDimen}', x0);
                    tip = tip.replace('{yDimen}', y0);
                    tip = tip.replace('{sizeDimen}', r0);
                    tip = tip.replace('{colorDimen}', c0);
                    tip = tip.replace('{timeDimen}', that.times[timeKeys[i]]);

                    if (timeKeys[i] == Math.ceil(time)) {
                        historyBubble.attr({&quot;stroke-width&quot;: 1, &quot;stroke&quot;: &quot;#f00&quot;});
                        historyBubble.hover(
                            function () {
                                floatTag.html('&lt;div style=&quot;text-align: left;margin:auto;color:#ffffff&quot;&gt;' + tip + '&lt;/div&gt;');
                                floatTag.css({&quot;visibility&quot; : &quot;visible&quot;});
                                // meshes.attr({&quot;stroke&quot;: &quot;#d6d6d6&quot;, &quot;stroke-dasharray&quot;: &quot;-&quot;});
                            },
                            function () {
                                floatTag.css({&quot;visibility&quot; : &quot;hidden&quot;});
                                // meshes.attr({&quot;stroke&quot;: &quot;#ebebeb&quot;, &quot;stroke-dasharray&quot;: &quot;-&quot;});
                            }
                        );
                    } else {
                        historyBubble.hover(
                            function () {
                                this.attr({&quot;stroke-width&quot;: 1, &quot;stroke&quot;: &quot;#f00&quot;});
                                floatTag.html('&lt;div style=&quot;text-align: left;margin:auto;color:#ffffff&quot;&gt;' + tip + '&lt;/div&gt;');
                                floatTag.css({&quot;visibility&quot; : &quot;visible&quot;});
                                // meshes.attr({&quot;stroke&quot;: &quot;#d6d6d6&quot;, &quot;stroke-dasharray&quot;: &quot;-&quot;});
                            },
                            function () {
                                this.attr({&quot;stroke-width&quot;: 0});
                                floatTag.css({&quot;visibility&quot; : &quot;hidden&quot;});
                                // meshes.attr({&quot;stroke&quot;: &quot;#ebebeb&quot;, &quot;stroke-dasharray&quot;: &quot;-&quot;});
                            }
                        );
                    }

                    historyBubble.click(function () {
                        that.generatePaths(Math.ceil(time));
                        that.choose = false;
                    });
                }

                var skeletonLineSet = foreCanvas.set();
                for (var i = 1, l = timeKeys.length; i &lt; l; i++) {
                    var x0 = that.interpolateData(timeKeys[i], timeKeys, that.getKeyData(xDimen, key)),
                        y0 = that.interpolateData(timeKeys[i], timeKeys, that.getKeyData(yDimen, key)),
                        x = that.x[xDimen](x0) - m[0],
                        y = that.y[yDimen](y0),
                        x1 = that.interpolateData(timeKeys[i-1], timeKeys, that.getKeyData(xDimen, key)),
                        y1 = that.interpolateData(timeKeys[i-1], timeKeys, that.getKeyData(yDimen, key)),
                        x2 = that.x[xDimen](x1) - m[0],
                        y2 = that.y[yDimen](y1);
                        skeletonLine = foreCanvas.path(&quot;M&quot;+x2+&quot; &quot;+y2+&quot;L&quot;+x+&quot; &quot;+y);
                        skeletonLine.attr(conf.skeletonLineAttr);
                        skeletonLineSet.push(skeletonLine);
                    }

                var skeletonCircleSet = foreCanvas.set();
                for (var i = 0, l = timeKeys.length; i &lt; l; i++) {
                    var x0 = that.interpolateData(timeKeys[i], timeKeys, that.getKeyData(xDimen, key)),
                        y0 = that.interpolateData(timeKeys[i], timeKeys, that.getKeyData(yDimen, key)),
                        r0 = that.interpolateData(timeKeys[i], timeKeys, that.getKeyData(sizeDimen, key)),
                        c0 = that.getColorData(key),
                        x = that.x[xDimen](x0) - m[0],
                        y = that.y[yDimen](y0),
                        r = that.z[sizeDimen](r0),
                        c = that.c[colorDimen](c0),
                        fOpacity = 0.1 + i * 0.9 / timeKeys.length;
                    skeletonCircle = foreCanvas.circle(x,y,skeletonRadius);
                    skeletonCircle.attr(conf.skeletonCircleAttr).attr({&quot;stroke&quot;: c});
                    skeletonCircleSet.push(skeletonCircle);

                    if (timeKeys[i] == Math.ceil(time)) {
                        skeletonCircle.attr({&quot;fill&quot;: &quot;#f00&quot;});
                        skeletonCircle.click(
                            function () {
                                that.generatePaths(Math.ceil(time));
                            }
                        );
                        skeletonCircle.hover(
                            function () {
                                floatTag.html('&lt;div style=&quot;text-align: left;margin:auto;color:#ffffff&quot;&gt;' + tip + '&lt;/div&gt;');
                                floatTag.css({&quot;visibility&quot; : &quot;visible&quot;});
                                skeletonCircleSet.attr({&quot;fill-opacity&quot;: 0.35});
                                this.attr({&quot;fill-opacity&quot;: 1, &quot;r&quot;: 5});
                                // meshes.attr({&quot;stroke&quot;: &quot;#d6d6d6&quot;, &quot;stroke-dasharray&quot;: &quot;-&quot;});
                                skeletonLineSet.attr({&quot;opacity&quot;: 0.35});
                            },
                            function () {
                                floatTag.css({&quot;visibility&quot; : &quot;hidden&quot;});
                                this.attr(conf.dotStrokeColor);
                                skeletonCircleSet.attr({&quot;fill-opacity&quot;: 0.7});
                                this.attr({&quot;r&quot;: skeletonRadius});
                                // meshes.attr({&quot;stroke&quot;: &quot;#ebebeb&quot;, &quot;stroke-dasharray&quot;: &quot;-&quot;});
                                skeletonLineSet.attr({&quot;opacity&quot;: 0.7});
                            }
                        );
                    } else {
                        skeletonCircle.hover(
                            function () {
                                floatTag.html('&lt;div style=&quot;text-align: left;margin:auto;color:#ffffff&quot;&gt;' + tip + '&lt;/div&gt;');
                                floatTag.css({&quot;visibility&quot; : &quot;visible&quot;});
                                skeletonCircleSet.attr({&quot;fill-opacity&quot;: 0.35});
                                this.attr({&quot;fill-opacity&quot;: 1, &quot;r&quot;: 5});
                                // meshes.attr({&quot;stroke&quot;: &quot;#d6d6d6&quot;, &quot;stroke-dasharray&quot;: &quot;-&quot;});
                                skeletonLineSet.attr({&quot;opacity&quot;: 0.35});
                            },
                            function () {
                                floatTag.css({&quot;visibility&quot; : &quot;hidden&quot;});
                                this.attr(conf.dotStrokeColor);
                                skeletonCircleSet.attr({&quot;fill-opacity&quot;: 0.7});
                                this.attr({&quot;r&quot;: skeletonRadius});
                                // meshes.attr({&quot;stroke&quot;: &quot;#ebebeb&quot;, &quot;stroke-dasharray&quot;: &quot;-&quot;});
                                skeletonLineSet.attr({&quot;opacity&quot;: 0.7});
                            }
                        );
                    }
                }

            }
        }     
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_getKeyData">
    getKeyData
  </h3>
  

  <p>get key's specific dimension data which include all time points</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Bubble.prototype.getKeyData()</td> 
      <td></td>
      <td>getKeyData</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Bubble.prototype.getKeyData = function(dimen,key) {
        var data = [];
        for (var i = 0; i &lt; this.source.length; i++) {
            if (this.source[i][this.keyDimen] === key) {
                data.push(this.source[i][dimen]);
            }
        }
        return data;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_getColorData">
    getColorData
  </h3>
  

  <p>get a unique color specified by key</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Bubble.prototype.getColorData()</td> 
      <td></td>
      <td>getColorData</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Bubble.prototype.getColorData = function(key) {
        for (var i = 0; i &lt; this.source.length; i++) {
            if (this.source[i][this.keyDimen] === key) {
                return this.source[i][this.colorDimen];
            }
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_initControls">
    initControls
  </h3>
  

  <p>set up an animation</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Bubble.prototype.initControls()</td> 
      <td></td>
      <td>initControls</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Bubble.prototype.initControls = function() {  
        var that = this,
            len = this.times.length -1;
            value = this.startTime;

        this.interval = setInterval(function() {
            if (value &lt;= len) {
                that.generatePaths(value);
                value += 0.25;
            } else {
                clearInterval(that.interval);
                that.interval = 0;
            }
        }, 250);
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_interpolateData">
    interpolateData
  </h3>
  

  <p>interpolated some data between neibourh data point for the animation</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Bubble.prototype.interpolateData()</td> 
      <td></td>
      <td>interpolateData</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Bubble.prototype.interpolateData = function(year, years, values) {
        var index = Math.ceil(year);
        if (year == years[index]) {
            return values[index];
        }
        var lowerIndex = Math.max(0,index-1);
        var lower = values[lowerIndex];
        var higherIndex = index;
        var higher = values[higherIndex];
        var lowYear = years[lowerIndex];
        var highYear = years[higherIndex];
        var p = (year-lowYear) / (highYear-lowYear);
        var value = +lower + +((higher-lower)*p) ;
        return value;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_uniq">
    uniq
  </h3>
  

  <p>make an array's every element unique by delete other same element<br />TODO: 用underscore的uniq替换该方法</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Array.prototype.uniq()</td> 
      <td></td>
      <td>uniq</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Array.prototype.uniq = function () {
        var temp = {},
            len = this.length;

        for (var i = 0; i &lt; len; i++) {
            if (typeof temp[this[i]] == &quot;undefined&quot;) {
                temp[this[i]] = 1;
            }
        }
        this.length = 0;
        len = 0;
        for (var i in temp) {
            this[len++] = i;
        }
        return this;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_clearAnimation">
    clearAnimation
  </h3>
  

  <p>clear animation and related artifacts</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Bubble.prototype.clearAnimation()</td> 
      <td></td>
      <td>clearAnimation</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Bubble.prototype.clearAnimation = function () {
        clearInterval(this.interval);
        this.interval = 0;
        this.backCanvas.clear();
        this.foreCanvas.clear();
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_pause">
    pause
  </h3>
  

  <p>pause the interval</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Bubble.prototype.pause()</td> 
      <td></td>
      <td>pause</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Bubble.prototype.pause = function () {
        clearInterval(this.interval);
        this.interval = 0;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_render">
    render
  </h3>
  

  <p>set the rendering process</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Bubble.prototype.render()</td> 
      <td></td>
      <td>render</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Bubble.prototype.render = function (options) {
        clearInterval(this.interval);
        this.setOptions(options);
        if (!this.interval) {
            this.renderAxis();
        }
        this.foreCanvas.clear();
 	    this.getScale();
        this.initControls();
    };

    return Bubble;
});</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/bullet" class="api">
  <h2>charts/bullet: API索引</h2>
  <ul class="indexs">
  
    <li>
      <a href="#_Bullet">Bullet</a>
    </li>

    <li>
      <a href="#_setSource">setSource</a>
    </li>

    <li>
      <a href="#_render">render</a>
    </li>

  </ul>
  <hr />

  

  <table class="table">
  

  
  </table>
  
  
  <h3 id="_Bullet">
    Bullet
  </h3>
  

  <p>Bullet构造函数</p>

<h2>Options</h2>

<ul>
<li><code>width</code> 数字，图片宽度，默认为200，表示图片高200px</li>
<li><code>height</code> 数字，图片高度，默认为80</li>
<li><code>orient</code> string，图片方向，默认为"horizonal"，表示水平方向。若为"vertical"，则表示垂直方向</li>
<li><code>axisStyle</code> string, 坐标系类型，默认为"linear"，表示坐标系为线性坐标系。若为"log"，则表示对数坐标系</li>
<li><code>logBase</code> 数字, 采用对数坐标系时的对数基，默认为Math.E</li>
<li><code>tickDivide</code> 数字，表示坐标的标尺的分段数，默认为5</li>
<li><code>margin</code> 数字数组，表示图片上、右、下、左的边距，默认为 [20, 20, 20, 20]</li>
<li><code>centerBarRatio</code> 数字，表示中间的测度条的高度与背景条高度的比值， 默认为0.3</li>
<li><code>markerWidth</code> 数字，表示标记条的宽度， 默认为4，单位为像素</li>
<li><code>markerRatio</code> 数字，表示标记条的高度与背景条高度的比值，默认为0.7</li>
<li><code>titleRatio</code> 数字，表示子弹图title的高度与背景条高度的比值，默认为0.6，此时title与subtitle的比值</li>
<li><code>backgroundColor</code> string数组，表示背景条颜色的渐变数组，默认为["#666", "#ddd"],背景条颜色就是这两种颜色的渐变</li>
<li><code>measureColor</code> string数组，表示测度条颜色的渐变数组，默认为["steelblue", "#B0C4DE"],测度条颜色就是这两种颜色的渐变</li>
<li><code>markerColor</code> string，表示标记条的颜色，默认为"#000"</li>
</ul>

<h2>Examples</h2>

<div class="highlight"><pre lang="">//Create bullet in a dom node with id "chart", width is 500; height is 600px;
var bullet = new Bullet("chart", {
    "width": 500,
    "height": 600,
    "margin": [10, 10, 20, 70]
});
//Create bullet with log base;
var log = new Bullet("chart2", {
    width: 300,
    height: 60,
    margin: [10, 10, 20, 70],
    backgroundColor: ["#66f", "#ddf"],
    measureColor: ["#000", "#000"],
    markerColor: "#44f",
    axisStyle: "log",
    logBase: 10
});
</pre></div>

  <table class="table">
  
    <tr>
      <td>声明</td>
      <td>Bullet</td> 
      <td></td>
      <td>Bullet</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>node(Mix)</td>
      <td colspan="2">The dom node or dom node Id</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>options(Object)</td>
      <td colspan="2">options json object for determin stream style.</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>var Bullet = DataV.extend(DataV.Chart, {
        initialize: function (node, options) {
            this.type = &quot;Bullet&quot;;
            this.node = this.checkContainer(node);
            // Properties
            this.defaults.orient = &quot;horizonal&quot;; // &quot;horizonal&quot;, &quot;vertical&quot;
            this.defaults.axisStyle = &quot;linear&quot;; // &quot;linear&quot;, &quot;log&quot;
            this.defaults.logBase = Math.E;
            this.defaults.tickDivide = 5;
            this.defaults.margin = [10, 10, 20, 80];//top, right, bottom, left
            this.defaults.centerBarRatio = 0.3;
            this.defaults.markerWidth = 4;
            this.defaults.markerRatio = 0.7;
            this.defaults.titleRatio = 0.6; //title's text height : subtitle's text height = 6:4
            this.defaults.backgroundColor = [&quot;#666&quot;, &quot;#ddd&quot;]; //dark, light
            this.defaults.measureColor = [&quot;steelblue&quot;, &quot;#B0C4DE&quot;]; //dark, light
            this.defaults.markerColor = &quot;#000&quot;;

            // canvas
            this.defaults.width = 200;
            this.defaults.height = 80;

            this.setOptions(options);
            this.createCanvas();
        }
    });</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setSource">
    setSource
  </h3>
  

  <p>设置数据源</p>

<h2>Examples</h2>

<div class="highlight"><pre lang="">bullet.setSource({
   title: "Sample",
   subtitle: "ratio",
   ranges: [0, 0.5, 0.8, 1],
   measures: [0.7, 0.9],
   markers: [0.6],
   rangeTitles: ["below 50%", "top 20% - 50%", "top 20%"],
   measureTitles: ["value is 0.7", "value is 0.9"],
   markerTitles: ["mean is 0.6"]
})
</pre></div>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Bullet.prototype.setSource()</td> 
      <td></td>
      <td>setSource</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>source(Object)</td>
      <td colspan="2">数据源</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Bullet.prototype.setSource = function (source) {
        var conf = this.defaults,
            range,
            axisOrient;
        this.data = source;
        if (conf.orient === &quot;horizonal&quot;) {
            axisOrient = &quot;bottom&quot;;
            range = [conf.margin[3], conf.width - conf.margin[1]];
        } else if (conf.orient === &quot;vertical&quot;) {
            axisOrient = &quot;left&quot;;
            range = [conf.height - conf.margin[2], conf.margin[0]];
        }

        if (conf.axisStyle === &quot;linear&quot;) {
            this.scale = d3.scale.linear();
        } else if (conf.axisStyle === &quot;log&quot;) {
            this.scale = d3.scale.log();
        }

        this.data.min = this.data.ranges[0];
        this.data.max = this.data.ranges[this.data.ranges.length - 1];
        this.scale.domain([this.data.min, this.data.max])
            .range(range);

        if (conf.axisStyle === &quot;linear&quot;) {
            this.axis = Axis().scale(this.scale).orient(axisOrient).ticks(conf.tickDivide).domainAttr({&quot;stroke&quot;: &quot;none&quot;});
        } else if (conf.axisStyle === &quot;log&quot;) {
            this.logScale = d3.scale.linear()
                .domain([Math.log(this.data.min)/Math.log(conf.logBase), Math.log(this.data.max)/Math.log(conf.logBase)])
                .range(range);
            this.axis = Axis()
                .orient(axisOrient)
                .scale(this.logScale)
                .ticks(conf.tickDivide)
                .tickFormat(function (d) {return Math.round(Math.pow(conf.logBase, d));})
                .domainAttr({&quot;stroke&quot;: &quot;none&quot;});
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_render">
    render
  </h3>
  

  <p>render bullet</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Bullet.prototype.render()</td> 
      <td></td>
      <td>render</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Bullet.prototype.render = function (options) {
        this.setOptions(options);
        this.generatePaths();
    };

    return Bullet;
});</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/bundle" class="api">
  <h2>charts/bundle: API索引</h2>
  <ul class="indexs">
  
    <li>
      <a href="#_Bundle">Bundle</a>
    </li>

    <li>
      <a href="#_setOptions">setOptions</a>
    </li>

    <li>
      <a href="#_setSource">setSource</a>
    </li>

    <li>
      <a href="#_createCanvas">createCanvas</a>
    </li>

    <li>
      <a href="#_layout">layout</a>
    </li>

    <li>
      <a href="#_render">render</a>
    </li>

    <li>
      <a href="#_generatePaths">generatePaths</a>
    </li>

  </ul>
  <hr />

  

  <table class="table">
  

  
  </table>
  
  
  <h3 id="_Bundle">
    Bundle
  </h3>
  

  <p>构造函数，node参数表示在html的哪个容器中绘制该组件<br />options对象为用户自定义的组件的属性，比如画布大小</p>

  <table class="table">
  
    <tr>
      <td>声明</td>
      <td>Bundle</td> 
      <td></td>
      <td>Bundle</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>var Bundle = DataV.extend(DataV.Chart, {
        initialize: function (node, options) {
            this.type = &quot;Bundle&quot;;
            this.node = this.checkContainer(node);
            this.json = {};
    
            // 图的半径
            this.defaults.diameter = 960;
            this.defaults.radius = this.defaults.diameter / 2;
            this.defaults.innerRadius = this.defaults.radius - 120;
            this.defaults.tension = 0.85;
    
            this.defaults.color = {
                defaultLineColor: &quot;#4065AF&quot;,
                defaultWordColor: &quot;#000000&quot;,
                lineHoverColor: &quot;#02B0ED&quot;,
                nodeHoverColor: &quot;#02B0ED&quot;,
                importNodesColor: &quot;#5DA714&quot;, //被引用的节点
                exportNodesColor: &quot;#FE3919&quot; //引用当前节点的节点
            };
    
            this.setOptions(options);
            this.createCanvas();
        }
    });</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setOptions">
    setOptions
  </h3>
  

  <p>设置用户自定义属性</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Bundle.prototype.setOptions()</td> 
      <td></td>
      <td>setOptions</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Bundle.prototype.setOptions = function (options) {
        if (options) {
            var prop;
            for (prop in options) {
                if (options.hasOwnProperty(prop)) {
                    this.defaults[prop] = options[prop];
                    if (prop === &quot;diameter&quot;) {
                        this.defaults.radius = this.defaults.diameter / 2;
                        this.defaults.innerRadius = this.defaults.radius - 120;
                    } else if (prop === &quot;radius&quot;) {
                        this.defaults.diameter = this.defaults.radius * 2;
                        this.defaults.innerRadius = this.defaults.radius - 120;
                    } else if (prop === &quot;innerRadius&quot;) {
                        this.defaults.radius = this.defaults.innerRadius + 120;
                        this.defaults.diameter = this.defaults.radius * 2;
                    } else if (prop === &quot;width&quot;) {
                        this.defaults.diameter = this.defaults.width;
                        this.defaults.radius = this.defaults.diameter / 2;
                        this.defaults.innerRadius = this.defaults.radius - 120;
                    }
                }
            }
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setSource">
    setSource
  </h3>
  

  <p>对原始数据进行处理<br />TODO: 改进为获取值时运算</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Bundle.prototype.setSource()</td> 
      <td></td>
      <td>setSource</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Bundle.prototype.setSource = function (source) {
        if (source[0] &amp;&amp; source[0] instanceof Array) {
            // csv or 2d array source
            if (source[0][0] === &quot;name&quot;) {
                source = source.slice(1); // 从第一行开始，第0行舍去
            }
            var nData = [];
            var imports = [];
            //var isNode = true;
            var nodeNum;
            var that = this;
            source.forEach(function (d, i) {
                if (d[0] === &quot;&quot;) {
                    throw new Error(&quot;name can not be empty(line:&quot; + (i + 1) + &quot;).&quot;);
                }
                if (d[1] !== &quot;&quot;) {
                    imports = d[1].split(&quot; &quot;);
                }
                nData[i] = {
                    name: d[0],
                    imports: imports
                };
            });
            this.json = nData;
        } else {
            // json source
            this.json = source;
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_createCanvas">
    createCanvas
  </h3>
  

  <p>创建画布</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Bundle.prototype.createCanvas()</td> 
      <td></td>
      <td>createCanvas</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Bundle.prototype.createCanvas = function () {
        var conf = this.defaults;
        this.canvas = new Raphael(this.node, conf.diameter, conf.diameter);

        //var c = this.canvas.circle(50, 50, 40);
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_layout">
    layout
  </h3>
  

  <p>布局</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Bundle.prototype.layout()</td> 
      <td></td>
      <td>layout</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Bundle.prototype.layout = function () {
        var packages = {
            // Lazily construct the package hierarchy from class names.
            root: function (classes) {
                var map = {};
                function construct(name, data) {
                    var node = map[name], i;
                    if (!node) {
                        node = map[name] = data || {name: name, children: []};
                        if (name.length) {
                            node.parent = construct(name.substring(0, i = name.lastIndexOf(&quot;.&quot;)));
                            node.parent.children.push(node);
                            node.key = name.substring(i + 1);
                        }
                    }
                    return node;
                }
          
                classes.forEach(function (d) {
                    construct(d.name, d);
                });
          
                return map[&quot;&quot;];
            },
        
            // Return a list of imports for the given array of nodes.
            imports: function (nodes) {
                var map = {},
                    imports = [];
          
                // Compute a map from name to node.
                nodes.forEach(function (d) {
                    map[d.name] = d;
                });
          
                // For each import, construct a link from the source to target node.
                nodes.forEach(function (d) {
                    if (d.imports) {
                        d.imports.forEach(function (i) {imports.push({source: map[d.name], target: map[i]});
                            });
                    }
                });
          
                return imports;
            }
        };
        
        var cluster = d3.layout.cluster()
            .size([360, this.defaults.innerRadius]) //.size(角度，半径)
            .sort(null)
            .value(function (d) {
                return d.size;
            });
        this.nodes = cluster.nodes(packages.root(this.json));
        this.links = packages.imports(this.nodes);
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_render">
    render
  </h3>
  

  <p>渲染弦图</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Bundle.prototype.render()</td> 
      <td></td>
      <td>render</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Bundle.prototype.render = function () {
        this.layout();
        this.generatePaths();
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_generatePaths">
    generatePaths
  </h3>
  

  <p>生成路径</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Bundle.prototype.generatePaths()</td> 
      <td></td>
      <td>generatePaths</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Bundle.prototype.generatePaths = function (options) {
        var that = this;

        var canvas = this.canvas;
        var rNodes = canvas.set();
        var rLinks = canvas.set();

        var bundle = d3.layout.bundle();

        var line = d3.svg.line.radial()
            .interpolate(&quot;bundle&quot;)
            .tension(this.defaults.tension)
            .radius(function (d) {
                return d.y;
            })
            .angle(function (d) {
                return d.x / 180 * Math.PI;
            });

        //定义图中的弦和节点
        var nodes = this.nodes;
        var links = this.links;
        var linksCount = links.length;
        var paths = bundle(links);

        var locateStr = &quot;&quot;; //对文字进行平移和旋转
        var locateBBox = &quot;&quot;; //对文字的bounding box进行平移和旋转
        var r = 0;
        var angle = 0;
        var xTrans = 0;
        var yTrans = 0;
        var anchor; //text-anchor: start or end
        var rotateStr = &quot;&quot;;

        //element data cache
        var nodeRelatedElements = {};// {key: {targetLink: [], sourceLink: [], targetNode: [], sourceNode: []}}
        var nodeElements = {}; //{key: Els}
        var bBoxElements = {}; //{key: Els}

        var i,
            j,
            key,
            textEl,
            bBox,
            bBoxNew,
            tCenterX,
            tCenterY,
            bBoxEl,
            linkEl;

        var mouseoverLink = function () {
            var current = this;
            //var color = that.data(&quot;color&quot;);
            if (rLinks.preLink) {
                rLinks.preLink.attr(&quot;stroke&quot;, that.defaults.color.defaultLineColor)
                    .attr(&quot;stroke-width&quot;, 1)
                    .attr(&quot;stroke-opacity&quot;, 0.6);

            }
            rLinks.preLink = this;

            current.attr(&quot;stroke&quot;, that.defaults.color.lineHoverColor)
                .attr(&quot;stroke-width&quot;, 2)
                .attr(&quot;stroke-opacity&quot;, 1.0)
                .toFront(); //把当前弦移到画布最上层
        };

        var mouseoverNode = function () {
            var relatedEl = this.data(&quot;relatedElements&quot;);
            //高亮所选节点的文字颜色
            this.data(&quot;relatedNode&quot;).attr({&quot;fill&quot;: that.defaults.color.nodeHoverColor,
                &quot;fill-opacity&quot;: 1.0, &quot;font-weight&quot;: &quot;600&quot;});
            //将包围盒颜色设为透明
            this.attr({&quot;fill&quot;: that.defaults.color.nodeHoverColor, &quot;fill-opacity&quot;: 0.0</code></pre></td>
    </tr>
  
  </table>
  
  

  <p>"font-weight": "600"</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>);
            
            relatedEl.sourceLink.forEach(function (d) { //set green
                d.attr({&quot;stroke&quot;: that.defaults.color.importNodesColor, &quot;stroke-width&quot;: 1, &quot;stroke-opacity&quot;: 0.9})
                    .toFront();
            });
            relatedEl.sourceNode.forEach(function (d) {
                d.attr({&quot;fill&quot;: that.defaults.color.importNodesColor, &quot;font-weight&quot;: &quot;600&quot;});
            });
            relatedEl.targetLink.forEach(function (d) { //set red
                d.attr({&quot;stroke&quot;: that.defaults.color.exportNodesColor, &quot;stroke-width&quot;: 1, &quot;stroke-opacity&quot;: 0.9})
                    .toFront();
            });
            relatedEl.targetNode.forEach(function (d) {
                d.attr({&quot;fill&quot;: that.defaults.color.exportNodesColor, &quot;font-weight&quot;: &quot;600&quot;});
            });
        };

        var mouseoutNode = function () {
            var relatedEl = this.data(&quot;relatedElements&quot;);
            this.data(&quot;relatedNode&quot;).attr({&quot;fill&quot;: that.defaults.color.defaultWordColor,
                &quot;font-weight&quot;: &quot;400&quot;, &quot;fill-opacity&quot;: 1.0});
            relatedEl.targetLink.forEach(function (d) {
                d.attr({&quot;stroke&quot;: that.defaults.color.defaultLineColor, &quot;stroke-width&quot;: 1, &quot;stroke-opacity&quot;: 0.6});
            });
            relatedEl.targetNode.forEach(function (d) {
                d.attr({&quot;fill&quot;: that.defaults.color.defaultWordColor, &quot;font-weight&quot;: &quot;400&quot;});
            });
            relatedEl.sourceLink.forEach(function (d) {
                d.attr({&quot;stroke&quot;: that.defaults.color.defaultLineColor, &quot;stroke-width&quot;: 1, &quot;stroke-opacity&quot;: 0.6});
            });
            relatedEl.sourceNode.forEach(function (d) {
                d.attr({&quot;fill&quot;: that.defaults.color.defaultWordColor, &quot;font-weight&quot;: &quot;400&quot;});
            });
        };

        for (j = 0; j &lt; nodes.length; j++) {
            //若为叶子节点
            if (!nodes[j].children) {
                locateStr = &quot;T&quot; + that.defaults.radius + &quot;,&quot; + that.defaults.radius + &quot;R&quot;; //使用大写T、R、S--绝对，not相对

                //半径: add a padding between lines and words
                r = nodes[j].y + 20;

                //计算旋转角度和水平、竖直方向所需平移的距离
                angle = (nodes[j].x - 90) * Math.PI / 180;
                xTrans = r * Math.cos(angle);
                yTrans = r * Math.sin(angle);

                //计算text-anchor
                if (nodes[j].x &lt; 180) {
                    anchor = &quot;start&quot;;
                } else {
                    anchor = &quot;end&quot;;
                }

                //计算文字方向是否需要旋转180度
                if (nodes[j].x &lt; 180) {
                    rotateStr = &quot;&quot;;
                } else {
                    rotateStr = &quot;R180&quot;;
                }

                //计算文字需要如何经过平移和旋转被排列在圆周上
                locateStr += (nodes[j].x - 90) + rotateStr + &quot;T&quot; + xTrans + &quot;,&quot; + yTrans;

                //绘制文字
                textEl = canvas.text()
                    .attr(&quot;font&quot;, &quot;11px arial&quot;)
                    .data(&quot;color&quot;, that.defaults.color)
                    .attr(&quot;text&quot;, nodes[j].key)
                    //.attr(&quot;title&quot;, nodes[j].size)
                    .transform(locateStr)
                    .attr(&quot;text-anchor&quot;, anchor)
                    .attr(&quot;fill&quot;, that.defaults.color.defaultWordColor);

                //获取旋转平移之前文字的bounding box
                bBox = textEl.getBBox(true);

                //canvas.rect(bBox.x, bBox.y, bBox.width, bBox.height);
                //获取旋转平移之后文字的bounding box
                bBoxNew = textEl.getBBox();
                //adjust vml box center
                if (Raphael.vml) {
                    //vml's word bbox is not related to text-anchor, always middle;
                    //svg's word bbox is related to text-anchor;
                    bBoxNew.x = bBoxNew.x + bBox.width / 2 * Math.cos(angle);
                    bBoxNew.y = bBoxNew.y + bBox.width / 2 * Math.sin(angle);
                }
                //canvas.rect(bBoxNew.x, bBoxNew.y, bBoxNew.width, bBoxNew.height);

                //新旧bounding box的中心坐标变化
                tCenterX = bBoxNew.x + bBoxNew.width / 2 - bBox.x - bBox.width / 2;
                tCenterY = bBoxNew.y + bBoxNew.height / 2 - bBox.y - bBox.height / 2;
                //对bounding box进行平移和旋转
                locateBBox = &quot;T&quot; + tCenterX + &quot;,&quot; + tCenterY + &quot;R&quot; + (nodes[j].x - 90) + rotateStr;

                // 包围盒
                bBoxEl = canvas.rect(bBox.x, bBox.y, bBox.width, bBox.height)
                    .transform(locateBBox)
                    .data(&quot;relatedNode&quot;, textEl)
                    .attr({&quot;fill&quot;: &quot;#fff&quot;, &quot;opacity&quot;: 0.01});
                
                key = nodes[j].key;
                nodeElements[key] = textEl;
                bBoxElements[key] = bBoxEl;
                nodeRelatedElements[key] = {targetLink: [], sourceLink: [], targetNode: [], sourceNode: []};

                rNodes.push(textEl);
            }
        }

        //绘制曲线
        for (i = 0; i &lt; linksCount; i++) {
            var l = paths[i];

            //对paths数组中的每一项进行计算，由路径节点信息得到坐标值
            var spline = line(l);
            var sourceKey = links[i].source.key;
            var targetKey = links[i].target.key;
            var tips = &quot;link source: &quot; + sourceKey  + &quot;\n&quot;
                        + &quot;link target: &quot; + targetKey;

            linkEl = canvas.path(spline)
                //.attr(&quot;stroke&quot;, that.defaults.defaultLineColor)
                .attr(&quot;stroke-opacity&quot;, 0.6)
                .attr(&quot;title&quot;, tips)
                .attr(&quot;d&quot;, spline)
                .attr(&quot;stroke&quot;, that.defaults.color.defaultLineColor)
                .translate(that.defaults.radius, that.defaults.radius)
                .mouseover(mouseoverLink);
                //.mouseout(mouseoutLink);
            linkEl[0].el = linkEl;

            nodeRelatedElements[sourceKey].targetLink.push(linkEl);
            nodeRelatedElements[sourceKey].targetNode.push(nodeElements[targetKey]);
            nodeRelatedElements[targetKey].sourceLink.push(linkEl);
            nodeRelatedElements[targetKey].sourceNode.push(nodeElements[sourceKey]);
            rLinks.push(linkEl);
        }

        $(this.canvas.canvas).mousemove(function (e) {
                    if(!e.target.el &amp;&amp; rLinks.preLink){
                        rLinks.preLink.attr(&quot;stroke&quot;, that.defaults.color.defaultLineColor)
                            .attr(&quot;stroke-width&quot;, 1)
                            .attr(&quot;stroke-opacity&quot;, 0.6);
                        rLinks.preLink = undefined;
                        //console.log(&quot;a&quot;);
                    }
                });

        //bind text words hover event
        for (key in bBoxElements) {
            if (bBoxElements.hasOwnProperty(key)) {
                bBoxElements[key].data(&quot;relatedElements&quot;, nodeRelatedElements[key])
                    .mouseover(mouseoverNode)
                    .mouseout(mouseoutNode);
            }
        }

    };

    return Bundle;
});</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/chord" class="api">
  <h2>charts/chord: API索引</h2>
  <ul class="indexs">
  
    <li>
      <a href="#_Chord">Chord</a>
    </li>

    <li>
      <a href="#_createCanvas">createCanvas</a>
    </li>

    <li>
      <a href="#_getColor">getColor</a>
    </li>

    <li>
      <a href="#_render">render</a>
    </li>

    <li>
      <a href="#_legend">legend</a>
    </li>

    <li>
      <a href="#_setSource">setSource</a>
    </li>

    <li>
      <a href="#_layout">layout</a>
    </li>

    <li>
      <a href="#_chordLayout">chordLayout</a>
    </li>

  </ul>
  <hr />

  

  <table class="table">
  

  
  </table>
  
  
  <h3 id="_Chord">
    Chord
  </h3>
  

  <p>构造函数</p>

  <table class="table">
  
    <tr>
      <td>声明</td>
      <td>Chord</td> 
      <td></td>
      <td>Chord</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>node(Object)</td>
      <td colspan="2">表示在html的哪个容器中绘制该组件</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>options(Object)</td>
      <td colspan="2">为用户自定义的组件的属性，比如画布大小</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>var Chord = DataV.extend(DataV.Chart, {
        initialize: function (node, options) {
            this.type = &quot;Chord&quot;;
            this.node = this.checkContainer(node);
            this.matrix = [];
            this.groupNames = []; //数组：记录每个group的名字

            //图的大小设置
            this.defaults.legend = true;
            this.defaults.width = 800;
            this.defaults.height = 800;

            //设置用户指定的属性
            this.setOptions(options);

            this.legendArea = [20, (this.defaults.height - 20 - 220), 200, 220];
            if (this.defaults.legend) {
                this.xOffset = this.legendArea[2];
            } else {
                this.xOffset = 0;
            }

            this.defaults.innerRadius = Math.min((this.defaults.width - this.xOffset), this.defaults.height) * 0.38;
            this.defaults.outerRadius = this.defaults.innerRadius * 1.10;
            //创建画布
            this.createCanvas();
        }
    });</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_createCanvas">
    createCanvas
  </h3>
  

  <p>创建画布</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Chord.prototype.createCanvas()</td> 
      <td></td>
      <td>createCanvas</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Chord.prototype.createCanvas = function () {
        this.canvas = new Raphael(this.node, this.defaults.width, this.defaults.height);
        canvasStyle = this.node.style;
        canvasStyle.position = &quot;relative&quot;;
        this.floatTag = DataV.FloatTag()(this.node);
        this.floatTag.css({
            &quot;visibility&quot;: &quot;hidden&quot;
        });
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_getColor">
    getColor
  </h3>
  

  <p>获取颜色</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Chord.prototype.getColor()</td> 
      <td></td>
      <td>getColor</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>i(Number)</td>
      <td colspan="2">元素类别编号</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>String</td>
      <td colspan="2">返回颜色值</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Chord.prototype.getColor = function (i) {
        var color = DataV.getColor();
        return color[i % color.length][0];
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_render">
    render
  </h3>
  

  <p>绘制弦图</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Chord.prototype.render()</td> 
      <td></td>
      <td>render</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Chord.prototype.render = function () {
        this.layout();
        if (this.defaults.legend) {
            this.legend();
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_legend">
    legend
  </h3>
  

  <p>绘制图例</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Chord.prototype.legend()</td> 
      <td></td>
      <td>legend</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Chord.prototype.legend = function () {
        var that = this;
        var paper = this.canvas;
        var legendArea = this.legendArea;
        var rectBn = paper.set();
        this.underBn = [];
        var underBn = this.underBn;
        for (i = 0; i &lt;= this.groupNum; i++) {
            //底框
            underBn.push(paper.rect(legendArea[0] + 10, legendArea[1] + 10 + (20 + 3) * i, 180, 20).attr({
                &quot;fill&quot;: &quot;#ebebeb&quot;,
                &quot;stroke&quot;: &quot;none&quot;
                //&quot;r&quot;: 3
            }).hide());
            //色框
            paper.rect(legendArea[0] + 10 + 3, legendArea[1] + 10 + (20 + 3) * i + 6, 16, 8).attr({
                &quot;fill&quot;: this.getColor(i),
                &quot;stroke&quot;: &quot;none&quot;
            });
            //文字
            paper.text(legendArea[0] + 10 + 3 + 16 + 8, legendArea[1] + 10 + (20 + 3) * i + 10, this.groupNames[i]).attr({
                &quot;fill&quot;: &quot;black&quot;,
                &quot;fill-opacity&quot;: 1,
                &quot;font-family&quot;: &quot;Verdana&quot;,
                &quot;font-size&quot;: 12
            }).attr({
                &quot;text-anchor&quot;: &quot;start&quot;
            });
            //选框
            rectBn.push(paper.rect(legendArea[0] + 10, legendArea[1] + 10 + (20 + 3) * i, 180, 20).attr({
                &quot;fill&quot;: &quot;white&quot;,
                &quot;fill-opacity&quot;: 0,
                &quot;stroke&quot;: &quot;none&quot;
                //&quot;r&quot;: 3
            })).data(&quot;clicked&quot;, 0);
        }
        rectBn.forEach(function (d, i) {
            d.mouseover(function () {
                if (d.data(&quot;clicked&quot;) === 0) {
                    underBn[i].attr('opacity', 0.5);
                    underBn[i].show();
                }
            }).mouseout(function () {
                if (d.data(&quot;clicked&quot;) === 0) {
                    underBn[i].hide();
                }
            });
            d.click(function () {
                for (j = 0; j &lt; underBn.length; j++) {
                    if (j === i) {
                        underBn[j].show();
                    } else {
                        underBn[j].hide();
                    }
                }
                rectBn.forEach(function (eachBn) {
                    if (eachBn !== d) {
                        eachBn.data(&quot;clicked&quot;, 0);
                    }
                });
                if (d.data(&quot;clicked&quot;) === 0) {
                    underBn[i].attr('opacity', 1);
                    underBn[i].show();
                    that.chordGroups.forEach(function (d) {
                        if (d.data('source') !== i &amp;&amp; d.data('target') !== i) {
                            d.attr({
                                'fill-opacity': 0.1
                            });
                        } else {
                            d.attr({
                                'fill-opacity': 0.6
                            });
                        }
                    });

                    d.data(&quot;clicked&quot;, 1);
                } else if (d.data(&quot;clicked&quot;) === 1) {
                    underBn[i].hide();
                    d.data(&quot;clicked&quot;, 0);
                    that.chordGroups.forEach(function (d) {
                        d.attr({
                            'fill-opacity': 0.6
                        });
                    });
                }
            });
        });
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setSource">
    setSource
  </h3>
  

  <p>对原始数据进行处理</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Chord.prototype.setSource()</td> 
      <td></td>
      <td>setSource</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>table(Array)</td>
      <td colspan="2">将要被绘制成饼图的二维表数据</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Chord.prototype.setSource = function (table) {
        if (table[0][0] !== null) {
            var t;
            for (t = 0; t &lt; table[0].length; t++) {
                this.groupNames[t] = table[0][t];
            }
            table = table.slice(1); // 从第一行开始，第0行舍去
        }

        var group = [];
        this.groupNum = table[0].length;
        var groupNum = this.groupNum;
        var that = this;
        table.forEach(function (d, i) {
            if (d.length !== groupNum || table.length !== groupNum) {
                throw new Error(&quot;The source data should be an n * n matrix!&quot;);
            }

            group[i] = [];
            var s;
            for (s = 0; s &lt; groupNum; s++) {
                group[i][s] = Number(d[s]);
            }
        });

        var r;
        for (r = 0; r &lt; groupNum; r++) {
            that.matrix[r] = group[r];
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_layout">
    layout
  </h3>
  

  <p>创建chord布局</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Chord.prototype.layout()</td> 
      <td></td>
      <td>layout</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Chord.prototype.layout = function () {
        var floatTag = this.floatTag;
        var that = this;

        that.canvas.clear();</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_chordLayout">
    chordLayout
  </h3>
  

  <p>ar see = [<br />            [11975, 5871, 8916, 2868],<br />            [1951, 10048, 2060, 6171],<br />            [8010, 16145, 8090, 8045],<br />            [1013, 990, 940, 6907]<br />        ];</p>

  <table class="table">
  
    <tr>
      <td>声明</td>
      <td>chordLayout</td> 
      <td></td>
      <td>chordLayout</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>var chordLayout = d3.layout.chord().padding(0.05) //chord segments之间的padding间隔
        .sortSubgroups(d3.descending) //chord segments细分后的排序规则
        .matrix(that.matrix);</code></pre></td>
    </tr>
  
  </table>
  
  

  <p>ar fillColor = d3.scale.ordinal()<br />            .domain(d3.range(4))<br />            .range(["#000000", "#FFDD89", "#957244", "#F26223"]);</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>//groups数组：获取每个组的起始角度、数值、索引等属性
        var groups = chordLayout.groups();

        //由内外半径、起始角度计算路径字符串
        var pathCalc = d3.svg.arc().innerRadius(that.defaults.innerRadius).outerRadius(that.defaults.outerRadius).startAngle(function (d) {
            return d.startAngle;
        }).endAngle(function (d) {
            return d.endAngle;
        });

        var chords = chordLayout.chords();

        //计算弦的路径曲线
        var chordCalc = d3.svg.chord().radius(that.defaults.innerRadius);

        //Raphael: Paper.path()
        var donutEle;
        //获取每个环形的字符串表示
        var spline;
        //表示每条弦的element
        var chordEle;
        //每条弦的字符串表示
        var belt;

        var num; //每个group分割小格数
        var unitAngle; //每个group所占的角度
        var angle;
        var radian;
        var tickLine;
        var tickStr; //每个tick的路径
        var xTrans, yTrans;
        var aX, aY, bX, bY; //每个tick起始端点的坐标
        var anchor;
        var rotateStr;
        var wordStr;
        var word;
        var textEl;
        var wXTrans, wYTrans;
        var tips;
        var minValue = 1000;
        that.chordGroups = that.canvas.set();
        that.donutGroups = that.canvas.set();

        $(this.node).append(this.floatTag);

        //计算某条弦被赋值为target或source的颜色
        var colorCalc = function (index) {
            var i = chords[index].target.value &gt; chords[index].source.value ? chords[index].target.index : chords[index].source.index;
            return i;
        };

        //添加透明效果

        var mouseOverDonut = function () {
            floatTag.html('&lt;div style = &quot;text-align: center;margin:auto;color:'
            //+ jqNode.color
            +
            &quot;#ffffff&quot; + '&quot;&gt;' + this.data('text') + '&lt;/div&gt;');
            floatTag.css({
                &quot;visibility&quot;: &quot;visible&quot;
            });
            that.underBn.forEach(function (d) {
                d.hide();
            });
            index = this.data(&quot;donutIndex&quot;);
            that.chordGroups.forEach(function (d) {
                if (d.data('source') !== index &amp;&amp; d.data('target') !== index) {
                    d.attr({
                        'fill-opacity': 0.1
                    });
                } else {
                    d.attr({
                        'fill-opacity': 0.6
                    });
                }
            });
            //fade(this.data(&quot;donutIndex&quot;), 0.2);
            that.underBn[index].attr('opacity', 0.5).show();

        };

        var mouseOutDonut = function () {
            floatTag.css({
                &quot;visibility&quot;: &quot;hidden&quot;
            });
            index = this.data(&quot;donutIndex&quot;);
            that.chordGroups.forEach(function (d) {
                if (d.data('source') !== index &amp;&amp; d.data('target') !== index) {
                    d.attr({
                        'fill-opacity': 0.6
                    });
                }
            });
            //fade(this.data(&quot;donutIndex&quot;), 0.6);
            that.underBn[index].hide();
        };

        var mouseoverChord = function () {
            floatTag.html('&lt;div style=&quot;text-align: center;margin:auto;color:#ffffff&quot;&gt;' + this.data('text') + '&lt;/div&gt;');
            floatTag.css({
                &quot;visibility&quot;: &quot;visible&quot;
            });
            that.underBn.forEach(function (d) {
                d.hide();
            });
            that.chordGroups.forEach(function (d) {
                d.attr(&quot;fill-opacity&quot;, 0.1);
            });
            if (navigator.appName !== &quot;Microsoft Internet Explorer&quot;) {
                this.toFront(); //把当前弦移到画布最上层
            }
            this.attr(&quot;fill-opacity&quot;, 0.7);
            that.underBn[this.data('source')].attr('opacity', 0.5).show();
        };

        var mouseoutChord = function () {
            floatTag.css({
                &quot;visibility&quot;: &quot;hidden&quot;
            });
            //alert(&quot;***&quot;);
            that.chordGroups.forEach(function (d) {
                d.attr(&quot;fill-opacity&quot;, 0.6);
            });
            //this.attr(&quot;fill-opacity&quot;, 0.6);
            that.underBn[this.data('source')].hide();
        };

        //画弦*********************************************************
        var t;
        for (t = 0; t &lt;= chords.length - 1; t++) {
            //alert(chords.length);
            belt = chordCalc(chords[t]);
            //hover到弦上时的效果
            tips = that.groupNames[chords[t].source.index] + &quot; to &quot; + that.groupNames[chords[t].target.index] + &quot;: &quot; + that.matrix[chords[t].source.index][chords[t].target.index] + &quot;,&quot; + that.groupNames[chords[t].target.index] + &quot; to &quot; + that.groupNames[chords[t].source.index] + &quot;: &quot; + that.matrix[chords[t].target.index][chords[t].source.index];

            chordEle = that.canvas.path(belt).
            translate((that.defaults.width - this.xOffset) / 2 + this.xOffset, that.defaults.height / 2).attr({
                &quot;path&quot;: belt,
                &quot;fill&quot;: that.getColor(colorCalc(t)),
                &quot;fill-opacity&quot;: 0.6,
                &quot;stroke&quot;: &quot;#d6d6d6&quot;,
                &quot;stroke-opacity&quot;: 0.1
            }).hover(mouseoverChord, mouseoutChord).data(&quot;source&quot;, chords[t].source.index).data(&quot;target&quot;, chords[t].target.index);
            //.attr(&quot;fill&quot;, fillColor(chords[t].target.index))
            chordEle.data('text', tips);
            that.chordGroups.push(chordEle);
        }



        //画圆弧*********************************************************
        var i, r;
        var donutName;
        var nameStr;
        var nameX, nameY;
        var ro, a;
        var sum = 0;
        for (r = 0; r &lt;= groups.length - 1; r++) {
            sum += groups[r].value;
        }

        for (i = 0; i &lt;= groups.length - 1; i++) {
            //画外圈的pie图**************************************
            //计算每个group的path
            spline = pathCalc(groups[i]);
            tips = that.groupNames[i] + &quot;: &quot; + Math.round(groups[i].value) + &quot; &quot; + (groups[i].value * 100 / sum).toFixed(2) + &quot;%&quot;;

            donutEle = that.canvas.path(spline).translate((that.defaults.width - this.xOffset) / 2 + this.xOffset, that.defaults.height / 2).data(&quot;donutIndex&quot;, i).attr({
                &quot;path&quot;: spline,
                &quot;fill&quot;: that.getColor(i),
                &quot;stroke&quot;: that.getColor(i)
            }).mouseover(mouseOverDonut).mouseout(mouseOutDonut);
            donutEle.data('text', tips);
            that.donutGroups.push(donutEle);

            //每个donut上显示名称
            ro = groups[i].startAngle * 180 / Math.PI - 86 + 90;
            a = (groups[i].startAngle * 180 / Math.PI - 86) * Math.PI / 180;
            nameX = ((that.defaults.outerRadius - that.defaults.innerRadius) / 2 + that.defaults.innerRadius) * Math.cos(a);
            nameY = ((that.defaults.outerRadius - that.defaults.innerRadius) / 2 + that.defaults.innerRadius) * Math.sin(a);
            nameStr = &quot;T&quot; + ((that.defaults.width - that.xOffset) / 2 + that.xOffset) + &quot;,&quot; + that.defaults.height / 2 + &quot;R&quot; + ro + &quot;T&quot; + nameX + &quot;,&quot; + nameY;

            if ((groups[i].endAngle - groups[i].startAngle) * 180 / Math.PI &gt; 10) {
                donutName = that.canvas.text().attr(&quot;font&quot;, &quot;12px Verdana&quot;).attr(&quot;text&quot;, that.groupNames[i]).transform(nameStr);
            }

            //画刻度和刻度值**************************************
            num = groups[i].value / 5000;
            //最细分的每个小格代表的数值大小
            unitAngle = (groups[i].endAngle - groups[i].startAngle) * 180 / Math.PI / num;

            var j;
            for (j = 0; j &lt;= num; j++) {
                //计算旋转角度和水平、竖直方向所需平移的距离
                radian = ((groups[i].startAngle * 180 / Math.PI - 90) + j * unitAngle);
                angle = radian * Math.PI / 180;
                xTrans = that.defaults.outerRadius * Math.cos(angle);
                yTrans = that.defaults.outerRadius * Math.sin(angle);

                tickStr = &quot;T&quot; + ((that.defaults.width - that.xOffset) / 2 + that.xOffset) + &quot;,&quot; + that.defaults.height / 2 + &quot;T&quot; + xTrans + &quot;,&quot; + yTrans;

                //刻度线的起点终点坐标
                aX = ((that.defaults.width - that.xOffset) / 2 + that.xOffset) + xTrans;
                aY = that.defaults.height / 2 + yTrans;
                bX = ((that.defaults.width - that.xOffset) / 2 + that.xOffset) + (that.defaults.outerRadius + 6) * Math.cos(angle);
                bY = that.defaults.height / 2 + (that.defaults.outerRadius + 6) * Math.sin(angle);

                tickLine = &quot;M&quot; + aX + &quot;,&quot; + aY + &quot;L&quot; + bX + &quot;,&quot; + bY;
                that.canvas.path(tickLine).attr({
                    'stroke': &quot;#929292&quot;,
                    &quot;stroke-width&quot;: '1px'
                }); //绘制刻度

                //每隔五个刻度，绘制一次文字
                if (j % 2 === 0) {
                    //计算text-anchor
                    if (radian + 90 &lt; 180) {
                        anchor = &quot;start&quot;;
                    } else {
                        anchor = &quot;end&quot;;
                    }

                    //计算文字方向是否需要旋转180度
                    if (radian + 90 &lt; 180) {
                        rotateStr = null;
                    } else {
                        rotateStr = &quot;R180&quot;;
                    }

                    wXTrans = (that.defaults.outerRadius + 10) * Math.cos(angle);
                    wYTrans = (that.defaults.outerRadius + 10) * Math.sin(angle);

                    word = j % 2 ? &quot;&quot; : Math.round(((groups[i].value / num) * j) / 1000);

                    wordStr = &quot;T&quot; + ((that.defaults.width - that.xOffset) / 2 + that.xOffset) + &quot;,&quot; + that.defaults.height / 2 + &quot;R&quot; + radian</code></pre></td>
    </tr>
  
  </table>
  
  

  <p>groups[i].startAngle * 180 / Math.PI - 90)</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>+ rotateStr + &quot;T&quot; + wXTrans + &quot;,&quot; + wYTrans;

                    //绘制文字
                    textEl = that.canvas.text(0, 0, word).attr(&quot;font&quot;, &quot;12px Verdana&quot;).transform(wordStr).attr(&quot;text-anchor&quot;, anchor).attr('fill', &quot;#929292&quot;);
                }
            }
        }</code></pre></td>
    </tr>
  
  </table>
  
  

  <p>his.canvas.text().attr("font", "12px arial").translate((that.defaults.width - this.xOffset) / 2 + this.xOffset, this.defaults.height).attr("text", "The unit of the scale on the periphery is 1000. \n 刻度值的单位为1000。");</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>};

    return Chord;
});</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/diff" class="api">
  <h2>charts/diff: API索引</h2>
  <ul class="indexs">
  
    <li>
      <a href="#_Diff">Diff</a>
    </li>

    <li>
      <a href="#_createCanvas">createCanvas</a>
    </li>

    <li>
      <a href="#_render">render</a>
    </li>

    <li>
      <a href="#_setSource">setSource</a>
    </li>

    <li>
      <a href="#_layout">layout</a>
    </li>

  </ul>
  <hr />

  

  <table class="table">
  

  
  </table>
  
  
  <h3 id="_Diff">
    Diff
  </h3>
  

  <p>构造函数</p>

  <table class="table">
  
    <tr>
      <td>声明</td>
      <td>Diff</td> 
      <td></td>
      <td>Diff</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>node(Object)</td>
      <td colspan="2">表示在html的哪个容器中绘制该组件</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>options(Object)</td>
      <td colspan="2">为用户自定义的组件的属性，比如画布大小</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>var Diff = DataV.extend(DataV.Chart, {
        type: &quot;Diff&quot;,
        initialize: function (node, options) {
            this.node = this.checkContainer(node);

            //图的大小设置
            this.defaults.width = 900;
            this.defaults.height = 800;

            //设置用户指定的属性
            this.setOptions(options);

            //创建画布
            this.createCanvas();
        }
    });</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_createCanvas">
    createCanvas
  </h3>
  

  <p>创建画布</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Diff.prototype.createCanvas()</td> 
      <td></td>
      <td>createCanvas</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Diff.prototype.createCanvas = function () {
        this.canvas = new Raphael(this.node, this.defaults.width, this.defaults.height);
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_render">
    render
  </h3>
  

  <p>绘制弦图</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Diff.prototype.render()</td> 
      <td></td>
      <td>render</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Diff.prototype.render = function () {
        this.layout();
    };

    // 计算顺序的相似度
    var diffMap = function (list1, list2) {
      var map = [];
      var hit = 0;
      var lastIndex = -1;
      for (var i = 0; i &lt; list1.length; i++) {
        var index = _.indexOf(list2, list1[i]);
        if (index === -1) {
          continue;
        } else {
          if (index &gt; lastIndex) {
            lastIndex = index;
            map.push([i, index]);
          }
          hit++;
        }
      }
      console.log(map);
      console.log(map.length / list1.length);
      console.log(hit / list1.length);
      return map;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setSource">
    setSource
  </h3>
  

  <p>对原始数据进行处理</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Diff.prototype.setSource()</td> 
      <td></td>
      <td>setSource</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>table(Array)</td>
      <td colspan="2">将要被绘制成饼图的二维表数据</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Diff.prototype.setSource = function (table1, table2) {
        this.rawData = [table1, table2];
        this.diffMap = diffMap(table1, table2);
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_layout">
    layout
  </h3>
  

  <p>创建chord布局</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Diff.prototype.layout()</td> 
      <td></td>
      <td>layout</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Diff.prototype.layout = function () {
        var that = this;
        var canvas = that.canvas;

        var paddingLeft = 10;
        var paddingTop = 10;
        var height = 20;
        var distance = 50;
        var width = (this.defaults.width - 2 * paddingLeft - distance) / 2;

        for (var j = 0, k = this.rawData.length; j &lt; k; j++) {
            var maped = _.pluck(this.diffMap, j);
            for (var i = 0, l = this.rawData[j].length; i &lt; l; i++) {
                canvas.rect(paddingLeft + j * (width + distance), paddingTop + height * i, width, height).attr({fill: _.indexOf(maped, i) !== -1 ? &quot;#00ff00&quot; : &quot;#ff0000&quot;});
                canvas.text(paddingLeft + j * (width + distance), paddingTop + height * i + height / 2, this.rawData[j][i]).attr({'text-anchor': 'start'});
            }
        }
        for (var i = 0, l = this.diffMap.length; i &lt; l; i++) {
            var line = this.diffMap[i];
            canvas.path(&quot;M&quot; + (paddingLeft + width) + ' ' + (paddingTop + height * line[0] + height / 2) + &quot;L&quot; + (paddingLeft + width + distance) + &quot; &quot; + (paddingTop + height * line[1] + height / 2)).attr({stroke: '#00ff00'});
        }
    };

    return Diff;
});</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/flow" class="api">
  <h2>charts/flow: API索引</h2>
  <ul class="indexs">
  
    <li>
      <a href="#_Flow">Flow</a>
    </li>

  </ul>
  <hr />

  

  <table class="table">
  

  
  </table>
  
  
  <h3 id="_Flow">
    Flow
  </h3>
  

  <p>Flow构造函数</p>

  <table class="table">
  
    <tr>
      <td>声明</td>
      <td>Flow</td> 
      <td></td>
      <td>Flow</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>var Flow = DataV.extend(DataV.Chart, {
        initialize: function (node, options) {
            this.type = &quot;Flow&quot;;
            this.node = this.checkContainer(node);

            // Properties
            this.font = {};

            // Canvas
            this.defaults.width = 500;
            this.defaults.height = 400;
            this.defaults.deep = 150;
            this.defaults.radius = 50;
            this.defaults.xStep = 300;
            this.defaults.xStart = 200;
            this.defaults.yStart = 50;

            this.setOptions(options);
            this.createCanvas();
        }
    });

    Flow.prototype.setSource = function (source) {
        var conf = this.defaults;

        this.rawData = source;
        this.source = this.remapSource(source);
    };

    Flow.prototype.remapSource = function (data) {
        console.log(data);
        var dataLength = data.length;
        var remapData = [];

        var total;
        var i;
        for (i = 0; i &lt; dataLength; i++){
            if (!data[i][3]) {
                total = data[i][2];
                remapData.push({id: data[i][0], name: data[i][1], value: data[i][2], pid: data[i][3], child: [], deep: 0});
            } else {
                remapData.push({id: data[i][0], name: data[i][1], value: data[i][2], pid: data[i][3], child: [], deep: 0});
            }
        }

        var conf = this.defaults;
        var width = conf.width;
        var height = conf.height;
        var radius = conf.radius;
        var xStep = conf.xStep;
        var xStart = conf.xStart;
        var yStart = conf.yStart;
        var depth = 0;

        for (i = 0; i &lt; dataLength; i++){
            if (remapData[i].pid) {
                remapData[i].deep = remapData[remapData[i].pid - 1].deep + 1;
                remapData[remapData[i].pid - 1].child.push(remapData[i].id - 1);
                if (remapData[i].deep &gt; depth) {
                    depth = remapData[i].deep;
                }
            }
            // remapData[remapData[i].pid].child.push(remapData[i].id);
        }

        this.depth = depth;
        radius = Math.min(Math.min((width - xStep * (depth - 1) - xStart * 2) / depth, height*0.55), radius);
        console.log(&quot;r:&quot; + radius);
        for (i = 0; i &lt; dataLength; i++){
            remapData[i].percent = remapData[i].value / total;
            remapData[i].radius = radius * remapData[i].percent;
        }
        return remapData;
        // return data;
    };

    Flow.prototype.layout = function () {
        var conf = this.defaults;
        var width = conf.width;
        var height = conf.height;
        var xStart = conf.xStart;
        var yStart = conf.yStart;
        var xStep = conf.xStep;
        var remapData = this.source;

        //console.log(this.source);
        var circleData = [];

        circleData.push({x: width * 0.24, y: height * 0.42, radius: Math.max(10, remapData[0].radius), deep: remapData[0].deep, name: remapData[0].name, value: remapData[0].value});
        circleData.push({x: width * 0.5, y: height * 0.245, radius: Math.max(10, remapData[1].radius), deep: remapData[1].deep, name: remapData[1].name, value: remapData[1].value});
        circleData.push({x: width * 0.5, y: height * 0.6, radius: Math.max(10, remapData[2].radius), deep: remapData[2].deep, name: remapData[2].name, value: remapData[2].value});
        circleData.push({x: width * 0.72, y: height * 0.5, radius: Math.max(10, remapData[3].radius), deep: remapData[3].deep, name: remapData[3].name, value: remapData[3].value});
        circleData.push({x: width * 0.72, y: height * 0.817, radius: Math.max(10, remapData[4].radius), deep: remapData[4].deep, name: remapData[4].name, value: remapData[4].value});

        for (i = 0;i &lt; circleData.length; i++) {
            console.log(circleData[i].x);
        }

        this.circleData = circleData;
    };

    Flow.prototype.getColor = function () {

        var colorMatrix = DataV.getColor();
        
        return color;
    };

    // Tree.prototype.getFont = function () {
    //     //var conf = this.defaults;

    //     return DataV.getFont();
    // };

    Flow.prototype.createCanvas = function () {
        var conf = this.defaults;
        this.canvas = new Raphael(this.node, conf.width, conf.height);

        this.DOMNode = $(this.canvas.canvas);
        var that = this;
        this.DOMNode.click(function (event) {
            that.trigger(&quot;click&quot;, event);
        });
        this.DOMNode.dblclick(function (event) {
            that.trigger(&quot;dblclick&quot;, event);
        });

        var mousewheel = document.all ? &quot;mousewheel&quot; : &quot;DOMMouseScroll&quot;;
        this.DOMNode.bind(mousewheel, function (event) {
            that.trigger(&quot;mousewheel&quot;, event);
        });

        this.DOMNode.bind(&quot;contextmenu&quot;, function (event) {
            that.trigger(&quot;contextmenu&quot;, event);
        });

        this.DOMNode.delegate(&quot;circle&quot;, &quot;click&quot;, function (event) {
            that.trigger(&quot;circle_click&quot;, event);
        });

        this.DOMNode.delegate(&quot;circle&quot;, &quot;mouseover&quot;, function (event) {
            that.trigger(&quot;circle_mouseover&quot;, event);
        });

        this.DOMNode.delegate(&quot;circle&quot;, &quot;mouseout&quot;, function (event) {
            that.trigger(&quot;circle_mouseout&quot;, event);
        });

        //console.log(this.canvas);
    };


    Flow.prototype.getLinkPath = function (fx, fy, tx, ty) {
        var conf = this.defaults;

        var c1x = fx + (tx - fx) / 1.5;
        var c1y = fy;
        var c2x = tx - (tx - fx) / 4;
        var c2y = ty - (ty - fy) / 2;

        var link_path = [[&quot;M&quot;, fx, fy],
            [&quot;S&quot;, c1x, c1y, tx, ty]];

        return link_path;
    };

    Flow.prototype.generatePaths = function () {
        var canvas = this.canvas;
        var source = this.source;
        var conf = this.defaults;
        var radius = conf.radius;
        //canvas.clear();
        // var font = this.getFont();
        var font_family = '微软雅黑';
        var font_size = 8;
        var depth = this.depth;
        var crilceData = this.circleData;
        var l = crilceData.length;
        var getLinkPath = this.getLinkPath;

        canvas.path().attr({stroke:  &quot;#cdcdcd&quot;, &quot;stroke-width&quot;: 2}).attr({path: getLinkPath(crilceData[0].x, crilceData[0].y, crilceData[1].x, crilceData[1].y)});
        canvas.path().attr({stroke:  &quot;#cdcdcd&quot;, &quot;stroke-width&quot;: 2}).attr({path: getLinkPath(crilceData[0].x, crilceData[0].y, crilceData[2].x, crilceData[2].y)});
        canvas.path().attr({stroke:  &quot;#cdcdcd&quot;, &quot;stroke-width&quot;: 2}).attr({path: getLinkPath(crilceData[2].x, crilceData[2].y, crilceData[3].x, crilceData[3].y)});
        canvas.path().attr({stroke:  &quot;#cdcdcd&quot;, &quot;stroke-width&quot;: 2}).attr({path: getLinkPath(crilceData[2].x, crilceData[2].y, crilceData[4].x, crilceData[4].y)});

        var i, d;
        var thisRadius;
        var thisColor;
        var titelPath = [];
        var valuePath = [];
        for (i = 0 ; i &lt; l ; i++) {
            d = crilceData[i];
            thisRadius = Math.max(27, d.radius);
            if (i === 1) {
                thisColor = &quot;#b4e481&quot;;
            } else if (i === 4) {
                thisColor = &quot;#cd3a19&quot;;
            } else {
                thisColor = &quot;#ffe79d&quot;;
            }
            canvas.circle(d.x, d.y, thisRadius)
            .attr({&quot;stroke&quot;: &quot;none&quot;, fill: thisColor});
            titelPath.push(canvas.text(0, 0, d.name).attr({'font-size': 12}));
            if (i &lt; l - 2) {
                titelPath[i].transform(&quot;t&quot; + d.x + &quot;,&quot; + (d.y - thisRadius - titelPath[i].getBBox().height/2 - 5));
            } else {
                titelPath[i].transform(&quot;t&quot; + d.x + &quot;,&quot; + (d.y - thisRadius - titelPath[i].getBBox().height/2 - 5)).attr({&quot;text-anchor&quot;: &quot;start&quot;});
            }

            if (i &lt; l - 1) {
                valuePath.push(canvas.text(d.x, d.y, d.value + &quot;人&quot;).attr({'font-size': 12}));
            } else {
                valuePath.push(canvas.text(d.x, d.y, d.value + &quot;人&quot;).attr({fill: &quot;#ffffff&quot;, 'font-size': 12}));
            }
        }

        var n = 0;

        var node;
        var num = 0;

        var nodes = canvas.set();
        var path = [];
        var textpath = [];
        
        var tree = this;
    };

    Flow.prototype.render = function (options) {
        var st = new Date().getTime();
        this.canvas.clear();
        this.setOptions(options);
        this.layout();
        var st2 = new Date().getTime();
        console.log(st2 - st);

        this.generatePaths();
        var et = new Date().getTime();
        console.log(et - st2);
        //this.canvas.renderfix();
    };

    return Flow;
});</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/force" class="api">
  <h2>charts/force: API索引</h2>
  <ul class="indexs">
  
    <li>
      <a href="#_Force">Force</a>
    </li>

    <li>
      <a href="#_setSource">setSource</a>
    </li>

    <li>
      <a href="#_createCanvas">createCanvas</a>
    </li>

    <li>
      <a href="#_getColor">getColor</a>
    </li>

    <li>
      <a href="#_getRadius">getRadius</a>
    </li>

    <li>
      <a href="#_getOpacity">getOpacity</a>
    </li>

    <li>
      <a href="#_update">update</a>
    </li>

    <li>
      <a href="#_legend">legend</a>
    </li>

    <li>
      <a href="#_layout">layout</a>
    </li>

    <li>
      <a href="#_animate">animate</a>
    </li>

    <li>
      <a href="#_render">render</a>
    </li>

  </ul>
  <hr />

  

  <table class="table">
  

  
  </table>
  
  
  <h3 id="_Force">
    Force
  </h3>
  

  <p>构造函数</p>

  <table class="table">
  
    <tr>
      <td>声明</td>
      <td>Force</td> 
      <td></td>
      <td>Force</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>node(Object)</td>
      <td colspan="2">表示在html的哪个容器中绘制该组件</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>options(Object)</td>
      <td colspan="2">为用户自定义的组件的属性，比如画布大小</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>var Force = DataV.extend(DataV.Chart, {
        initialize: function (node, options) {
            this.type = &quot;Force&quot;;
            this.node = this.checkContainer(node);
            this.net = {};
            this.linkValeMin = 0;
            this.linkValeMax = 1;
            this.nodeValueMin = 0;
            this.nodeValueMax = 1;
            this.clicked = false;
            this.clickedNum = -1;
            this.legendClicked = false;

            // Properties
            this.font = {};

            // Canvas
            this.defaults.legend = true;
            this.defaults.width = 500;
            this.defaults.height = 500;
            this.defaults.linkLength = 50;
            this.defaults.linkWidth = 2;
            this.defaults.classNum = 6;
            this.defaults.forceValue = 10;
            this.defaults.iterate = 100;
            this.defaults.browserName = navigator.appName;

            this.setOptions(options);
            this.defaults.charge = -(this.defaults.width + this.defaults.height) / this.defaults.forceValue;
            this.legendArea = [20, (this.defaults.height - 20 - this.defaults.classNum * 20), 200, 220];
            if (this.defaults.legend) {
                this.xOffset = this.legendArea[2];
            } else {
                this.xOffset = 0;
            }

            this.createCanvas();
        }
    });</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setSource">
    setSource
  </h3>
  

  <p>Set CSV content to force-directed net</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Force.prototype.setSource()</td> 
      <td></td>
      <td>setSource</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>table(Array)</td>
      <td colspan="2">the csv table to be rendered</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Force.prototype.setSource = function (table) {
        //this.net = json;
        if (table[0][0] === &quot;Id&quot;) {
            table = table.slice(1);
        }
        var nData = [];
        var lData = [];
        var isNode = true;
        var nodeNum;
        var that = this;
        table.forEach(function (d, i) {
            var value;
            if (isNode) {
                if (d[0] === &quot;Source&quot;) {
                    isNode = false;
                    nodeNum = i + 1;
                } else {
                    if (d[0] === &quot;&quot;) {
                        throw new Error(&quot;ID can not be empty(line:&quot; + (i + 1) + &quot;).&quot;);
                    }
                    value = that._toNum(d[2]);
                    nData[i] = {
                        name: d[1],
                        nodeValue: value
                    };
                    if (i === 0) {
                        that.nodeValueMin = value;
                        that.nodeValueMax = value;
                    }
                    that.nodeValueMin = (value &lt; that.nodeValueMin) ? value : that.nodeValueMin;
                    that.nodeValueMax = (value &gt; that.nodeValueMax) ? value : that.nodeValueMax;
                }
            } else {
                if (d[0] === &quot;&quot;) {
                    throw new Error(&quot;Source can not be empty(line:&quot; + (i + 1) + &quot;).&quot;);
                }
                if (d[1] === &quot;&quot;) {
                    throw new Error(&quot;Target can not be empty(line:&quot; + (i + 1) + &quot;).&quot;);
                }
                value = that._toNum(d[2]);
                lData[i - nodeNum] = {
                    source: that._toNum(d[0]),
                    target: that._toNum(d[1]),
                    value: that._toNum(d[2])
                };
                if (i === nodeNum) {
                    that.linkValueMin = value;
                    that.linkValueMax = value;
                }
                that.linkValueMin = (value &lt; that.linkValueMin) ? value : that.linkValueMin;
                that.linkValueMax = (value &gt; that.linkValueMax) ? value : that.linkValueMax;
            }
        });
        this.net.nodes = nData;
        this.net.links = lData;
        this.nodeValueMax++;
        this.linkValueMax++;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_createCanvas">
    createCanvas
  </h3>
  

  <p>创建画布</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Force.prototype.createCanvas()</td> 
      <td></td>
      <td>createCanvas</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Force.prototype.createCanvas = function () {
        var conf = this.defaults;
        this.canvas = new Raphael(this.node, conf.width, conf.height);
        //var c = this.canvas.circle(50, 50, 40);
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_getColor">
    getColor
  </h3>
  

  <p>获取节点颜色</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Force.prototype.getColor()</td> 
      <td></td>
      <td>getColor</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>i(Number)</td>
      <td colspan="2">元素类别编号</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>String</td>
      <td colspan="2">返回颜色值</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Force.prototype.getColor = function (i) {
        var color = DataV.getColor(this.classNum);
        //var k = color.length * (i - this.nodeValueMin-0.1) / (this.nodeValueMax - this.nodeValueMin);
        //if (k &lt; 0) k = 0;
        return color[i % color.length][0];
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_getRadius">
    getRadius
  </h3>
  

  <p>获取节点的半径</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Force.prototype.getRadius()</td> 
      <td></td>
      <td>getRadius</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>value(Number)</td>
      <td colspan="2">元素对应的数据值</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>Number</td>
      <td colspan="2">返回半径值</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Force.prototype.getRadius = function (value) {
        var conf = this.defaults;
        return 16.0 * (value - this.nodeValueMin) / (this.nodeValueMax - this.nodeValueMin) + 8;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_getOpacity">
    getOpacity
  </h3>
  

  <p>获取节点透明度</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Force.prototype.getOpacity()</td> 
      <td></td>
      <td>getOpacity</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>value(Number)</td>
      <td colspan="2">元素类别编号</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>Number</td>
      <td colspan="2">返回透明度值</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Force.prototype.getOpacity = function (value) {
        return 0.083 * (value - this.linkValueMin) / (this.linkValueMax - this.linkValueMin) + 0.078;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_update">
    update
  </h3>
  

  <p>update the layout by modify the attributes of nodes and links</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Force.prototype.update()</td> 
      <td></td>
      <td>update</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Force.prototype.update = function () {
        var that = this;
        var conf = this.defaults;
        var canvas = this.canvas;

        this.nodes = this.canvas.set();
        this.links = this.canvas.set();
        var nodes = this.nodes;
        var links = this.links;
        var i, j, temp;
        this.force.charge(conf.charge).nodes(this.net.nodes).links(this.net.links).start();

        var nodesData = this.net.nodes;
        var linksData = this.net.links;
        var nodesNum = nodesData.length;
        var linksNum = linksData.length;
        var connectMatrix = [];
        var linkMatrix = [];
        conf.iterate = (nodesNum + linksNum) * 2;

        var onMouseClick = function () {
            that.legendClicked = false;
            that.underBn.forEach(function (d) {
                d.hide();
                d.data('clicked', false);
            });
            that.clicked = true;
            if (!this.data('clicked')) {
                if (conf.browserName !== &quot;Microsoft Internet Explorer&quot;) {
                    that.force.linkDistance(conf.linkLength * 2).charge(conf.charge * 2).start();
                }
                that.nodes.forEach(function (d) {
                    d.data('rect').hide();
                    d.data('text').hide();
                    d.attr({
                        &quot;opacity&quot;: 0.2
                    });
                    d.data('clicked', false);
                    d.data('showText', false);
                });
                that.links.forEach(function (d) {
                    d.attr({
                        'stroke-opacity': 0.0
                    });
                });
                that.clickedNum = this.data('index');
                this.data('clicked', true);
                this.data(&quot;link&quot;).forEach(function (d) {
                    d.attr({
                        &quot;stroke-opacity&quot;: d.data('opacity')
                    });
                });
                this.data(&quot;node&quot;).forEach(function (d) {
                    d.attr({
                        &quot;opacity&quot;: 0.9
                    });
                    d.data('showText', true);
                });
                that.underBn[this.data('colorType')].data('clicked', true).attr('opacity', 1).show();
            } else {
                that.clicked = false;
                if (conf.browserName !== &quot;Microsoft Internet Explorer&quot;) {
                    that.force.linkDistance(conf.linkLength).charge(conf.charge).start();
                }
                nodes.forEach(function (d) {
                    d.attr({
                        &quot;opacity&quot;: 0.9
                    });
                    if (d.data('big')) {
                        d.data('showText', true);
                    } else {
                        d.data('rect').hide();
                        d.data('text').hide();
                        d.data('showText', false);
                    }
                });
                links.forEach(function (d) {
                    d.attr({
                        'stroke-opacity': d.data('opacity')
                    });
                });
                this.data('clicked', false);
                that.underBn[this.data('colorType')].hide();
            }
        };

        var onCanvasClick = function () {
            that.legendClicked = false;
            that.underBn.forEach(function (d) {
                d.hide();
                d.data('clicked', false);
            });
            that.clicked = false;
            if (conf.browserName !== &quot;Microsoft Internet Explorer&quot;) {
                that.force.linkDistance(conf.linkLength).charge(conf.charge).start();
            } else {
                that.force.resume();
            }
            nodes.forEach(function (d) {
                d.attr({
                    &quot;opacity&quot;: 0.9
                });
                if (d.data('big')) {
                    d.data('showText', true);
                } else {
                    d.data('rect').hide();
                    d.data('text').hide();
                    d.data('showText', false);
                }
            });
            links.forEach(function (d) {
                d.attr({
                    'stroke-opacity': d.data('opacity')
                });
            });
        };

        var topValue = [];
        var topId = [];
        var topNum = 10;
        if (nodesNum &lt; 10) {
            topNum = nodesNum;
        }
        for (i = 0; i &lt; topNum; i++) {
            topValue[i] = nodesData[i].nodeValue;
            topId[i] = i;
        }
        for (i = 0; i &lt; topNum; i++) {
            for (j = 1; j &lt; topNum - i; j++) {
                if (topValue[j] &lt; topValue[j - 1]) {
                    temp = topValue[j];
                    topValue[j] = topValue[j - 1];
                    topValue[j - 1] = temp;
                    temp = topId[j];
                    topId[j] = topId[j - 1];
                    topId[j - 1] = temp;
                }
            }
        }
        //rapheal绘制部分
        for (i = 0; i &lt; nodesNum; i++) {
            nodesData[i].x = (conf.width + this.xOffset) / 2;
            nodesData[i].y = conf.height / 2;
            var n = nodesData[i];
            var k = Math.floor(conf.classNum * (n.nodeValue - this.nodeValueMin) / (this.nodeValueMax - this.nodeValueMin));
            if (k &gt;= conf.classNum) k = conf.classNum - 1;
            var radius = this.getRadius(n.nodeValue);
            var cnode = canvas.circle(n.x, n.y, radius).attr({
                fill: this.getColor(k),
                'stroke': &quot;#ffffff&quot;,
                'opacity': 0.9
                //title: n.name
            });
            var nodeText = canvas.text(n.x, n.y - radius, n.name).attr({
                'opacity': 1,
                //'font-family': &quot;微软雅黑&quot;,
                'font': '12px Verdana'
            }).hide();
            var nodeRect = canvas.rect(n.x, n.y, nodeText.getBBox().width, nodeText.getBBox().height, 2).attr({
                'fill': &quot;#000000&quot;,
                'stroke-opacity': 0,
                'fill-opacity': 0.1
            }).hide();
            cnode.data('r', radius);
            cnode.data(&quot;name&quot;, n.name);
            cnode.data('text', nodeText);
            cnode.data('rect', nodeRect);
            cnode.data('colorType', k);
            cnode.data('clicked', false);
            cnode.data('index', i);
            cnode.data('big', false);

            if (i &gt;= topNum &amp;&amp; topValue[0] &lt; nodesData[i].nodeValue) {
                topValue[0] = nodesData[i].nodeValue;
                topId[0] = i;
                for (j = 1; j &lt; topNum; j++) {
                    if (topValue[j] &lt; topValue[j - 1]) {
                        temp = topValue[j];
                        topValue[j] = topValue[j - 1];
                        topValue[j - 1] = temp;
                        temp = topId[j];
                        topId[j] = topId[j - 1];
                        topId[j - 1] = temp;
                    } else {
                        break;
                    }
                }
            }

            nodes.push(cnode);
            connectMatrix[i] = [];
            linkMatrix[i] = [];
            connectMatrix[i].push(nodes[i]);
        }

        for (i = 0; i &lt; topNum; i++) {
            nodes[topId[i]].data(&quot;big&quot;, true);
        }


        for (i = 0; i &lt; linksNum; i++) {
            var l = linksData[i];
            var clink = canvas.path(&quot;M&quot; + l.source.x + &quot;,&quot; + l.source.y + &quot;L&quot; + l.target.x + &quot;,&quot; + l.target.y).attr({
                'stroke-width': conf.linkWidth,
                'stroke-opacity': this.getOpacity(l.value)
            }).toBack();
            clink.data('opacity', this.getOpacity(l.value));
            links.push(clink);
            connectMatrix[l.source.index].push(nodes[l.target.index]);
            connectMatrix[l.target.index].push(nodes[l.source.index]);
            linkMatrix[l.source.index].push(links[i]);
            linkMatrix[l.target.index].push(links[i]);
        }

        var background = canvas.rect(0, 0, conf.width, conf.height).attr({
            'fill': '#ffffff',
            'stroke-opacity': 0
        }).toBack();
        background.click(onCanvasClick);

        nodes.forEach(function (d, i) {
            d.data(&quot;node&quot;, connectMatrix[i]);
            d.data(&quot;link&quot;, linkMatrix[i]);
            if (d.data('big')) {
                d.data('showText', true);
            } else {
                d.data('showText', false);
            }
            d.drag(function (dx, dy) {
                d.data('x', this.ox + dx);
                d.data('y', this.oy + dy);
            }, function () {
                that.force.resume();
                this.ox = this.attr(&quot;cx&quot;);
                this.oy = this.attr(&quot;cy&quot;);
                d.data('x', this.ox);
                d.data('y', this.oy);
                d.data('drag', true);
            }, function () {
                that.force.resume();
                d.data('drag', false);
            });
            d.click(onMouseClick); //.mouseup(onmouseup);
            d.mouseover(function () {
                if (conf.browserName !== &quot;Microsoft Internet Explorer&quot;) {
                    that.force.resume();
                }
                this.attr({
                    'r': d.data('r') + 5
                });
                if (!this.data('showText')) {
                    //this.attr('title', &quot;&quot;);
                    this.data('showText', true);
                    this.data('hover', true);
                }
                if (!that.underBn[this.data('colorType')].data('clicked')) {
                    that.underBn[this.data('colorType')].attr('opacity', 0.5).show();
                }
            }).mouseout(function () {
                this.attr({
                    'r': d.data('r')
                });
                //this.attr('title', this.data('name'));
                if (this.data('hover') &amp;&amp; !this.data('clicked')) {
                    d.data('rect').hide();
                    d.data('text').hide();
                    this.data('showText', false);
                    this.data('hover', false);
                }
                if (!that.underBn[this.data('colorType')].data('clicked')) {
                    that.underBn[this.data('colorType')].hide();
                }
            });
        });

    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_legend">
    legend
  </h3>
  

  <p>绘制图例</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Force.prototype.legend()</td> 
      <td></td>
      <td>legend</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Force.prototype.legend = function () {
        var that = this;
        var conf = this.defaults;
        var paper = this.canvas;
        var legendArea = this.legendArea;
        var rectBn = paper.set();
        this.underBn = [];
        var underBn = this.underBn;
        for (i = 0; i &lt;= conf.classNum - 1; i++) {
            //底框
            underBn.push(paper.rect(legendArea[0] + 10, legendArea[1] + 10 + (20 + 3) * i, 180, 20).attr({
                &quot;fill&quot;: &quot;#ebebeb&quot;,
                &quot;stroke&quot;: &quot;none&quot;,
                'opacity': 1
            }).data('clicked', false).hide());
            //色框
            paper.rect(legendArea[0] + 10 + 3, legendArea[1] + 10 + (20 + 3) * i + 6, 16, 8).attr({
                &quot;fill&quot;: that.getColor(i),
                &quot;stroke&quot;: &quot;none&quot;
            });
            //文字
            var min = Math.floor(this.nodeValueMin + i * (this.nodeValueMax - this.nodeValueMin) / conf.classNum);
            var max = Math.floor(min + (this.nodeValueMax - this.nodeValueMin) / conf.classNum);
            paper.text(legendArea[0] + 10 + 3 + 16 + 8, legendArea[1] + 10 + (20 + 3) * i + 10, min + &quot; ~ &quot; + max).attr({
                &quot;fill&quot;: &quot;black&quot;,
                &quot;fill-opacity&quot;: 1,
                &quot;font-family&quot;: &quot;Verdana&quot;,
                &quot;font-size&quot;: 12
            }).attr({
                &quot;text-anchor&quot;: &quot;start&quot;
            });
            //选框
            rectBn.push(paper.rect(legendArea[0] + 10, legendArea[1] + 10 + (20 + 3) * i, 180, 20).attr({
                &quot;fill&quot;: &quot;white&quot;,
                &quot;fill-opacity&quot;: 0,
                &quot;stroke&quot;: &quot;none&quot;
                //&quot;r&quot;: 3
            })).data(&quot;clicked&quot;, 0);
        }
        rectBn.forEach(function (d, i) {
            d.mouseover(function () {
                if (!underBn[i].data('clicked')) {
                    underBn[i].attr('opacity', 0.5);
                    underBn[i].show();
                }
            }).mouseout(function () {
                if (!underBn[i].data('clicked')) {
                    underBn[i].hide();
                }
            });
            d.click(function () {
                that.clicked = false;
                if (conf.browserName !== &quot;Microsoft Internet Explorer&quot;) {
                    that.force.linkDistance(conf.linkLength).charge(conf.charge).start();
                }
                for (j = 0; j &lt; underBn.length; j++) {
                    if (j === i) {
                        underBn[j].show();
                    } else {
                        underBn[j].hide();
                    }
                }
                rectBn.forEach(function (eachBn) {
                    if (eachBn !== d) {
                        eachBn.data(&quot;clicked&quot;, 0);
                    }
                });
                if (d.data(&quot;clicked&quot;) === 0) {
                    that.legendClicked = true;
                    underBn[i].attr('opacity', 1);
                    underBn[i].data('clicked', true);
                    underBn[i].show();
                    that.nodes.forEach(function (d) {
                        if (d.data('colorType') === i) {
                            d.attr({
                                &quot;opacity&quot;: 0.9
                            });
                            d.data('showText', true);
                        } else {
                            d.attr({
                                &quot;opacity&quot;: 0.2
                            });
                            d.data('rect').hide();
                            d.data('text').hide();
                            d.data('showText', false);
                        }
                    });
                    that.links.forEach(function (d) {
                        d.attr({
                            &quot;stroke-opacity&quot;: 0
                        });
                    });
                    d.data(&quot;clicked&quot;, 1);
                } else if (d.data(&quot;clicked&quot;) === 1) {
                    that.legendClicked = false;
                    underBn[i].data('clicked', false);
                    underBn[i].hide();
                    d.data(&quot;clicked&quot;, 0);
                    that.nodes.forEach(function (d) {
                        d.attr({
                            &quot;opacity&quot;: 0.9
                        });
                        if (d.data('big')) {
                            d.data('showText', true);
                        } else {
                            d.data('rect').hide();
                            d.data('text').hide();
                            d.data('showText', false);
                        }
                    });
                    that.links.forEach(function (d) {
                        d.attr({
                            &quot;stroke-opacity&quot;: d.data('opacity')
                        });
                    });
                }
            });
        });
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_layout">
    layout
  </h3>
  

  <p>create the force-direct layout</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Force.prototype.layout()</td> 
      <td></td>
      <td>layout</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Force.prototype.layout = function () {
        var conf = this.defaults;
        this.force = d3.layout.force().linkDistance(conf.linkLength).size([conf.width + this.xOffset, conf.height]).theta(1.5);
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_animate">
    animate
  </h3>
  

  <p>update the force-direct layout animation</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Force.prototype.animate()</td> 
      <td></td>
      <td>animate</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Force.prototype.animate = function () {
        var conf = this.defaults;
        var nodes = this.nodes;
        var links = this.links;
        var tick = 0;
        var that = this;

        var nodesData = this.net.nodes;
        var linksData = this.net.links;

        this.force.on(&quot;tick&quot;, function () {
            if (conf.browserName !== &quot;Microsoft Internet Explorer&quot; || tick &gt; conf.iterate) {
                if (tick % 2 === 0) {
                    nodes.forEach(function (d, i) {
                        var margin = d.data('r');
                        var nd = nodesData[i];
                        if (d.data('drag')) {
                            nd.x = d.data('x');
                            nd.y = d.data('y');
                        }
                        nd.x = (nd.x &lt; margin + that.xOffset) ? (margin + that.xOffset) : nd.x;
                        nd.x = (nd.x &gt; conf.width - margin) ? conf.width - margin : nd.x;
                        nd.y = (nd.y &lt; margin) ? margin : nd.y;
                        nd.y = (nd.y &gt; conf.height - margin) ? conf.height - margin : nd.y;
                        var bx = d.data('text').getBBox().width / 2;
                        var by = d.data('text').getBBox().height / 2;

                        if (that.clicked) {
                            var mx = nodesData[that.clickedNum].x;
                            var my = nodesData[that.clickedNum].y;
                            var tx, ty;
                            if (d.data('clicked')) {

                                if (conf.browserName !== &quot;Microsoft Internet Explorer&quot;) {
                                    nd.x = (conf.width + that.xOffset) / 2;
                                    nd.y = conf.height / 2;
                                }
                                d.data('rect').attr({
                                    'x': nd.x - bx,
                                    'y': nd.y + d.data('r')
                                });
                                d.data('text').attr({
                                    'x': nd.x,
                                    'y': nd.y + by + d.data('r')
                                });
                                d.data('rect').show();
                                d.data('text').show();
                            } else if (d.data('showText')) {
                                var lx = (nd.x - mx);
                                var ly = (nd.y - my);
                                var length = Math.sqrt(lx * lx + ly * ly);
                                tx = nd.x + bx * lx / length;
                                ty = nd.y + by * ly / length;
                                tx = (nd.x &lt; mx) ? tx - d.data('r') : tx + d.data('r');
                                ty = (nd.y &lt; my) ? ty - d.data('r') : ty + d.data('r');
                                tx = (tx &lt; margin + that.xOffset) ? (margin + that.xOffset) : tx;
                                tx = (tx &gt; conf.width - margin) ? conf.width - margin : tx;
                                ty = (ty &lt; margin) ? margin : ty;
                                ty = (ty &gt; conf.height - margin) ? conf.height - margin : ty;
                                d.data('rect').attr({
                                    'x': tx - bx,
                                    'y': ty - by
                                });
                                d.data('text').attr({
                                    'x': tx,
                                    'y': ty
                                });
                                d.data('rect').show();
                                d.data('text').show();
                            }
                        } else if (d.data('showText')) {
                            d.data('rect').attr({
                                'x': nd.x - bx,
                                'y': nd.y - by + 4 + d.data('r')
                            });
                            d.data('text').attr({
                                'x': nd.x,
                                'y': nd.y + 4 + d.data('r')
                            });
                            try {
                                d.data('rect').show();
                                d.data('text').show();
                            } catch (e) {}

                        }
                        d.attr({
                            'cx': nd.x,
                            'cy': nd.y
                        });
                    });
                    links.forEach(function (d, i) {
                        d.attr('path', &quot;M&quot; + linksData[i].source.x + &quot;,&quot; + linksData[i].source.y + &quot;L&quot; + linksData[i].target.x + &quot;,&quot; + linksData[i].target.y);
                    });
                }
            }++tick;
        });
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_render">
    render
  </h3>
  

  <p>render the force-directed net on the canvas and keep updating</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Force.prototype.render()</td> 
      <td></td>
      <td>render</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>options(Object)</td>
      <td colspan="2">user options</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Force.prototype.render = function (options) {
        this.setOptions(options);
        this.canvas.clear();
        this.layout();
        if (this.defaults.legend) {
            this.legend();
        }
        this.update();
        this.animate();
    };

    return Force;
});</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/histogram" class="api">
  <h2>charts/histogram: API索引</h2>
  <ul class="indexs">
  
    <li>
      <a href="#_Histogram">Histogram</a>
    </li>

    <li>
      <a href="#_createCanvas">createCanvas</a>
    </li>

    <li>
      <a href="#_setSource">setSource</a>
    </li>

    <li>
      <a href="#_setAxis">setAxis</a>
    </li>

    <li>
      <a href="#_drawDiagram">drawDiagram</a>
    </li>

    <li>
      <a href="#_render">render</a>
    </li>

  </ul>
  <hr />

  

  <p>lobal Raphael, d3, $, define</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>;(function (name, definition) {
    if (typeof define === 'function') { // Module
        define(definition);
    } else { // Assign to common namespaces or simply the global object (window)
        this[name] = definition(function (id) { return this[id];});
    }
})('Histogram', function (require) {
    var DataV = require('DataV');</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_Histogram">
    Histogram
  </h3>
  

  <p>Histogram构造函数<br />Create histogram in a dom node with id "chart", default width is 522; height is 522px;</p>

<h2>Options</h2>

<ul>
<li><code>width</code> 宽度，默认为节点宽度</li>
<li><code>typeNames</code> 指定y轴上数据类目</li>
</ul>

<h2>Examples</h2>

<div class="highlight"><pre lang="">var histogram = new Histogram("chart", {"width": 500, "height": 600, "typeNames": ["Y", "Z"]});
</pre></div>

  <table class="table">
  
    <tr>
      <td>声明</td>
      <td>Histogram</td> 
      <td></td>
      <td>Histogram</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>node(Mix)</td>
      <td colspan="2">The dom node or dom node Id</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>options(Object)</td>
      <td colspan="2">options json object for determin histogram style.</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>var Histogram = DataV.extend(DataV.Chart, {
        initialize: function (node, options) {
            this.type = &quot;Histogram&quot;;
            this.node = this.checkContainer(node);
            this.defaults = {};

            // Properties
            this.defaults.dimensionX = {}; //dimension of X axis(horizonal).  array type
            this.defaults.demensionY = {}; //dimension of Y axis(vertical).  array type
            this.defaults.allDimensions = {};
            this.defaults.dimensionDomain = {};
            this.defaults.typeNames = [];

            // canvas parameters
            this.defaults.width = 522;
            this.defaults.height = 522;
            this.defaults.margin = 50;
            this.defaults.gap = 15;
            this.defaults.circleR = 3;
            this.defaults.barColor = [&quot;#308BE6&quot;,&quot;#8EEC00&quot;];
            
            //图例区域的左上顶点坐标x，y，宽，高
            this.defaults.legendArea = [422, 50, 472, 220];
            //散点矩阵区域的左上顶点坐标x，y，宽，高
            this.defaults.diagramArea = [50, 50, 422, 472];

            this.defaults.typeName = &quot;undefined&quot;; //默认情况是没有分类
            this.defaults.tagDimen = &quot;undefined&quot;;


            this.setOptions(options);
            this.createCanvas();
        }   
    });</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_createCanvas">
    createCanvas
  </h3>
  

  <p>创建画布</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Histogram.prototype.createCanvas()</td> 
      <td></td>
      <td>createCanvas</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Histogram.prototype.createCanvas = function () {
        var conf = this.defaults;
        this.node.style.position = &quot;relative&quot;;
        this.canvas = new Raphael(this.node, conf.width, conf.height);

        this.canvasF = document.getElementById(this.container);
        this.floatTag = DataV.FloatTag()(this.canvasF);
        this.floatTag.css({&quot;visibility&quot;: &quot;hidden&quot;});
	};</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setSource">
    setSource
  </h3>
  

  <p>设置数据源</p>

<p>Examples：</p>

<div class="highlight"><pre lang="">histogram.setSource(source);
</pre></div>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Histogram.prototype.setSource()</td> 
      <td></td>
      <td>setSource</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>source(Array)</td>
      <td colspan="2">数据源 第一列为排布在x轴的数据，后n列为排布在y轴的数据</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Histogram.prototype.setSource = function (source) {
        var conf = this.defaults;
        var i, j, l;
        var xTemp = [],
            yTemp = [];
        xTemp = source[0][0];
        yTemp = source[0][1];
        
        conf.allDimensions = source[0];
        conf.dimensionX = xTemp;
        conf.dimensionY = yTemp;
        conf.xAxisData = [];
        this.source = [];
        
        for (i = 1, l = source.length; i &lt; l; i++) {
            if (conf.typeNames.length == 1) {
                var line = {}, dimenT = conf.allDimensions;
                for (j = 0, ll = dimenT.length; j &lt; ll; j++) {
                    line[dimenT[j]] = source[i][j]; //each line is an array, contains value for each dimension
                }
                this.source.push(line);
            }
            else if (conf.typeNames.length == 2) {
                var lineY = {}, lineZ = {}, dimenT = conf.allDimensions;
                lineY[dimenT[0]] = i;
                lineY[dimenT[1]] = source[i][1];
                this.source.push(lineY);
                lineZ[dimenT[0]] = i;
                lineZ[dimenT[1]] = source[i][2];
                this.source.push(lineZ);
                conf.xAxisData.push(source[i][0]);
            }
        }
        //设置默认的定义域
        var getExtent = function (s, dimen) {
            return d3.extent(s, function (p) {
                return +p[dimen];
            });
        };
        var dimen;
        for (i = 0, l = conf.allDimensions.length; i &lt; l; i++) {
            dimen = conf.allDimensions[i];
            conf.dimensionDomain[dimen] = getExtent(this.source, dimen);
            conf.dimensionDomain[dimen][0] = 0;
        }
	};</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setAxis">
    setAxis
  </h3>
  

  <p>设置坐标轴</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Histogram.prototype.setAxis()</td> 
      <td></td>
      <td>setAxis</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Histogram.prototype.setAxis = function () {
        var conf = this.defaults;
        var tagWidth = conf.width / 5 &gt; 50 ? 50 : conf.width / 5;
        conf.legendArea = [conf.width - tagWidth - conf.margin, 0, conf.width, conf.height];
        conf.diagramArea = [0, 0, conf.width - tagWidth - conf.margin, conf.height];
    
        var w = conf.diagramArea[2] - 2 * conf.margin;
        var h = conf.diagramArea[3] - conf.margin;
		
        this.x = {};
        this.y = {};
        var x = this.x,
            y = this.y;
        var tickAr = [5];
        //设置x轴
        x[conf.dimensionX] = d3.scale.linear().domain(conf.dimensionDomain[conf.dimensionX]).range([conf.margin, w]);
        x[conf.dimensionX].ticks = x[conf.dimensionX].ticks.apply(x[conf.dimensionX], tickAr);
        //设置y轴
        y[conf.dimensionY] = d3.scale.linear().domain(conf.dimensionDomain[conf.dimensionY]).range([h, conf.margin]);
        y[conf.dimensionY].ticks = y[conf.dimensionY].ticks.apply(y[conf.dimensionY], tickAr);
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_drawDiagram">
    drawDiagram
  </h3>
  

  <p>进行柱状图的绘制</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Histogram.prototype.drawDiagram()</td> 
      <td></td>
      <td>drawDiagram</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Histogram.prototype.drawDiagram = function () {
        var that = this;
        var conf = this.defaults;
        var paper = this.canvas;
        var x = this.x;
        var y = this.y;
        var i, j, k, l;
        //画坐标轴
        var axisLines = paper.set();
        var tickText = paper.set();
        var hLines = paper.set();
        var dimenX = conf.dimensionX;
        var dimenY = conf.dimensionY;
        var leftPos = x[dimenX].range()[0],
            rightPos = x[dimenX].range()[1],
            upPos = y[dimenY].range()[1],
            downPos = y[dimenY].range()[0];
        var linePos,
            lineGap;
        //X轴
        ticks = x[dimenX].ticks;
        for (j = 1; j &lt; ticks.length; j++) {
            tickText.push(paper.text(x[dimenX](ticks[j]), downPos+10, conf.xAxisData[ticks[j]-1]).attr({
                &quot;fill&quot;: &quot;#878791&quot;,
                &quot;fill-opacity&quot;: 0.7,
                &quot;font-family&quot;: &quot;雅黑&quot;,
                &quot;font-size&quot;: 12
            }).attr({
                &quot;text-anchor&quot;: &quot;middle&quot;
            }).rotate(0, x[dimenX](ticks[j]), upPos));
            axisLines.push(paper.path(&quot;M&quot; + x[dimenX](ticks[j]) + &quot;,&quot; + downPos + &quot;L&quot; + x[dimenX](ticks[j]) + &quot;,&quot; + (downPos+5)).attr({
                &quot;stroke&quot;: &quot;#D7D7D7&quot;,
                &quot;stroke-width&quot;: 2
            }));
        }
        axisLines.push(paper.path(&quot;M&quot; + leftPos + &quot;,&quot; + upPos + &quot;L&quot; + leftPos + &quot;,&quot; + downPos).attr({
            &quot;stroke&quot;: &quot;#D7D7D7&quot;,
            &quot;stroke-width&quot;: 2
        }));
        //Y轴
        ticks = y[dimenY].ticks;
        for (j = 0; j &lt; ticks.length; j++) {
            tickText.push(paper.text(leftPos - 10, y[dimenY](ticks[j]), ticks[j]).attr({
                &quot;fill&quot;: &quot;#878791&quot;,
                &quot;fill-opacity&quot;: 0.7,
                &quot;font-family&quot;: &quot;雅黑&quot;,
                &quot;font-size&quot;: 12
            }).attr({
                &quot;text-anchor&quot;: &quot;end&quot;
            }).rotate(0, rightPos + 6, y[dimenY](ticks[j])));
            axisLines.push(paper.path(&quot;M&quot; + leftPos + &quot;,&quot; + y[dimenY](ticks[j]) + &quot;L&quot; + (leftPos - 5) + &quot;,&quot; + y[dimenY](ticks[j])).attr({
                &quot;stroke&quot;: &quot;#D7D7D7&quot;,
                &quot;stroke-width&quot;: 2
            }));
        }
        axisLines.push(paper.path(&quot;M&quot; + leftPos + &quot;,&quot; + downPos + &quot;L&quot; + rightPos + &quot;,&quot; + downPos).attr({
            &quot;stroke&quot;: &quot;#D7D7D7&quot;,
            &quot;stroke-width&quot;: 2
        }));
        var numOfHLine = d3.round((downPos - upPos)/30-1);
        for (j = 1; j &lt;= numOfHLine; j++) {
            hLinesPos = downPos - j * 30;
            hLines.push(paper.path(&quot;M&quot; + leftPos + &quot;,&quot; + hLinesPos + &quot;L&quot; + rightPos + &quot;,&quot; + hLinesPos).attr({
                &quot;stroke&quot;: &quot;#ECECEC&quot;,
                &quot;stroke-width&quot;:1
            }));
        }
        //定义变量
        //bars
        var barWidth = 8;
        this.defaults.bars = paper.set();
        var bars = paper.set();
        //legend
        var legendArea = this.defaults.legendArea;
        var rectBn = paper.set();
        var underBn = [];
        var temp;
        //绘制
        //bars
        var mouseOverBar = function (event) {
            var bars = this.data.container;
            var seq = this.data.seqNum - this.data.seqNum % 2;
            var rectBn = this.data.rectBn;
            var clicked = false;
            var typeSeq = -1;
            var typeNum = this.data.typeNum;
            var xPos, yPos;
            var temp;
            var paper = bars[0].paper;
            for(i = 0, j = rectBn.length; i &lt; j; i++)
                if(rectBn[i].data.isClicked) {
                    clicked = true;
                    typeSeq = i;
                }
            //hover
            if(clicked) {
                if(typeSeq != this.data.seqNum % typeNum)
                    return;
                for(i = this.data.seqNum % typeNum, j = bars.length; i &lt; j; i+=typeNum) {
                    bars[i].attr({
                        &quot;fill-opacity&quot;:0.3
                    });
                }
                bars[this.data.seqNum].attr({
                    &quot;fill-opacity&quot;:1
                });
            } else {
                for(i = 0, j = bars.length; i &lt; j; i++) {
                    if(i == seq) {
                        i++;
                    }
                    else {
                        
                            bars[i].attr({
                                &quot;fill-opacity&quot;:0.3
                            });
                    }
                }
            }
            //pins
            xPos = bars[seq].attrs.x + 4 * typeNum;
            yPos = bars[seq].attrs.y + bars[seq].attrs.height;
            //axis x text
            temp = paper.text(xPos, yPos, this.data.xAxisLabel).attr({
                &quot;file&quot;: &quot;#ffffff&quot;,
                &quot;fill-opacity&quot;: 0.7,
                &quot;font-family&quot;: &quot;雅黑&quot;,
                &quot;font-size&quot;: 12,
                &quot;text-anchor&quot;: &quot;middle&quot;
            });
            var textWidth = temp.node.clientWidth + 8;
            temp.remove();
            //axis x rect
            temp = paper.rect(xPos - textWidth/2, yPos, textWidth, 20, 2).attr({
                &quot;fill&quot;: &quot;#5f5f5f&quot;,
                &quot;fill-opacity&quot;: 1,
                &quot;stroke&quot;: &quot;none&quot;
            });;
            bars.push(temp);
            temp = paper.text(xPos, yPos + 10, this.data.xAxisLabel).attr({
                &quot;file&quot;: &quot;#abcdef&quot;,
                &quot;fill-opacity&quot;: 0.7,
                &quot;font-family&quot;: &quot;雅黑&quot;,
                &quot;font-size&quot;: 12,
                &quot;text-anchor&quot;: &quot;middle&quot;
            });
            bars.push(temp);
        };
        
        var mouseOutBar = function (event) {
            var bars = this.data.container;
            var seq = this.data.seqNum - this.data.seqNum % 2;
            var rectBn = this.data.rectBn;
            var clicked = false;
            var typeSeq = -1;
            var typeNum = this.data.typeNum;
            var temp;
            for(i = 0, j = rectBn.length; i &lt; j; i++)
                if(rectBn[i].data.isClicked) {
                    clicked = true;
                    typeSeq = i;
                }
            //hover
            if(clicked) {
                if(typeSeq != this.data.seqNum % typeNum)
                    return;
                for(i = this.data.seqNum % typeNum, j = bars.length; i &lt; j; i+=typeNum) {
                    bars[i].attr({
                        &quot;fill-opacity&quot;:1
                    });
                }
            } else {
                for(i = 0, j = bars.length; i &lt; j; i++) {
                    if(i == seq) {
                        i++;
                    }
                    else {
                        bars[i].attr({
                            &quot;fill-opacity&quot;:1
                        });
                    }
                }
            }
            //pins
            temp = bars.pop();
            temp.remove();
            temp = bars.pop();
            temp.remove();
        };
        
        for (i = 0, j = this.source.length; i &lt; j; i++) {
            for (k = 0, l = conf.typeNames.length; k &lt; l; k++)
                if(i%l == k) {
                    temp = paper.rect((x[dimenX](this.source[i][dimenX])-barWidth * (l / 2 - i % l)), y[dimenY](this.source[i][dimenY]), 
                        barWidth, downPos - y[dimenY](this.source[i][dimenY])).attr({
                            &quot;fill&quot;: conf.barColor[k],
                            &quot;fill-opacity&quot;: 1,
                            &quot;stroke&quot;: &quot;none&quot;
                            });
                    temp.data = {};
                    temp.data.container = bars;
                    temp.data.seqNum = i;
                    temp.data.rectBn = rectBn;
                    temp.data.typeNum = conf.typeNames.length;
                    temp.data.xAxisLabel = conf.xAxisData[d3.round((i-1)/l)];
                    temp.data.yAxisLabel = this.source[i][dimenY];
                    temp.mouseover(mouseOverBar);
                    temp.mouseout(mouseOutBar);
                    bars.push(temp);
                }
        }
        //legend
        var mouseOverLegend = function (event) {
            var bars = this.data.container;
            var seq = this.data.seqNum;
            var rectBn = this.data.rectBn;
            for(i = 0, j = rectBn.length; i &lt; j; i++)
                if(rectBn[i].data.isClicked)
                    return;
            //
            for(i = (seq + 1)%2, j = bars.length; i &lt; j; i+=2) {
                bars[i].attr({
                    &quot;fill-opacity&quot;:0.3
                });
            }
            this.data.underBn[seq].attr({
                &quot;fill-opacity&quot;:0.5
            });
        };
        var mouseOutLegend = function (event) {
            var bars = this.data.container;
            var seq = this.data.seqNum;
            var rectBn = this.data.rectBn;
            for(i = 0, j = rectBn.length; i &lt; j; i++)
                if(rectBn[i].data.isClicked)
                    return;
            //
            for(i = (seq + 1)%2, j = bars.length; i &lt; j; i+=2) {
                bars[i].attr({
                    &quot;fill-opacity&quot;:1
                });
            }
            this.data.underBn[seq].attr({
                &quot;fill-opacity&quot;:0
            });
        };
        var clickLegend = function (event) {
            var bars = this.data.container;
            var seq = this.data.seqNum;
            var clicked = false;
            var underBn = this.data.underBn;
            var rectBn = this.data.rectBn;
            var lastClickedSeq;
            var typeNum = this.data.typeNum;
            //check if any legend has been already clicked
            for(i = 0, j = rectBn.length; i &lt; j; i++) {
                if(rectBn[i].data.isClicked) {
                    clicked = true;
                    lastClickedSeq = i;
                    break;
                }
            }
            if(this.data.isClicked) {
                for(i = 0; i &lt; typeNum; i++) {
                    if(i != seq % typeNum) {
                        for(var j = i, m = bars.length; j &lt; m; j+=typeNum)
                            bars[j].attr({
                                &quot;fill-opacity&quot;:0.3
                            });
                    }
                }
                this.data.isClicked = false;
            } else if(!clicked) {
                for(i = 0; i &lt; typeNum; i++) {
                    if(i != seq % typeNum) {
                        for(j = i, m = bars.length; j &lt; m; j+=typeNum)
                            bars[j].attr({
                                &quot;fill-opacity&quot;:0.1
                            });
                    }
                }
                this.data.isClicked = true;
            } else {
                //cancle the clicked button
                underBn[lastClickedSeq].attr({
                    &quot;fill-opacity&quot;:0
                });
                for(i = lastClickedSeq % typeNum, j = bars.length; i &lt; j; i+=typeNum)
                    bars[i].attr({
                        &quot;fill-opacity&quot;:0.1
                    });
                for(i = seq % typeNum, j = bars.length; i &lt; j; i+=typeNum)
                    bars[i].attr({
                        &quot;fill-opacity&quot;:1
                    });
                this.data.rectBn[lastClickedSeq].data.isClicked = false;
                this.data.isClicked = true;
            }
            this.data.underBn[seq].attr({
                &quot;fill-opacity&quot;:(this.data.isClicked?1:0)
            });
        };
        for (i = 0; i &lt; conf.typeNames.length; i++) {
            //底框
            underBn.push(paper.rect(legendArea[0] + 10, legendArea[1] + 10 + (20 + 3) * i, 180, 20).attr({
                &quot;fill&quot;: &quot;#ebebeb&quot;,
                &quot;fill-opacity&quot;:0,
                &quot;stroke&quot;: &quot;none&quot;
            }));
            //色框
            temp = paper.rect(legendArea[0] + 10 + 3, legendArea[1] + 10 + (20 + 3) * i + 6, 16, 8).attr({
                &quot;fill&quot;: conf.barColor[i],
                &quot;stroke&quot;: &quot;none&quot;
            });
            //文字
            paper.text(legendArea[0] + 10 + 3 + 16 + 8, legendArea[1] + 10 + (20 + 3) * i + 10, conf.typeNames[i]).attr({
                &quot;fill&quot;: &quot;black&quot;,
                &quot;fill-opacity&quot;: 1,
                &quot;font-family&quot;: &quot;Verdana&quot;,
                &quot;font-size&quot;: 12
            }).attr({
                &quot;text-anchor&quot;: &quot;start&quot;
            });
            //选框
            temp = paper.rect(legendArea[0] + 10, legendArea[1] + 10 + (20 + 3) * i, 180, 20).attr({
                &quot;fill&quot;: &quot;white&quot;,
                &quot;fill-opacity&quot;: 0,
                &quot;stroke&quot;: &quot;none&quot;
                //&quot;r&quot;: 3
            }).data(&quot;type&quot;, i);
            temp.mouseover(mouseOverLegend);
            temp.mouseout(mouseOutLegend);
            temp.click(clickLegend);
            temp.data = {};
            temp.data.seqNum = i;
            temp.data.container = bars;
            temp.data.rectBn = rectBn;
            temp.data.isClicked = false;
            temp.data.underBn = underBn;
            temp.data.typeNum = conf.typeNames.length;
            rectBn.push(temp);
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_render">
    render
  </h3>
  

  <p>绘制柱状图</p>

<h2>Options</h2>

<ul>
<li><code>width</code> 宽度，默认为节点宽度</li>
<li><code>typeNames</code> 指定y轴上数据类目</li>
</ul>

<h2>Examples</h2>

<div class="highlight"><pre lang="">histogram.render({"width": 1024})
</pre></div>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Histogram.prototype.render()</td> 
      <td></td>
      <td>render</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>options(Object)</td>
      <td colspan="2">options json object for determin histogram style.</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Histogram.prototype.render = function (options) {
        this.setOptions(options);
        this.canvas.clear();
        this.setAxis();
        this.drawDiagram();
	};
	return Histogram;
});</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/line" class="api">
  <h2>charts/line: API索引</h2>
  <ul class="indexs">
  
    <li>
      <a href="#_Line">Line</a>
    </li>

    <li>
      <a href="#_createCanvas">createCanvas</a>
    </li>

    <li>
      <a href="#_setSource">setSource</a>
    </li>

    <li>
      <a href="#_getColor">getColor</a>
    </li>

    <li>
      <a href="#_setXaxis">setXaxis</a>
    </li>

    <li>
      <a href="#_setYaxis">setYaxis</a>
    </li>

    <li>
      <a href="#_setBackground">setBackground</a>
    </li>

    <li>
      <a href="#_render">render</a>
    </li>

    <li>
      <a href="#_interactive">interactive</a>
    </li>

  </ul>
  <hr />

  
  <h3 id="_Line">
    Line
  </h3>
  

  <p>Line构造函数<br />Create line in a dom node with id "chart", width is 500px; height is 600px;</p>

<h2>Examples</h2>

<div class="highlight"><pre lang="">var line = new Line("chart", {"width": 500, "height": 600});
</pre></div>

  <table class="table">
  
    <tr>
      <td>声明</td>
      <td>Line</td> 
      <td></td>
      <td>Line</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>node(Mix)</td>
      <td colspan="2">The dom node or dom node Id</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>options(Object)</td>
      <td colspan="2">options json object for determin line style.</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>var Line = DataV.extend(DataV.Chart, {
    initialize: function (node, options) {
      this.type = &quot;Line&quot;;
      this.node = this.checkContainer(node);

      this.defaults = {};

      this.defaults.width = 960;
      this.defaults.height = 500;

      //Properties
      this.defaults.hasDataTitle = true;
      this.defaults.margin = [10, 40, 40, 40];
      this.defaults.title = null;
      this.defaults.subtitle = null;
      this.defaults.tagDepDomain = [];

      this.defaults.clickMode = true;
      this.defaults.hoverMode = true;

      //绘制属性
      this.defaults.lineSize = 2;
      this.defaults.nodeMode = true;
      this.defaults.nodeRadius = 2;
      this.defaults.hasMackLine = true;
      this.defaults.hasXAxis = true;
      this.defaults.hasYAxis = true;
      this.defaults.XAxisTick = 10;
      this.defaults.YAxisTick = 4;
      this.defaults.XAxisOrient = &quot;bottom&quot;;
      this.defaults.YAxisOrient = &quot;left&quot;;
      this.defaults.XAxisPadding = 10;
      this.defaults.YAxisPadding = 10;
      this.defaults.XAxisDomain = [];
      this.defaults.YAxisDomain = [];
      this.defaults.XAxisFontSize = 10;
      this.defaults.YAxisFontSize = 10;
      this.defaults.YAxisStartDy = 20;
      this.defaults.hasXGrid = true;
      this.defaults.hasYGrid = true;

      //Color
      this.defaults.titleColor = &quot;#000&quot;;
      this.defaults.subtitleColor = &quot;#000&quot;;
      this.defaults.AxisColor = &quot;#000&quot;;
      this.defaults.gridColor = &quot;#efefef&quot;;

      //设置用户指定属性
      this.setOptions(options);

      //创建画布
      this.createCanvas();
    }
  });</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_createCanvas">
    createCanvas
  </h3>
  

  <p>创建画布</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Line.prototype.createCanvas()</td> 
      <td></td>
      <td>createCanvas</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Line.prototype.createCanvas = function () {
    var conf = this.defaults;

    this.canvas = new Raphael(this.node, conf.width, conf.height);

    this.canvasF = this.node;

    var canvasStyle = this.canvasF.style;
    canvasStyle.position = &quot;relative&quot;;
    this.floatTag = DataV.FloatTag()(this.canvasF);
    this.floatTag.css({
      &quot;visibility&quot;: &quot;hidden&quot;
    });
  };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setSource">
    setSource
  </h3>
  

  <p>对原始数据进行处理</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Line.prototype.setSource()</td> 
      <td></td>
      <td>setSource</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Line.prototype.setSource = function (source) {
    var conf = this.defaults;
    var tagDepDomain = conf.tagDepDomain;
    var dataTable;
    var titles = [];
    var linesData = [];

    if (conf.hasDataTitle) {
      titles = source[0];
      dataTable = source.slice(1);
    } else {
      dataTable = source;
    }

    var j, l;
    var max, min;
    var maxList = [], minList = [];
    var maxLength = 0;
    dataTable.forEach(function (d, i) {
      // initialize the nodes of line
      maxLength = Math.max(maxLength, d.length);
      var line = {name: d[0], id: i, data: [], tags: []};
      for (j = 1, l = d.length; j &lt; l; j++) {
        var nodeData = d[j];
        line.data.push(nodeData);
        if (j === 1) {
          maxList[i] = nodeData;
          minList[i] = nodeData;
        } else {
          maxList[i] = Math.max(maxList[i], nodeData);
          minList[i] = Math.min(minList[i], nodeData);
        }
      }

      // initialize tag content
      l = tagDepDomain.length;
      if (l) {
        var tag = [];
        for (j = 0; j &lt; l; j++){
          var num  = tagDepDomain[j];
          tag = {name: null, data: d[num]};
          var name = titles[num];
          if (name){
            tag.name = name;
          }
          tags.push(tag);
        }
      }

      linesData.push(line);

      if (i === 0) {
        max = maxList[0];
        min = minList[0];
      } else {
        max = Math.max(maxList[i], max);
        min = Math.min(minList[i], min);
      }
    });

    var margin = conf.margin;
    this.xWidth = conf.width - margin[1] - margin[3];
    this.yHeight = conf.height - margin[0] - margin[2];

    this.titles = titles;
    this.maxLength = maxLength - 1;
    this.linesData = linesData;
    this.max = max;
    this.min = min;
    this.maxList = maxList;
    this.minList = minList;

    this.chosen = false;
    this.chosenNum = -1;
  };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_getColor">
    getColor
  </h3>
  

  <p>获取颜色函数</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Line.prototype.getColor()</td> 
      <td></td>
      <td>getColor</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>function</td>
      <td colspan="2">DataV根据主题获取随机离散色函数</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Line.prototype.getColor = function () {
    var colorFunction = DataV.getDiscreteColor();
    return colorFunction;
  };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setXaxis">
    setXaxis
  </h3>
  

  <p>绘制X轴</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Line.prototype.setXaxis()</td> 
      <td></td>
      <td>setXaxis</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Line.prototype.setXaxis = function (titles) {
    var conf = this.defaults;
    var canvas = this.canvas;

    if (conf.hasXAxis) {
      var axisColor = conf.AxisColor;
      var gridColor = conf.gridColor;
      var hasDataTitle = conf.hasDataTitle;
      var XAxisPadding = conf.XAxisPadding;
      var margin = conf.margin;
      var startX = margin[3];
      var startY = conf.height - margin[2];
      var xWidth = this.xWidth;
      var maxLength = this.maxLength;
      var yHeight = this.yHeight;
      var fontSize = conf.XAxisFontSize;

      var tickLength;
      if (conf.hasXGrid) {
        tickLength = yHeight;
      } else {
        tickLength = 5;
      }

      var tick = conf.XAxisTick;
      var tickStep;
      if (tick % maxLength === 0) {
        tickStep = xWidth / tick;
      } else {
        tickStep = xWidth / this.maxLength;
        tick = this.maxLength;
      }

      var xAxis = canvas.set();
      var xAxisText = canvas.set();
      xAxis.push(canvas.path(&quot;M&quot; + startX + &quot;,&quot; + startY + &quot;L&quot; + (startX + xWidth) + &quot;,&quot; + startY));

      var l = titles.length;
      for (var i = 0; i &lt; tick; i++) {
        xAxis.push(canvas.path(&quot;M&quot; + (startX + i * tickStep) + &quot;,&quot; + startY + &quot;L&quot; + (startX + i * tickStep) + &quot;,&quot; + (startY - tickLength))
          .attr({&quot;stroke&quot;: gridColor}));
        if (hasDataTitle &amp;&amp; i &lt; l - 1) {
          xAxisText.push(canvas.text((startX + i * tickStep), startY + XAxisPadding, titles[i + 1]));
        }
      }

      xAxis.attr({fill: axisColor, &quot;stroke-width&quot;:2});
      xAxisText.attr({&quot;font-size&quot;: fontSize});
      this.xAxis = xAxis;
      this.xAxisText = xAxisText;
      this.xTick = xWidth / maxLength;
    }
  };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setYaxis">
    setYaxis
  </h3>
  

  <p>绘制Y轴</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Line.prototype.setYaxis()</td> 
      <td></td>
      <td>setYaxis</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Line.prototype.setYaxis = function () {
    var conf = this.defaults;
    var canvas = this.canvas;

    if (conf.hasYAxis) {
      var axisColor = conf.AxisColor;
      var gridColor = conf.gridColor;
      var margin = conf.margin;
      var YAxisStartDy = conf.YAxisStartDy;
      var yHeight = this.yHeight - YAxisStartDy;
      var xWidth = this.xWidth;
      var startX = margin[3];
      var startY = margin[0] + yHeight;
      var YAxisPadding = conf.YAxisPadding;
      var max = this.max;
      var min = this.min;
      var fontSize = conf.YAxisFontSize;

      var tick = conf.YAxisTick;
      var tickStep = yHeight / tick;

      var d = (max - min) % (tick - 1);
      if (d !== 0) {
        max = max + (tick - 1) - d;
      }
      d = (max - min) / (tick - 1);

      var tickLength;
      if (conf.hasYGrid) {
        tickLength = xWidth;
      } else {
        tickLength = 5;
      }

      var yAxis = canvas.set();
      var yAxisText = canvas.set();
      var dx = 
      yAxis.push(canvas.path(&quot;M&quot; + startX + &quot;,&quot; + (startY + YAxisStartDy) + &quot;L&quot; + startX + &quot;,&quot; + (startY - yHeight)));

      for (var i = 0; i &lt; tick; i++) {
        yAxis.push(canvas.path(&quot;M&quot; + startX+ &quot;,&quot; + (startY - i * tickStep) + &quot;L&quot; + (startX + tickLength) + &quot;,&quot; + (startY - i * tickStep))
          .attr({&quot;stroke&quot;: gridColor}));
        yAxisText.push(canvas.text(startX - YAxisPadding, (startY - i * tickStep), (min + i * d)));
      }

      yAxis.attr({fill: axisColor, &quot;stroke-width&quot;:2});
      yAxisText.attr({&quot;font-size&quot;: fontSize});
      this.yAxis = yAxis;
      this.yAxisText = yAxisText;
      this.yHeight = yHeight;

      this.yMatchNum = tickStep / d;
      this.y0 = startY;
    }
  };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setBackground">
    setBackground
  </h3>
  

  <p>绘制背景</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Line.prototype.setBackground()</td> 
      <td></td>
      <td>setBackground</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Line.prototype.setBackground = function () {
    var conf = this.defaults;
    var canvas = this.canvas;
    var xWidth = this.xWidth;
    var yHeight = this.yHeight;
    var x0 = conf.margin[3];
    var y0 = this.y0;

    var rect = canvas.rect(x0, (y0 - yHeight), xWidth, yHeight).attr({&quot;fill&quot;: &quot;#fff&quot;,&quot;fill-opacity&quot;: 0, &quot;stroke&quot;: &quot;none&quot;});
    this.background = rect;
  };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_render">
    render
  </h3>
  

  <p>渲染折线图</p>

<h2>Examples</h2>

<div class="highlight"><pre lang="">var line = new Line("chart");
line.setSource(source);
line.render();
</pre></div>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Line.prototype.render()</td> 
      <td></td>
      <td>render</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>options(object)</td>
      <td colspan="2">options json object for determin line style.</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Line.prototype.render = function (options) {
    this.canvas.clear();
    this.createCanvas();
    var conf = this.defaults;
    var linesData = this.linesData;
    var nodesList = [];

    this.setXaxis(this.titles);
    this.setYaxis();

    this.setBackground();

    var canvas = this.canvas;
    var nodeMode = conf.nodeMode;
    var getColor = this.getColor();
    var lineSize = conf.lineSize;
    var max = this.max;
    var min = this.min;
    var xTick = this.xTick;
    var yMatchNum = this.yMatchNum;
    var yHeight = this.yHeight;
    var x0 = conf.margin[3];
    var y0 = this.y0;
    var YAxisStartDy = conf.YAxisStartDy;
    var radius = conf.nodeRadius;

    var j, l;
    var lines = canvas.set();
    linesData.forEach(function (d, i) {
      var nodeData = d.data;
      var nodes = canvas.set();
      var color = getColor(i);
      var linePath = &quot;M&quot;;

      for (j = 0, l = nodeData.length; j &lt; l; j++) {
        var x = x0 + xTick * (j);
        var y = y0 - ((nodeData[j] - min) * yMatchNum);

        linePath = linePath + x + &quot;,&quot; + y;
        
        if (j &lt; l - 1) {
          linePath = linePath + &quot;L&quot;;
        }

        if (nodeMode) {
          var thisNode = canvas.circle(x, y, radius * 2).attr({fill: color, &quot;stroke&quot;: &quot;none&quot;});
          thisNode.data('num', j);
          thisNode.data('lineNum', i);
          thisNode.data('data', nodeData[j]);
          nodes.push(thisNode);
        }
      }

      lines.push(canvas.path(linePath).attr({&quot;stroke&quot;: color, &quot;stroke-width&quot;: lineSize}).data('num', i));
      if (nodeMode) {
        nodesList.push(nodes.toFront());
      }
    });

    this.lines = lines;
    this.nodesList = nodesList;

    this.interactive();
  };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_interactive">
    interactive
  </h3>
  

  <p>添加交互选项</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Line.prototype.interactive()</td> 
      <td></td>
      <td>interactive</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Line.prototype.interactive = function () {
    var that = this;
    var conf = this.defaults;
    var hoverMode = conf.hoverMode;
    var clickMode = conf.clickMode;
    var nodeMode = conf.nodeMode;
    var chosen = this.chosen;
    var chosenNum = this.chosenNum;
    var lines = this.lines;
    var nodesList = this.nodesList;
    var xAxisText = this.xAxisText;
    var XAxisFontSize = conf.XAxisFontSize;

    var highLight = function (num) {
      var line = lines[num];
      lines.attr({&quot;stroke-opacity&quot;: 0.2});

      nodesList.forEach(function (d) {
        d.attr({&quot;fill-opacity&quot;: 0.2});
      });

      line.attr({&quot;stroke-opacity&quot;: 1}).toFront();
      nodesList[num].attr({&quot;fill-opacity&quot;: 1}).toFront();
    };

    var unhighLinght = function () {
      lines.forEach(function (d) {
        d.attr({&quot;stroke-opacity&quot;: 1});
      });
      nodesList.forEach(function (d) {
        d.attr({&quot;fill-opacity&quot;: 1});
      });
    };

    var background = this.background;

    if (clickMode){
      background.click(function () {
        if (chosen) {
          unhighLinght();
          chosen = false;
          that.chosen = chosen;
        }
      });
    }

    var floatTag = this.floatTag;
    $(this.node).append(this.floatTag);
    // if (hoverMode) {
    //  background.mouseover(function () {
        
  //    }).mouseout(function () {
  //      floatTag.css({&quot;visibility&quot; : &quot;hidden&quot;});
  //    });
    // }

    lines.forEach(function (d) {
      if (hoverMode) {
        d.mouseover(function () {
          if (!chosen) {
            highLight(d.data('num'));
          }
        }).mouseout(function () {
          if (!chosen) {
            unhighLinght();
          }
        });
      }

      if (clickMode){
        d.click(function () {
          chosenNum = d.data('num');
          highLight(chosenNum);

          chosen = true;
          that.chosen = chosen;
        });
      }
    });

    if (nodeMode){
      var radius = conf.nodeRadius;

      nodesList.forEach(function (d) {
        d.forEach (function (d) {
          if (hoverMode) {
            d.mouseover(function () {
              d.animate({r: (radius + 2) * 2}, 100);
              xAxisText[d.data('num')].animate({'font-size': XAxisFontSize * 2}, 100);
              floatTag.html('&lt;div style=&quot;text-align: center;margin:auto;color:#ffffff&quot;&gt;' + d.data('data') + '&lt;/div&gt;');
                floatTag.css({&quot;visibility&quot;: &quot;visible&quot;});
              if (!chosen) {
                highLight(d.data(&quot;lineNum&quot;));
              }
            }).mouseout(function () {
              d.animate({r: radius * 2}, 100);
              xAxisText[d.data('num')].animate({'font-size': XAxisFontSize}, 100);
              floatTag.css({&quot;visibility&quot;: &quot;hidden&quot;});
              if (!chosen) {
                unhighLinght();             
              }
            });
          }

          if (clickMode){
            d.click(function () {
              chosenNum = d.data('lineNum');
              highLight(chosenNum);

              chosen = true;
              that.chosen = chosen;
            });
          }
        });
      });
    }
  };

  return Line;
});</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/matrix" class="api">
  <h2>charts/matrix: API索引</h2>
  <ul class="indexs">
  
    <li>
      <a href="#_Matrix">Matrix</a>
    </li>

  </ul>
  <hr />

  

  <table class="table">
  

  
  </table>
  
  
  <h3 id="_Matrix">
    Matrix
  </h3>
  

  <p>构造函数</p>

  <table class="table">
  
    <tr>
      <td>声明</td>
      <td>Matrix</td> 
      <td></td>
      <td>Matrix</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>var Matrix = DataV.extend(DataV.Chart, {
        initialize: function (node, options) {
            this.type = &quot;Matrix&quot;;
            this.node = this.checkContainer(node);

            // Properties
            this.font = {};

            // Canvas
            this.defaults.width = 1200;
            this.defaults.height = 1200;
            this.defaults.axisWidth = 40;

            this.setOptions(options);
            this.createCanvas();
            this.move = false;
        }
    });

    Matrix.prototype.getDataTable = function (table) {
        var title = table[0];
        table = table.slice(1);

        var titleLength = title.length;
        var tableWidth = table[0].length;
        var tableHeight = table.length;

        this.tableWidth = tableWidth;
        this.tableHeight = tableHeight;

        //for symmetric matrix
        if (tableWidth !== title.length || tableHeight !== title.length) {
            throw new Error(&quot;This matrix is not symmetric matrix!!!&quot;);
        } else {
            this.tableWidth = tableWidth;
            this.tableHeight = tableHeight;
        }

        this.title = title;
        return table;
    };

    Matrix.prototype.setSource = function (source) {
        var conf = this.defaults;

        this.source = this.getDataTable(source);
        this.hasSort = false;
        // this.source = this.remapSource(source);
    };

    Matrix.prototype.layout = function () {
        var conf = this.defaults;
        var width = conf.width;
        var height = conf.height;
        var tableWidth = this.tableWidth;
        var tableHeight = this.tableHeight;
        var axisWidth = conf.axisWidth;

        this.cellWidth = Math.min((width - axisWidth) / tableWidth, (height - axisWidth) / tableHeight);

        var startX;
        var startY;
        var bRectWidth;
        var matrixWidth;

        if (width &gt; height) {
            startX = (width - height)/2 + axisWidth;
            startY = axisWidth;
            bRectWidth = height - axisWidth;
            matrixWidth = bRectWidth - axisWidth;
        } else if (height &gt; width) {
            startX = axisWidth;
            startY = (height - width) + axisWidth;
            bRectWidth = width - axisWidth;
        } else {
            startX = axisWidth;
            startY = axisWidth;
            bRectWidth = width - axisWidth;
            matrixWidth = bRectWidth - axisWidth;
        }

        this.startX = startX;
        this.startY = startY;
        this.bRectWidth = bRectWidth;
        this.matrixWidth = matrixWidth;
    };

    Matrix.prototype.getColor = function (i) {
        var colorMatrix = DataV.getColor();
        var length = colorMatrix.length;
        var num = i % length;
        //var color = '#939598';
        var color = '#FFFFFF';

        if (num !== 0) {
            color = colorMatrix[num][0];
        }

        return color;
    };

    Matrix.prototype.createCanvas = function () {
        var conf = this.defaults;
        this.canvas = new Raphael(this.node, conf.width, conf.height);

        this.DOMNode = $(this.canvas.canvas);
        var that = this;
        this.DOMNode.click(function (event) {
            that.trigger(&quot;click&quot;, event);
            that.update();
        });
        this.DOMNode.dblclick(function (event) {
            that.trigger(&quot;dblclick&quot;, event);
        });

        var mousewheel = document.all ? &quot;mousewheel&quot; : &quot;DOMMouseScroll&quot;;
        this.DOMNode.bind(mousewheel, function (event) {
            that.trigger(&quot;mousewheel&quot;, event);
        });

        this.DOMNode.bind(&quot;contextmenu&quot;, function (event) {
            that.trigger(&quot;contextmenu&quot;, event);
        });

        this.DOMNode.delegate(&quot;circle&quot;, &quot;click&quot;, function (event) {
            that.trigger(&quot;circle_click&quot;, event);
        });

        this.DOMNode.delegate(&quot;circle&quot;, &quot;mouseover&quot;, function (event) {
            that.trigger(&quot;circle_mouseover&quot;, event);
        });

        this.DOMNode.delegate(&quot;circle&quot;, &quot;mouseout&quot;, function (event) {
            that.trigger(&quot;circle_mouseout&quot;, event);
        });
    };

    Matrix.prototype.generatePaths = function () {
        var canvas = this.canvas;
        var source = this.source;
        var conf = this.defaults;
        var width = conf.width;
        var height = conf.height;
        var startX = this.startX;
        var startY = this.startY;
        var cellWidth = this.cellWidth;
        var tableWidth = this.tableWidth;
        var tableHeight = this.tableHeight;
        var bRectWidth = this.bRectWidth;
        var matrixWidth = this.matrixWidth;

        //canvas.clear();
        // var color = this.getColor();
        // var font = this.getFont();
        var font_family = '微软雅黑';
        var font_size = 8;

        var title = this.title;

        var row = [];
        var columnLine = [];
        var columnText = [];

        var backgroundRect = canvas.rect(startX, startY, bRectWidth, bRectWidth);
        //backgroundRect.attr({fill: &quot;#939598&quot;, stroke: &quot;none&quot;, &quot;fill-opacity&quot;: 0.8});
        backgroundRect.attr({fill: &quot;#ffffff&quot;, stroke: &quot;none&quot;, &quot;fill-opacity&quot;: 0.8});
        backgroundRect.toBack();

        var sort;
        if (this.hasSort) {
            sort = this.sort;
        }
        var i, j, a, b, color, rect;
        var rects = [];  //for column change move rect
        for (i = 0; i &lt; tableHeight; i++) {
            if (!this.hasSort){
                a = i;
            } else {
                for (j = 0; j &lt; sort.length; j++) {
                    if (sort[j] === i) {
                        a = j;
                    }
                }
            }
            var rowRect = canvas.set();
            canvas.path(&quot;M&quot; + startX + &quot; &quot; + (startY + cellWidth * i) + &quot;L&quot; + (startX + matrixWidth + 10 + cellWidth) + &quot; &quot;
             + (startY + cellWidth * i)).attr({stroke: &quot;#D1D1D1&quot;, &quot;stroke-width&quot;: 1});
            rowRect.push(canvas.text(-20, cellWidth / 2, title[i])
                .attr({&quot;fill&quot;: &quot;#000000&quot;,
                    &quot;fill-opacity&quot;: 0.7,
                    &quot;font-family&quot;: &quot;Verdana&quot;,
                    //&quot;font-weight&quot;: &quot;bold&quot;,
                    &quot;font-size&quot;: 12}));

            for (j = 0; j &lt; tableWidth; j++) {
                if (!this.hasSort) {
                    color = this.getColor(source[i][j]);
                } else {
                    color = this.getColor(source[i][sort[j]]);
                }
                rect = canvas.rect(cellWidth * j, 0, cellWidth, cellWidth)
                    .attr({stroke: &quot;none&quot;, fill: color, &quot;fill-opacity&quot;: 0.8});
                rowRect.push(rect);
                rects.push(rect);
            }

            rowRect.transform(&quot;t&quot; + startX + &quot;, &quot; + (startY + cellWidth * a));
            row.push(rowRect);
        }

        canvas.path(&quot;M&quot; + startX + &quot; &quot; + (startY + cellWidth * tableHeight) + &quot;L&quot; + (startX + matrixWidth + 10 + cellWidth) + &quot; &quot;
             + (startY + cellWidth * tableHeight)).attr({stroke: &quot;#D1D1D1&quot;, &quot;stroke-width&quot;: 1});

        for (i = 0; i &lt; tableWidth; i++) {
            // var columnLine = canvas.set();
            // var columnText = canvas.set();
            if (!this.hasSort){
                a = i;
            } else {
                for (j = 0; j &lt; sort.length; j++) {
                    if (sort[j] === i) {
                        a = j;
                    }
                }
            }
            columnLine.push(canvas.path(&quot;M0 0L0 &quot; + matrixWidth + 10 + cellWidth)
                .attr({stroke: &quot;#D1D1D1&quot;, &quot;stroke-width&quot;: 1})
                .transform(&quot;t&quot; + (startX + cellWidth * a) + &quot;, &quot; + startY));
            columnText.push(canvas.text(cellWidth / 2, -20, title[i])
                .attr({&quot;fill&quot;: &quot;#000000&quot;,
                    &quot;fill-opacity&quot;: 0.7,
                    &quot;font-family&quot;: &quot;Verdana&quot;,
                    //&quot;font-weight&quot;: &quot;bold&quot;,
                    &quot;font-size&quot;: 12})
                .transform(&quot;t&quot; + (startX + cellWidth * a) + &quot;, &quot; + startY + &quot;r90&quot;));
        }

        columnLine.push(canvas.path(&quot;M0 0L0 &quot; + matrixWidth + 10 + cellWidth)
                .attr({stroke: &quot;#D1D1D1&quot;, &quot;stroke-width&quot;: 1})
                .transform(&quot;t&quot; + (startX + cellWidth * tableWidth) + &quot;, &quot; + startY));

        this.row = row;
        this.columnText = columnText;
        this.columnLine = columnLine;
        this.rects = rects;
    };

    Matrix.prototype.getSort = function (source) {
        var sumQueue = [];
        var sort = [];
        var rowData;
        var rowLength;
        var sum;
        var means;
        var matrixD = [];
        var quareSum;
        var rowquareSum = [];

        var i, j, k;
        for (i = 0 ; i &lt; source.length ; i++) {
            rowData = source[i];
            rowLength = rowData.length;
            sum = 0;
            quareSum = 0;

            for (j = 0 ; j &lt; rowLength ; j++) {
                sum = sum + rowData[j];
            }

            means = sum / rowLength;
            for (j = 0 ; j &lt; rowLength ; j++) {
                rowData[j] = rowData[j] - means;
                quareSum = quareSum + Math.pow(rowData[j], 2);
            }

            quareSum = Math.sqrt(quareSum);

            rowquareSum.push(quareSum);
            matrixD.push(rowData);
        }

        var rowI;
        var rowJ;
        var matrixR = [];

        for (i = 0 ; i &lt; source.length ; i++) {
            matrixR[i] = [];
            for (j = 0 ; j &lt; source.length ; j++) {
                matrixR[i][j] = 0;
            }
        }

        for (i = 0 ; i &lt; source.length ; i++) {
            rowI = matrixD[i];
            matrixR[i][i] = source[i][i];
            for (j = i + 1 ; j &lt; source.length ; j++) {
                sum = 0;
                rowJ = matrixD[j];
                for (k = 0; k &lt; rowLength; k++) {
                    sum = sum + rowI[k] * rowJ[k];
                }

                sum = sum / (rowquareSum[i] * rowquareSum[j]);
                matrixR[i][j] = sum;
                matrixR[j][i] = sum;
            }
        }



        return matrixR;
    };
    
    Matrix.prototype.update = function () {
        var i, j;
        var source = [];
        for(i = 0; i &lt; this.source.length ; i++){
            source[i] = this.source[i].concat();
        }

        var sort = [];
        for (i = 0; i &lt; source[0].length; i++) {
            sort.push(i);
        }

        if (this.hasSort) {
            this.sort = sort;
            this.hasSort = false;
        } else {
            var getSort = this.getSort;
            var i, j;
            var pt;
            var nowSort = [];
            var iterations = 12;

            for (i = 0; i &lt; iterations; i++) {
                source = getSort(source);
            }

            nowSort = source[0];

            var a, b;
            for (i = 1; i &lt; sort.length; i++) {
                a = sort[i];
                for (j = i + 1; j &lt; sort.length; j++) {
                    b = sort[j];
                    if (nowSort[a] &lt; nowSort[b]) {
                        pt = sort[i];
                        sort[i] = sort[j];
                        sort[j] = pt;
                    }
                }
            }
            sort = [0,7,5,2,8,3,1,9,6,14,15,4,13,10,16,11,12];
            this.sort = sort;
            this.hasSort = true;
        }

        if (!this.move) {
            this.move = true;
            var rects = this.rects;
            var num;
            var startX = this.startX;
            var startY = this.startY;
            var cellWidth = this.cellWidth;

            var rowAnim;
            var columnLineAnim;
            var columnTextAnim;
            var anim;

            for (i = 0; i &lt; sort.length; i++) {
                num = sort[i];
                // if (num != i) {
                rowAnim = Raphael.animation({transform: [&quot;t&quot;, startX, (startY + cellWidth * i)]}, 200, &quot;&lt;&gt;&quot;);
                this.row[num].animate(rowAnim.delay(100 * i));
                // }
            }

            var that = this;
            var moveEnd = function () {
                that.move = false;
            };

            for (i = 0; i &lt; sort.length; i++) {
                num = sort[i];
                // if (num != i) {
                //columnLineAnim = Raphael.animation({transform: [&quot;t&quot;, (startX + cellWidth * i), startY]}, 1000, &quot;&lt;&gt;&quot;);
                columnTextAnim = Raphael.animation({transform: [&quot;t&quot;, (startX + cellWidth * i), startY, &quot;r&quot;, 90]},
                    200, &quot;&lt;&gt;&quot;);
                //this.columnLine[num].animate(columnLineAnim.delay(500 * (i + sort.length + 1)));
                this.columnText[num].animate(columnTextAnim.delay(100 * (i + sort.length + 1)));

                for (j = 0; j &lt; sort.length; j++) {
                    if (i === sort.length - 1 &amp;&amp; j === sort.length - 1) {
                        anim = Raphael.animation({'x': cellWidth * i}, 200, &quot;&lt;&gt;&quot;, moveEnd);
                    } else {
                        anim = Raphael.animation({'x': cellWidth * i}, 200, &quot;&lt;&gt;&quot;);
                    }
                    rects[j * sort.length + num].animate(anim.delay(100 * (i + sort.length + 1)));
                }
                // }
            }
        }
    };

    Matrix.prototype.render = function (options) {
        if (!this.move) {
            this.canvas.clear();
            this.setOptions(options);
            this.layout();
            this.generatePaths();
        }
    };

    return Matrix;
});</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/parallel" class="api">
  <h2>charts/parallel: API索引</h2>
  <ul class="indexs">
  
    <li>
      <a href="#_Parallel">Parallel</a>
    </li>

    <li>
      <a href="#_chooseDimensions">chooseDimensions</a>
    </li>

    <li>
      <a href="#_setDimensionType">setDimensionType</a>
    </li>

    <li>
      <a href="#_getDimensionExtents">getDimensionExtents</a>
    </li>

    <li>
      <a href="#_setDimensionExtent">setDimensionExtent</a>
    </li>

    <li>
      <a href="#_getDimensionTypes">getDimensionTypes</a>
    </li>

    <li>
      <a href="#_getDimensionDomains">getDimensionDomains</a>
    </li>

    <li>
      <a href="#_setDimensionDomain">setDimensionDomain</a>
    </li>

    <li>
      <a href="#_on">on</a>
    </li>

    <li>
      <a href="#_setSource">setSource</a>
    </li>

    <li>
      <a href="#_render">render</a>
    </li>

  </ul>
  <hr />

  

  <table class="table">
  

  
  </table>
  
  
  <h3 id="_Parallel">
    Parallel
  </h3>
  

  <p>构造函数</p>

<h2>Options</h2>

<ul>
<li><code>width</code> 数字，图片宽度，默认为750，表示图片高750px</li>
<li><code>height</code> 数字，图片高度，默认为500</li>
<li><code>marginWidth</code> 数组，表示图片上、右、下、左的边距，默认为 [20, 20, 20, 20]</li>
<li><code>backgroundAttr</code> 对象，没有选中的线的样式，默认为{"fill": "none", "stroke": "#ccc", "stroke-opacity": 0.4}， 具体设置方式请参考Raphael手册：<a href='http://raphaeljs.com/reference.html#Element.attr'>http://raphaeljs.com/reference.html#Element.attr</a></li>
<li><code>foregroundAttr</code> 对象，被选中的线的样式，默认为{"fill": "none", "stroke": "steelblue", "stroke-opacity": 0.7}， 具体设置方式请参考Raphael手册：<a href='http://raphaeljs.com/reference.html#Element.attr'>http://raphaeljs.com/reference.html#Element.attr</a></li>
<li><code>axisStyle</code> 对象，设置坐标轴属性。3中坐标轴属性：domainAttr表示坐标轴线属性。tickAttr表示坐标轴标尺属性。tickTextAttr表示坐标轴文字属性。具体设置方式请参考Raphael手册：<a href='http://raphaeljs.com/reference.html#Element.attr'>http://raphaeljs.com/reference.html#Element.attr</a></li>
<li><code>customEvent</code> 函数对象，其中有3个自定义函数。<code>brushstart</code> 函数，表示刚开始拖选区间的事件响应，默认为空函数; <code>brushend</code> 函数，表示拖选结束后的事件响应，默认为空函数; <code>brush</code> 函数，表示拖选时的事件响应，默认为空函数; 这些函数可以在创建对象或setOption()时一起设置，也可以通过on()函数单独设置。</li>
</ul>

  <table class="table">
  
    <tr>
      <td>声明</td>
      <td>Parallel</td> 
      <td></td>
      <td>Parallel</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>node(Node,String,jQuery)</td>
      <td colspan="2">容器节点，文档节点、ID或者通过jQuery查询出来的对象</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>var Parallel = DataV.extend(DataV.Chart, {
        initialize: function (node, options) {
            this.type = &quot;Parallel&quot;;
            this.node = this.checkContainer(node);

            // Properties
            this.allDimensions = [];
            this.dimensions = [];
            this.dimensionType = {};
            this.dimensionDomain = {};
            this.dimensionExtent = {};

            // Canvas
            this.defaults.width = 750;
            this.defaults.height = 500;
            this.defaults.marginWidth = [20, 20, 20, 20];
            this.defaults.backgroundAttr = {&quot;fill&quot;: &quot;none&quot;, &quot;stroke&quot;: &quot;#ccc&quot;, &quot;stroke-opacity&quot;: 0.4};
            this.defaults.foregroundAttr = {&quot;fill&quot;: &quot;none&quot;, &quot;stroke&quot;: &quot;steelblue&quot;, &quot;stroke-opacity&quot;: 0.7};

            this.defaults.axisStyle = {
                domainAttr : {&quot;stroke&quot;: &quot;#000&quot;},//坐标轴线
                tickAttr : {&quot;stroke&quot;: &quot;#000&quot;},//坐标轴标尺
                tickTextAttr : {}//坐标轴文字
            }

            this.defaults.customEvent = {
                &quot;brushstart&quot;: function () {},
                &quot;brushend&quot;: function () {},
                &quot;brush&quot;: function () {}
            };

            this.setOptions(options);
            this.createCanvas();
        }
    });</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_chooseDimensions">
    chooseDimensions
  </h3>
  

  <p>choose dimension</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Parallel.prototype.chooseDimensions()</td> 
      <td></td>
      <td>chooseDimensions</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>dimen(array)</td>
      <td colspan="2">Array of column names</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Parallel.prototype.chooseDimensions = function (dimen) {
        var conf = this.defaults;
        this.dimensions = [];
        for (var i = 0, l = dimen.length; i&lt;l; i++) {
            if ($.inArray(dimen[i], this.allDimensions) !== -1) {
                this.dimensions.push(dimen[i]);
            }
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setDimensionType">
    setDimensionType
  </h3>
  

  <p>set dimension type, ordinal or quantitative</p>

<h2>Examples</h2>

<div class="highlight"><pre lang=""> parallel.setDimensionType({"cylinders": "ordinal", "year": "quantitative"});
</pre></div>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Parallel.prototype.setDimensionType()</td> 
      <td></td>
      <td>setDimensionType</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>dimenType(Object)</td>
      <td colspan="2">dimension type obj</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Parallel.prototype.setDimensionType = function (dimenType) {
        var conf = this.defaults,
            prop,
            type;
        if (dimenType) {
            for (prop in dimenType) {
                if (dimenType.hasOwnProperty(prop) &amp;&amp; this.dimensionType[prop]) {
                    var type = dimenType[prop];
                    if (type !== &quot;quantitative&quot; &amp;&amp; type !== &quot;ordinal&quot;) {
                        throw new Error('Dimension type should be &quot;quantitative&quot; or &quot;ordinal&quot;.');
                    }
                    if (this.dimensionType[prop] !== type) {
                        this.dimensionType[prop] = type;
                        this._setDefaultDimensionDomain(prop);
                    }
                }
            }
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_getDimensionExtents">
    getDimensionExtents
  </h3>
  

  <p>get dimensions extents</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Parallel.prototype.getDimensionExtents()</td> 
      <td></td>
      <td>getDimensionExtents</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>Object</td>
      <td colspan="2">{key: dimension name(column name); value: dimenType(&quot;ordinal&quot; or &quot;quantitativ&quot;)}</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Parallel.prototype.getDimensionExtents = function () {
        return $.extend({}, this.dimensionExtent);
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setDimensionExtent">
    setDimensionExtent
  </h3>
  

  <p>set dimension extent, if chart has been rendered, then refresh the chart;</p>

<h2>Examples</h2>

<div class="highlight"><pre lang=""> parallel.setDimensionExtent({
   "cylinders": ["6", "3"],
   "economy (mpg)": [35, 20]
 });
</pre></div>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Parallel.prototype.setDimensionExtent()</td> 
      <td></td>
      <td>setDimensionExtent</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>dimenExtent(Object)</td>
      <td colspan="2">{key: dimension name(column name); value: extent array;}</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Parallel.prototype.setDimensionExtent = function (dimenExtent) {
        var conf = this.defaults;
        var dimen, i, l, extent;
        var rebrushNeeded = false;
        var ordinalExtent = [];

        if (arguments.length === 0) {
            // clean all extent
            this.dimensionExtent = {};
        } else {
            for (prop in dimenExtent) {
                if (dimenExtent.hasOwnProperty(prop) &amp;&amp; this.dimensionType[prop]) {
                    extent = dimenExtent[prop];
                    if (!(extent instanceof Array)) {
                        throw new Error(&quot;extent should be an array&quot;);
                    } else {
                        if (extent.length !== 2) {
                            throw new Error(&quot;extent should be an array with two items, for example: [num1, num2]&quot;);
                        } else if (this.dimensionType[prop] === &quot;quantitative&quot;) {
                            this.dimensionExtent[prop] = extent;
                            rebrushNeeded = true;
                            if (this.brush) {
                                this.y[prop].brush.extent(extent);
                                this.y[prop].brush.refresh();
                            }
                        } else if (this.dimensionType[prop] === &quot;ordinal&quot;) {
                            if (typeof this.dimensionDomain[prop].itemIndex[extent[0]] === 'undefined'
                                    || typeof this.dimensionDomain[prop].itemIndex[extent[1]] === 'undefined') {
                                throw new Error(prop + &quot; does not have value: &quot; + extent[0] + &quot; or &quot; + extent[1]); 
                            } else {
                                rebrushNeeded = true;
                                ordinalExtent = this._getOrdinalExtent(prop, extent);
                                this.dimensionExtent[prop] = extent;
                                if (this.brush) {
                                    this.y[prop].brush.extent(ordinalExtent);
                                    this.y[prop].brush.refresh();
                                }
                            }
                        }
                    }
                }
            }
            if (rebrushNeeded &amp;&amp; this.brush) {
                this.brush();
            }
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_getDimensionTypes">
    getDimensionTypes
  </h3>
  

  <p>get dimension types</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Parallel.prototype.getDimensionTypes()</td> 
      <td></td>
      <td>getDimensionTypes</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>Object</td>
      <td colspan="2">{key: dimension name(column name); value: dimenType(&quot;ordinal&quot; or &quot;quantitativ&quot;)}</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Parallel.prototype.getDimensionTypes = function () {
        return $.extend({}, this.dimensionType);
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_getDimensionDomains">
    getDimensionDomains
  </h3>
  

  <p>get dimension domain</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Parallel.prototype.getDimensionDomains()</td> 
      <td></td>
      <td>getDimensionDomains</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>Object</td>
      <td colspan="2">{key: dimension name(column name); value: extent array;}</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Parallel.prototype.getDimensionDomains = function () {
        return $.extend({}, this.dimensionDomain);
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setDimensionDomain">
    setDimensionDomain
  </h3>
  

  <p>set dimension domain</p>

<h2>Examples</h2>

<div class="highlight"><pre lang=""> parallel.setDimensionDomain({
   "cylinders": [4, 8], //quantitative
   "year": ["75", "79", "80"] //ordinal
 });
</pre></div>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Parallel.prototype.setDimensionDomain()</td> 
      <td></td>
      <td>setDimensionDomain</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>dimenDomain(Object)</td>
      <td colspan="2">{key: dimension name(column name); value: domain array (quantitative domain is digit array whose length is 2, ordinal domain is string array whose length could be larger than 2;}</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Parallel.prototype.setDimensionDomain = function (dimenDomain) {
        //set default dimensionDomain, extent for quantitative type, item array for ordinal type
        var conf = this.defaults;
        var dimen, i, l, domain;

        if (arguments.length === 0) {
            for (i = 0, l = this.allDimensions.length; i &lt; l; i++) {
                dimen = this.allDimensions[i];
                this._setDefaultDimensionDomain(dimen);
            }
        } else {
            for (prop in dimenDomain) {
                if (dimenDomain.hasOwnProperty(prop) &amp;&amp; this.dimensionType[prop]) {
                    domain = dimenDomain[prop];
                    if (!(domain instanceof Array)) {
                        throw new Error(&quot;domain should be an array&quot;);
                    } else {
                        if (this.dimensionType[prop] === &quot;quantitative&quot; &amp;&amp; domain.length !== 2) {
                            throw new Error(&quot;quantitative's domain should be an array with two items, for example: [num1, num2]&quot;);
                        }
                        if (this.dimensionType[prop] === &quot;quantitative&quot;) {
                            this.dimensionDomain[prop] = domain;
                        } else if (this.dimensionType[prop] === &quot;ordinal&quot;) {
                            this.dimensionDomain[prop] = this._setOrdinalDomain(domain);
                        }
                    }
                }
            }
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_on">
    on
  </h3>
  

  <p>侦听自定义事件</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Parallel.prototype.on()</td> 
      <td></td>
      <td>on</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Parallel.prototype.on = function (eventName, callback) {
        if ($.inArray(eventName, [&quot;brushstart&quot;, &quot;brushend&quot;, &quot;brush&quot;]) !== -1) {
            this.defaults.customEvent[eventName] = callback;
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setSource">
    setSource
  </h3>
  

  <p>设置数据源</p>

<h2>Examples</h2>

<p>第一行为列名</p>

<div class="highlight"><pre lang="">[
 ["name", "weight", "year"],
 ["AMC", "2000", "79"],
 ["Buick", "2100", "80"]
]
</pre></div>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Parallel.prototype.setSource()</td> 
      <td></td>
      <td>setSource</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>source(Array)</td>
      <td colspan="2">二维数组的数据源</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Parallel.prototype.setSource = function (source) {
        //source is 2-dimension array

        var conf = this.defaults;
        this.allDimensions = source[0];

        //by default all dimensions show
        this.dimensions = source[0];

        //this.source is array of line; key is dimension, value is line's value in that dimension
        this.source = [];
        for(var i=1, l=source.length; i&lt;l; i++){
            var line = {},
                dimen = this.allDimensions;
            for(var j=0, ll=dimen.length; j&lt;ll; j++){
                line[dimen[j]] = source[i][j];
            }
            this.source.push(line);
        }

        //judge dimesions type auto
        //if all number, quantitative else ordinal
        this.dimensionType = {};
        for (var i = 0, l = this.allDimensions.length; i &lt; l; i++) {
            var type = &quot;quantitative&quot;;
            for (var j=1, ll = source.length; j&lt;ll; j++) {
                var d = source[j][i];
                if(d &amp;&amp; (!DataV.isNumeric(d))){
                    type = &quot;ordinal&quot;;
                    break;
                }
            }
            this.dimensionType[this.allDimensions[i]] = type;
        }

        this.setDimensionDomain();

    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_render">
    render
  </h3>
  

  <p>绘制图表</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Parallel.prototype.render()</td> 
      <td></td>
      <td>render</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Parallel.prototype.render = function (options) {
        this.setOptions(options);
        this.layout();
        this.generatePaths();
    };</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/pie" class="api">
  <h2>charts/pie: API索引</h2>
  <ul class="indexs">
  
    <li>
      <a href="#_Pie">Pie</a>
    </li>

    <li>
      <a href="#Pie_dimension">dimension</a>
    </li>

    <li>
      <a href="#_createCanvas">createCanvas</a>
    </li>

    <li>
      <a href="#_getColor">getColor</a>
    </li>

    <li>
      <a href="#_render">render</a>
    </li>

    <li>
      <a href="#_legend">legend</a>
    </li>

    <li>
      <a href="#_setSource">setSource</a>
    </li>

    <li>
      <a href="#_layout">layout</a>
    </li>

  </ul>
  <hr />

  

  <table class="table">
  

  
  </table>
  
  
  <h3 id="_Pie">
    Pie
  </h3>
  

  <p>构造函数</p>

  <table class="table">
  
    <tr>
      <td>声明</td>
      <td>Pie</td> 
      <td></td>
      <td>Pie</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>node(Object)</td>
      <td colspan="2">表示在html的哪个容器中绘制该组件</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>options(Object)</td>
      <td colspan="2">为用户自定义的组件的属性，比如画布大小</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>var Pie = DataV.extend(DataV.Chart, {
        type: &quot;Pie&quot;,
        initialize: function (node, options) {
            this.node = this.checkContainer(node);
            this.sum = 0;
            this.groupNames = []; //数组：记录每个group的名字
            this.groupValue = [];
            this.groups = [];
            this.click = 0;

            //图的大小设置
            this.defaults.legend = true;
            this.defaults.width = 800;
            this.defaults.height = 800;

            //设置用户指定的属性
            this.setOptions(options);

            this.legendArea = [20, (this.defaults.height - 20 - 220), 200, 220];
            if (this.defaults.legend) {
                this.xOffset = this.legendArea[2];
            } else {
                this.xOffset = 0;
            }

            this.defaults.radius = Math.min((this.defaults.width - this.xOffset), this.defaults.height) * 0.3;
            this.defaults.protrude = this.defaults.radius * 0.1;
            //创建画布
            this.createCanvas();
        }
    });</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="Pie_dimension">
    dimension
  </h3>
  

  <p>饼图纬度描述</p>

  <table class="table">
  
    <tr>
      <td>属性</td>
      <td>Pie.dimension</td> 
      <td>Pie</td>
      <td>dimension</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Pie.dimension = {};</code></pre></td>
    </tr>
  
  </table>
  
  

  <p>标签纬度</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Pie.dimension.label = {
        type: &quot;string&quot;,
        required: false
    };</code></pre></td>
    </tr>
  
  </table>
  
  

  <p>值纬度</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Pie.dimension.value = {
        type: &quot;number&quot;,
        required: true
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_createCanvas">
    createCanvas
  </h3>
  

  <p>创建画布</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Pie.prototype.createCanvas()</td> 
      <td></td>
      <td>createCanvas</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Pie.prototype.createCanvas = function () {
        this.canvas = new Raphael(this.node, this.defaults.width, this.defaults.height);
        var canvasStyle = this.node.style;
        canvasStyle.position = &quot;relative&quot;;
        this.floatTag = DataV.FloatTag()(this.node);
        this.floatTag.css({
            &quot;visibility&quot;: &quot;hidden&quot;
        });
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_getColor">
    getColor
  </h3>
  

  <p>获取颜色</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Pie.prototype.getColor()</td> 
      <td></td>
      <td>getColor</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>i(Number)</td>
      <td colspan="2">元素类别编号</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>String</td>
      <td colspan="2">返回颜色值</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Pie.prototype.getColor = function (i) {
        var color = DataV.getColor();
        return color[i % color.length][0];
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_render">
    render
  </h3>
  

  <p>绘制饼图</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Pie.prototype.render()</td> 
      <td></td>
      <td>render</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Pie.prototype.render = function () {
        var conf = this.defaults;
        var floatTag = this.floatTag;
        var that = this;
        this.layout();
        var groups = this.groups;

        //由内外半径、起始角度计算路径字符串
        var pathCalc = d3.svg.arc()
        .innerRadius(conf.radius)
        .outerRadius(0)
        .startAngle(function (d) {
            return d.startAngle;
        }).endAngle(function (d) {
            return d.endAngle;
        });

        var donutEle;
        //获取每个环形的字符串表示
        var spline;
        var tips;
        that.donutGroups = that.canvas.set();

        $(this.node).append(this.floatTag);

        //添加透明效果

        var mouseOver = function () {
            floatTag.html('&lt;div style=&quot;text-align:center;margin:auto;color:#ffffff&quot;&gt;' + this.data('text') + '&lt;/div&gt;');
            floatTag.css({
                &quot;visibility&quot;: &quot;visible&quot;
            });
            var index = this.data(&quot;donutIndex&quot;);
            if (!this.data('click')) {
                that.underBn[index].attr('opacity', 0.5).show();
            }
            if (that.click === 0) {
                that.donutGroups.forEach(function (d) {
                    if (index !== d.data(&quot;donutIndex&quot;)) {
                        d.attr('fill-opacity', 0.5);
                    }
                });
            }
            this.attr('fill-opacity', 1);
        };

        var mouseOut = function () {
            floatTag.css({
                &quot;visibility&quot;: &quot;hidden&quot;
            });
            var index = this.data(&quot;donutIndex&quot;);
            //fade(this.data(&quot;donutIndex&quot;), 0.6);
            if (!this.data('click')) {
                that.underBn[index].hide();
            }
            if (that.click === 0) {
                that.donutGroups.forEach(function (d) {
                    d.attr('fill-opacity', 1);
                });
            } else if (!this.data('click')) {

                this.attr('fill-opacity', 0.5);
            }
        };

        var mouseClick = function () {
            var index = this.data(&quot;donutIndex&quot;);
            var flag = !this.data('click');
            this.data('click', flag);
            var a = 0.5 * ((that.groups[index].startAngle + that.groups[index].endAngle) - Math.PI);
            var nameX = conf.protrude * Math.cos(a);
            var nameY = conf.protrude * Math.sin(a);
            if (flag) {
                if (that.click === 0) {
                    that.donutGroups.forEach(function (d) {
                        if (!d.data('click')) {
                            d.attr('fill-opacity', 0.5);
                        }
                    });
                }
                that.underBn[index].attr('opacity', 1).show();
                this.attr('fill-opacity', 1);
                this.data('nameTag').translate(0, - conf.protrude);
                this.data('line').translate(0, - conf.protrude);
                this.translate(nameX, nameY);
                that.click += 1;
            } else {
                this.data('nameTag').translate(0, conf.protrude);
                this.data('line').translate(0, conf.protrude);
                this.translate(-nameX, - nameY);
                that.click -= 1;
                if (that.click &gt; 0) {
                    this.attr('fill-opacity', 0.5);
                }
            }
        };


        //画圆弧
        var i;
        var nameStr;
        var nameX, nameY;
        var ro, a;
        for (i = 0; i &lt;= groups.length - 1; i++) {
            //画外圈的pie图
            //计算每个group的path
            spline = pathCalc(groups[i]);
            tips = that.groupNames[i] + &quot;: &quot; + Math.round(groups[i].value) + &quot; &quot; + (groups[i].value * 100 / this.sum).toFixed(2) + &quot;%&quot;;

            donutEle = that.canvas.path(spline)
            .translate((conf.width - this.xOffset) / 2 + this.xOffset, conf.height / 2)
            .data(&quot;donutIndex&quot;, i)
            .attr({
                &quot;path&quot;: spline,
                &quot;fill&quot;: that.getColor(i),
                &quot;stroke&quot;: '#ffffff'
            })
            .mouseover(mouseOver)
            .mouseout(mouseOut)
            .click(mouseClick);

            //每个donut上显示名称
            ro = (groups[i].startAngle + groups[i].endAngle) * 90 / Math.PI;
            a = 0.5 * ((groups[i].startAngle + groups[i].endAngle) - Math.PI);
            nameX = (conf.radius + 2 * conf.protrude) * Math.cos(a);
            nameY = (conf.radius + 2 * conf.protrude) * Math.sin(a);
            nameStr = &quot;T&quot; + ((conf.width - that.xOffset) / 2 + that.xOffset) + &quot;,&quot; + conf.height / 2 + &quot;R&quot; + ro + &quot;T&quot; + nameX + &quot;,&quot; + nameY;

            var line = that.canvas.path(&quot;M,0,-&quot; + conf.protrude + &quot;L0,&quot; + conf.protrude).transform(nameStr).translate(0, conf.protrude + 9);
            var nameTag = that.canvas.text().attr(&quot;font&quot;, &quot;18px Verdana&quot;).attr(&quot;text&quot;, that.groupNames[i]).transform(nameStr);

            donutEle.data('text', tips).data('click', false).data('nameTag', nameTag).data('line', line);
            that.donutGroups.push(donutEle);
        }

        if (conf.legend) {
            this.legend();
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_legend">
    legend
  </h3>
  

  <p>绘制图例</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Pie.prototype.legend()</td> 
      <td></td>
      <td>legend</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Pie.prototype.legend = function () {
        var that = this;
        var conf = this.defaults;
        var paper = this.canvas;
        var legendArea = this.legendArea;
        this.rectBn = paper.set();
        var rectBn = this.rectBn;
        this.underBn = [];
        var underBn = this.underBn;
        for (var i = 0, l = this.groups.length; i &lt; l; i++) {
            //底框
            underBn.push(paper.rect(legendArea[0] + 10, legendArea[1] + 10 + (20 + 3) * i, 180, 20).attr({
                &quot;fill&quot;: &quot;#ebebeb&quot;,
                &quot;stroke&quot;: &quot;none&quot;
                //&quot;r&quot;: 3
            }).hide());
            //色框
            paper.rect(legendArea[0] + 10 + 3, legendArea[1] + 10 + (20 + 3) * i + 6, 16, 8).attr({
                &quot;fill&quot;: this.getColor(i),
                &quot;stroke&quot;: &quot;none&quot;
            });
            //文字
            paper.text(legendArea[0] + 10 + 3 + 16 + 8, legendArea[1] + 10 + (20 + 3) * i + 10, this.groupNames[i]).attr({
                &quot;fill&quot;: &quot;black&quot;,
                &quot;fill-opacity&quot;: 1,
                &quot;font-family&quot;: &quot;Verdana&quot;,
                &quot;font-size&quot;: 12,
                &quot;text-anchor&quot;: &quot;start&quot;
            });
            //选框
            rectBn.push(paper.rect(legendArea[0] + 10, legendArea[1] + 10 + (20 + 3) * i, 180, 20).attr({
                &quot;fill&quot;: &quot;white&quot;,
                &quot;fill-opacity&quot;: 0,
                &quot;stroke&quot;: &quot;none&quot;
                //&quot;r&quot;: 3
            }));
        }
        rectBn.forEach(function (d, i) {
            // TODO 这里的事件建议采用事件委托
            d.mouseover(function () {
                if (!that.donutGroups[i].data(&quot;click&quot;)) {
                    underBn[i].attr('opacity', 0.5);
                    underBn[i].show();
                }
            }).mouseout(function () {
                if (!that.donutGroups[i].data(&quot;click&quot;)) {
                    underBn[i].hide();
                }
            });
            d.click(function () {
                var a = 0.5 * ((that.groups[i].startAngle + that.groups[i].endAngle) - Math.PI);
                var nameX = conf.protrude * Math.cos(a);
                var nameY = conf.protrude * Math.sin(a);
                if (!that.donutGroups[i].data(&quot;click&quot;)) {
                    if (that.click === 0) {
                        that.donutGroups.forEach(function (d) {
                            if (!d.data('click')) {
                                d.attr('fill-opacity', 0.5);
                            }
                        });
                    }
                    underBn[i].attr('opacity', 1).show();
                    that.donutGroups[i].data(&quot;click&quot;, true).attr('fill-opacity', 1);
                    that.donutGroups[i].data('nameTag').translate(0, - conf.protrude);
                    that.donutGroups[i].data('line').translate(0, - conf.protrude);
                    that.donutGroups[i].translate(nameX, nameY);
                    that.click += 1;

                } else if (that.donutGroups[i].data(&quot;click&quot;)) {
                    that.donutGroups[i].data('nameTag').translate(0, conf.protrude);
                    that.donutGroups[i].data('line').translate(0, conf.protrude);
                    that.donutGroups[i].translate(-nameX, - nameY);
                    that.click -= 1;
                    if (that.click &gt; 0) {
                        that.donutGroups[i].attr('fill-opacity', 0.5);
                    } else {
                        that.donutGroups.forEach(function (d) {
                            d.attr('fill-opacity', 1);
                        });
                    }
                    underBn[i].hide();
                    that.donutGroups[i].data(&quot;click&quot;, false);

                }
            });
        });
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setSource">
    setSource
  </h3>
  

  <p>对原始数据进行处理</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Pie.prototype.setSource()</td> 
      <td></td>
      <td>setSource</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>table(Array)</td>
      <td colspan="2">将要被绘制成饼图的二维表数据</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Pie.prototype.setSource = function (table) {
        this.groupNames = _.pluck(table, 0);
        this.groupValue = _.pluck(table, 1).map(function (item) {
            return parseFloat(item);
        });
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_layout">
    layout
  </h3>
  

  <p>创建pie布局</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Pie.prototype.layout()</td> 
      <td></td>
      <td>layout</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Pie.prototype.layout = function () {
        var that = this;

        that.canvas.clear();

        var acc = 0;
        this.sum = DataV.sum(this.groupValue);
        var sum = this.sum;
        this.groups = this.groupValue.map(function (item, index) {
            var startAngle = 2 * acc * Math.PI / sum;
            acc += item;
            var endAngle = 2 * acc * Math.PI / sum;
            var ret = {
                index: index,
                value: item,
                startAngle: startAngle,
                endAngle: endAngle
            };
            return ret;
        });
    };

    return Pie;
});</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/scatterplotMatrix" class="api">
  <h2>charts/scatterplotMatrix: API索引</h2>
  <ul class="indexs">
  
    <li>
      <a href="#_setDimensionsX">setDimensionsX</a>
    </li>

    <li>
      <a href="#_setDimensionsY">setDimensionsY</a>
    </li>

    <li>
      <a href="#_setAxis">setAxis</a>
    </li>

    <li>
      <a href="#_createCanvas">createCanvas</a>
    </li>

  </ul>
  <hr />

  

  <table class="table">
  

  
  </table>
  
  
  <h3 id="_setDimensionsX">
    setDimensionsX
  </h3>
  

  <p>设置X轴的维度</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>ScatterplotMatrix.prototype.setDimensionsX()</td> 
      <td></td>
      <td>setDimensionsX</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>ScatterplotMatrix.prototype.setDimensionsX = function (dimen) {
        if (!dimen) {
            throw new Error(&quot;Please specify the dimensions.&quot;);
        }
        var conf = this.defaults;
        conf.dimensionsX = [];
        var i = 0,
            l = 0;
        for (i = 0, l = dimen.length; i &lt; l; i++) {
            if (_.indexOf(conf.allDimensions, dimen[i]) !== -1) {
                conf.dimensionsX.push(dimen[i]);
            }
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setDimensionsY">
    setDimensionsY
  </h3>
  

  <p>设置Y轴的维度</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>ScatterplotMatrix.prototype.setDimensionsY()</td> 
      <td></td>
      <td>setDimensionsY</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>ScatterplotMatrix.prototype.setDimensionsY = function (dimen) {
        if (!dimen) {
            throw new Error(&quot;Please specify the dimensions.&quot;);
        }
        var conf = this.defaults;
        conf.dimensionsY = [];
        var i = 0,
            l = 0;
        for (i = 0, l = dimen.length; i &lt; l; i++) {
            if (_.indexOf(conf.allDimensions, dimen[i]) !== -1) {
                conf.dimensionsY.push(dimen[i]);
            }
        }
    };

    //设置类型的名字
    ScatterplotMatrix.prototype.setTypeName = function (types) {
        this.defaults.typeNames = types;
    };

    //设置源数据
    ScatterplotMatrix.prototype.setSource = function (source) {
        var i, j, l, ll;
        var conf = this.defaults;

        var xTemp = [],
            yTemp = [];
        for (i = 1; i &lt; source[0].length; i++) {
            xTemp[i - 1] = source[0][i];
            yTemp[i - 1] = source[0][i];
        }
        conf.allDimensions = source[0];
        // 默认情况下，所有维度都显示
        conf.dimensionsX = xTemp;
        conf.dimensionsY = yTemp;

        // this.source is array of line; key is dimension, value is line's value in that dimension
        this.source = [];

        for (i = 1, l = source.length; i &lt; l; i++) {
            var line = {}, dimenT = conf.allDimensions;
            for (j = 0, ll = dimenT.length; j &lt; ll; j++) {
                line[dimenT[j]] = source[i][j]; //each line is an array, contains value for each dimension
            }
            this.source.push(line);
        }

        // 设置默认的定义域
        var getExtent = function (s, dimen) {
            return d3.extent(s, function (p) {
                return +p[dimen];
            });
        };
        var dimen;
        for (i = 0, l = conf.allDimensions.length; i &lt; l; i++) {
            dimen = conf.allDimensions[i];
            conf.dimensionDomain[dimen] = getExtent(this.source, dimen);
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setAxis">
    setAxis
  </h3>
  

  <p>设置X轴和Y轴</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>ScatterplotMatrix.prototype.setAxis()</td> 
      <td></td>
      <td>setAxis</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>ScatterplotMatrix.prototype.setAxis = function () {
        var conf = this.defaults;

        conf.legendArea = [20, (conf.height - 20 - 220), 200, 220];
        conf.introArea = [20, 20, 200, 200];
        conf.diagramArea = [240, 20, (conf.width - 260), (conf.height - 40)];

        var w = conf.diagramArea[2] - 2 * conf.margin,
            h = conf.diagramArea[3] - conf.margin,
            g = conf.gap,
            nX = conf.dimensionsX.length,
            nY = conf.dimensionsY.length,
            wX = d3.round((w - (nX - 1) * g) / nX),
            wY = d3.round((h - (nY - 1) * g) / nY),
            sw = d3.min([wX, wY]);

        this.defaults.squareWidth = sw;
        this.defaults.dX = conf.dimensionsX[0];
        this.defaults.dY = conf.dimensionsY[0];

        this.x = {};
        this.y = {};
        var x = this.x,
            y = this.y;
        var tickAr = [5];

        //设置X轴
        var i, l, dimen, begin, end;
        for (i = 0, l = conf.dimensionsX.length; i &lt; l; i++) {
            dimen = conf.dimensionsX[i];
            begin = i * (sw + g) + conf.diagramArea[0] + 30;
            end = begin + sw;
            x[dimen] = d3.scale.linear().domain(conf.dimensionDomain[dimen]).range([begin, end]);
            x[dimen].ticks = x[dimen].ticks.apply(x[dimen], tickAr);
        }
        //设置Y轴
        for (i = 0, l = conf.dimensionsY.length; i &lt; l; i++) {
            dimen = conf.dimensionsY[i];
            end = i * (sw + g) + conf.diagramArea[1] + 30;
            begin = end + sw;
            y[dimen] = d3.scale.linear().domain(conf.dimensionDomain[dimen]).range([begin, end]);
            y[dimen].ticks = y[dimen].ticks.apply(y[dimen], tickAr);
        }
    };

    //画散点矩阵
    ScatterplotMatrix.prototype.drawDiagram = function () {
        var i, j, k, z, ticks;
        var conf = this.defaults,
            x = this.x,
            y = this.y,
            sw = conf.squareWidth,
            g = conf.gap,
            cR = conf.circleR;

        var paper = this.canvas;
        var sourceData = this.source;

        var dimensionsX = conf.dimensionsX,
            dimensionsY = conf.dimensionsY,
            lx = dimensionsX.length,
            ly = dimensionsY.length;

        var browserName = navigator.appName;
        var that = this;

        $(this.node).append(this.floatTag);

        //画背景点
        var circlesBg = paper.set(); //背景点
        var centerPos;

        if (browserName !== &quot;Microsoft Internet Explorer&quot;) {
            for (k = 0; k &lt; sourceData.length; k++) {
                for (i = 0; i &lt; lx; i++) {
                    for (j = 0; j &lt; ly; j++) {
                        centerPos = this.circleCenter(k, dimensionsX[i], dimensionsY[j]);
                        circlesBg.push(paper.circle(centerPos[0], centerPos[1], cR).attr({
                            &quot;fill&quot;: &quot;gray&quot;,
                            &quot;stroke&quot;: &quot;none&quot;,
                            &quot;opacity&quot;: 0.2
                        }));
                    }
                }
            }
        }

        // 画矩形框
        var squares = paper.set();
        var x1, y1;
        for (i = 0; i &lt; lx; i++) {
            for (j = 0; j &lt; ly; j++) {
                x1 = x[dimensionsX[i]].range()[0];
                y1 = y[dimensionsY[j]].range()[1];
                squares.push(paper.rect(x1 - 1, y1 - 1, sw + 2, sw + 2));
            }
        }
        squares.attr({
            &quot;fill&quot;: &quot;white&quot;,
            &quot;fill-opacity&quot;: 0.5, //背景点的蒙版
            &quot;stroke&quot;: &quot;#d6d6d6&quot;,
            &quot;stroke-width&quot;: '1px'
        });

        //画虚线
        var reLines = paper.set(),
            tickText = paper.set();
        var tickAr = [10], //set the number of ticks
            leftPos = x[dimensionsX[0]].range()[0],
            rightPos = x[dimensionsX[lx - 1]].range()[1],
            upPos = y[dimensionsY[0]].range()[1],
            downPos = y[dimensionsY[ly - 1]].range()[0];

        var reLineGap = sw / 7; //每个矩形框中画6条虚线
        var reLinePos;

        //画纵向的虚线
        for (i = 0; i &lt; lx; i++) {
            ticks = x[dimensionsX[i]].ticks;
            for (j = 0; j &lt; ticks.length; j++) {
                tickText.push(paper.text((x[dimensionsX[i]](ticks[j])), downPos + 6, ticks[j]).attr({
                    &quot;fill&quot;: &quot;#aaaaaa&quot;,
                    &quot;fill-opacity&quot;: 0.7,
                    &quot;font-family&quot;: &quot;雅黑&quot;,
                    &quot;font-size&quot;: 12
                }).attr({
                    &quot;text-anchor&quot;: &quot;end&quot;
                }).rotate(-45, x[dimensionsX[i]](ticks[j]), downPos + 6));
            }
            for (z = 1; z &lt; 7; z++) {
                reLinePos = x[dimensionsX[i]].range()[0] + z * reLineGap;
                reLines.push(paper.path(&quot;M&quot; + (reLinePos) + &quot;,&quot; + (upPos) + &quot;L&quot; + (reLinePos) + &quot;,&quot; + (downPos)).attr({
                    &quot;stroke&quot;: &quot;#ebebeb&quot;,
                    &quot;stroke-dasharray&quot;: &quot;-&quot;
                }));
            }
        }
        //画横向的虚线
        for (i = 0; i &lt; ly; i++) {
            //draw reference lines
            ticks = y[dimensionsY[i]].ticks;
            for (j = 0; j &lt; ticks.length; j++) {
                tickText.push(paper.text(rightPos + 6, y[dimensionsY[i]](ticks[j]), ticks[j]).attr({
                    &quot;fill&quot;: &quot;#aaaaaa&quot;,
                    &quot;fill-opacity&quot;: 0.7,
                    &quot;font-family&quot;: &quot;雅黑&quot;,
                    &quot;font-size&quot;: 12
                }).attr({
                    &quot;text-anchor&quot;: &quot;start&quot;
                }).rotate(315, rightPos + 6, y[dimensionsY[i]](ticks[j])));
            }
            for (z = 1; z &lt; 7; z++) {
                reLinePos = y[dimensionsY[i]].range()[1] + z * reLineGap;
                reLines.push(paper.path(&quot;M&quot; + (leftPos) + &quot;,&quot; + (reLinePos) + &quot;L&quot; + (rightPos) + &quot;,&quot; + (reLinePos)).attr({
                    &quot;stroke&quot;: &quot;#ebebeb&quot;,
                    &quot;stroke-dasharray&quot;: &quot;-&quot;
                }));
            }
        }

        //坐标轴名称
        var axText = paper.set();
        var xPos, yPos;
        var pos = y[dimensionsY[0]].range()[1] - 10;
        for (i = 0; i &lt; lx; i++) {
            xPos = x[dimensionsX[i]].range()[0] + sw / 2;
            axText.push(paper.text(xPos, pos, dimensionsX[i]).attr({
                &quot;fill&quot;: &quot;#000000&quot;,
                &quot;fill-opacity&quot;: 0.7,
                &quot;font-family&quot;: &quot;Verdana&quot;,
                //&quot;font-weight&quot;: &quot;bold&quot;,
                &quot;font-size&quot;: 12
            }).attr({
                &quot;text-anchor&quot;: &quot;middle&quot;
            }));
        }

        pos = x[dimensionsX[0]].range()[0] - 10;
        for (i = 0; i &lt; ly; i++) {
            yPos = y[dimensionsY[i]].range()[1] + sw / 2;
            axText.push(paper.text(pos, yPos, dimensionsY[i]).attr({
                &quot;fill&quot;: &quot;#000000&quot;,
                &quot;fill-opacity&quot;: 0.7,
                &quot;font-family&quot;: &quot;Verdana&quot;,
                //&quot;font-weight&quot;: &quot;bold&quot;,
                &quot;font-size&quot;: 12
            }).attr({
                &quot;text-anchor&quot;: &quot;middle&quot;
            }).rotate(-90, pos, yPos));
        }

        // 画前景点
        var circlesFg = []; //circles in foreground
        var circleType = -1;
        var typeMax = -1;

        this.preIndex = &quot;start&quot;;
        this.linePosition = [0,0];
        //水平虚线
        that.lineH = paper.path(&quot;M&quot; + (leftPos) + &quot;,&quot; + (0) + &quot;L&quot; + (rightPos) + &quot;,&quot; + (0)).attr({
            &quot;stroke-dasharray&quot;: &quot;- &quot;,
            'stroke': '#000000'
        }).hide();
        //垂直虚线
        that.lineV = paper.path(&quot;M&quot; + (0) + &quot;,&quot; + (upPos) + &quot;L&quot; + (0) + &quot;,&quot; + (downPos)).attr({
            &quot;stroke-dasharray&quot;: &quot;- &quot;,
            'stroke': '#000000'
        }).hide();
        var hoverTag;
        var circle;
        for (k = 0; k &lt; sourceData.length; k++) {
            if (conf.typeName !== &quot;NoTypeDefinition&quot;) { //classify the circles according to their types
                circleType = sourceData[k][conf.typeName] - 1;
                typeMax = Math.max(typeMax, circleType);
            } else {
                circleType = 0;
            }
            for (i = 0; i &lt; lx; i++) {
                for (j = 0; j &lt; ly; j++) {
                    centerPos = this.circleCenter(k, dimensionsX[i], dimensionsY[j]);
                    //前景点
                    circle = paper.circle(centerPos[0], centerPos[1], cR)
                    .data(&quot;type&quot;, circleType)
                    .data(&quot;canHover&quot;, 0)
                    .data(&quot;position&quot;, centerPos)
                    .data('colorType', circleType)
                    .attr({
                        &quot;fill&quot;: &quot;#800&quot;,
                        &quot;stroke&quot;: &quot;none&quot;,
                        &quot;opacity&quot;: 0.5
                    }).attr({
                        &quot;fill&quot;: this.getColor(circleType)
                    });
                    //如果制定了hover要显示的文字，则hover显示的文字
                    if (conf.legendDimen !== &quot;NoTagDimen&quot;) {
                        hoverTag = conf.legendDimen + &quot;: &quot; + sourceData[k][conf.legendDimen];
                        circle.data(&quot;legend&quot;, hoverTag);
                    }
                    circlesFg.push(circle);
                }
            }
        }

        //图例
        var legendArea = this.defaults.legendArea;
        var rectBn = paper.set();
        var underBn = [];
        for (i = 0; i &lt;= typeMax; i++) {
            //底框
            underBn.push(paper.rect(legendArea[0] + 10, legendArea[1] + 10 + (20 + 3) * i, 180, 20).attr({
                &quot;fill&quot;: &quot;#ebebeb&quot;,
                &quot;stroke&quot;: &quot;none&quot;
            }).hide());
            //色框
            paper.rect(legendArea[0] + 10 + 3, legendArea[1] + 10 + (20 + 3) * i + 6, 16, 8).attr({
                &quot;fill&quot;: this.getColor(i),
                &quot;stroke&quot;: &quot;none&quot;
            });
            //文字
            paper.text(legendArea[0] + 10 + 3 + 16 + 8, legendArea[1] + 10 + (20 + 3) * i + 10, conf.typeNames[i]).attr({
                &quot;fill&quot;: &quot;black&quot;,
                &quot;fill-opacity&quot;: 1,
                &quot;font-family&quot;: &quot;Verdana&quot;,
                &quot;font-size&quot;: 12
            }).attr({
                &quot;text-anchor&quot;: &quot;start&quot;
            });
            //选框
            rectBn.push(paper.rect(legendArea[0] + 10, legendArea[1] + 10 + (20 + 3) * i, 180, 20).attr({
                &quot;fill&quot;: &quot;white&quot;,
                &quot;fill-opacity&quot;: 0,
                &quot;stroke&quot;: &quot;none&quot;
                //&quot;r&quot;: 3
            }).data(&quot;type&quot;, i)).data(&quot;clicked&quot;, 0);
        }

        if (browserName !== &quot;Microsoft Internet Explorer&quot;) {
            rectBn.forEach(function (d, i) {
                underBn[i].data('legendclicked', false);
                d.mouseover(function () {
                    if (underBn[i].data('legendclicked') === false) {
                        underBn[i].attr('opacity', 0.5).show();
                    }
                }).mouseout(function () {
                    if (underBn[i].data('legendclicked') === false) {
                        underBn[i].hide();
                    }
                });
                d.click(function () {
                    for (j = 0; j &lt; underBn.length; j++) {
                        if (j === i) {
                            underBn[j].show();
                        } else {
                            underBn[j].hide();
                        }
                    }
                    rectBn.forEach(function (eachBn) {
                        if (eachBn !== d) {
                            eachBn.data(&quot;clicked&quot;, 0);
                        }

                    });
                    if (d.data(&quot;clicked&quot;) === 0) {
                        underBn[i].attr('opacity', 1).show();
                        underBn[i].data('legendclicked', true);
                        circlesFg.forEach(function (ec) {
                            if (ec.data(&quot;type&quot;) !== d.data(&quot;type&quot;)) {
                                ec.hide();
                                ec.data(&quot;canHover&quot;, 0);
                            } else {
                                ec.show();
                                ec.data(&quot;canHover&quot;, 1);
                            }
                        });
                        d.data(&quot;clicked&quot;, 1);
                    } else if (d.data(&quot;clicked&quot;) === 1) {
                        underBn[i].hide();
                        underBn[i].data('legendclicked', false);
                        d.data(&quot;clicked&quot;, 0);
                        circlesFg.forEach(function (ec) {
                            ec.show();
                            ec.data(&quot;canHover&quot;, 0);
                        });
                    }
                });
            });

            //Bursh函数定义
            var curBrush;

            function brushstart() {
                if (curBrush !== undefined &amp;&amp; curBrush !== d3.event.target) {
                    curBrush.clear();
                }
                var i;
                for (i = 0; i &lt; circlesFg.length; i++) {
                    circlesFg[i].hide();
                    circlesFg[i].data(&quot;canHover&quot;, 0);
                }
                underBn.forEach(function (ub) {
                    ub.hide();
                });
                rectBn.forEach(function (rb) {
                    rb.data(&quot;clicked&quot;, 0);
                });
            }

            function brush() {
                curBrush = d3.event.target;

                var e = curBrush.extent(),
                    dimX = d3.event.target.dimX,
                    dimY = d3.event.target.dimY,
                    tempX,
                    tempY,
                    count = lx * ly,
                    i,
                    z;

                for (i = 0; i &lt; sourceData.length; i++) {
                    tempX = sourceData[i][dimX];
                    tempY = sourceData[i][dimY];
                    if (e[0][0] - 1 &lt;= tempX &amp;&amp; tempX &lt;= e[1][0] + 1 &amp;&amp; e[0][1] - 1 &lt;= tempY &amp;&amp; tempY &lt;= e[1][1] + 1) {
                        for (z = 0; z &lt; count; z++) {
                            circlesFg[i * count + z].show();
                        }
                    } else {
                        for (z = 0; z &lt; count; z++) {
                            circlesFg[i * count + z].hide();
                        }
                    }
                }
            }

            function brushend() {
                if (d3.event.target.empty()) {
                    circlesFg.forEach(function (d) {
                        d.show();
                    });
                }
            }

            //Brush交互
            var brushes = [];
            var b;
            for (i = 0; i &lt; lx; i++) {
                for (j = 0; j &lt; ly; j++) {
                    b = Brush().x(x[dimensionsX[i]]).y(y[dimensionsY[j]]).backgroundAttr({
                        &quot;opacity&quot;: 0, //背景颜色：白色、全透明
                        &quot;fill&quot;: &quot;white&quot;
                    }).foregroundAttr({ //选框颜色
                        &quot;opacity&quot;: 0.2,
                        &quot;fill&quot;: &quot;#fff700&quot;
                    }).on(&quot;brushstart&quot;, brushstart).on(&quot;brush&quot;, brush).on(&quot;brushend&quot;, brushend);
                    b(paper);
                    b.dimX = dimensionsX[i];
                    b.dimY = dimensionsY[j];
                    brushes.push(b);
                }
            }
            //hover交互
            //var preIndex = &quot;start&quot;;
            var floatTag = this.floatTag;
            $(paper.canvas).bind(&quot;mousemove&quot;, function (e) {
                var bgOffset = $(this).parent().offset();
                var mouse = [e.pageX - bgOffset.left, e.pageY - bgOffset.top];
                var location = [Math.floor((mouse[0] - leftPos) / (sw + g)), Math.floor((mouse[1] - upPos) / (sw + g))];
                if (that.preIndex !== &quot;start&quot;) {
                    that.lineV.hide();
                    that.lineH.hide();
                    if (conf.legendDimen !== &quot;NoTagDimen&quot;) {
                        floatTag.css({&quot;visibility&quot; : &quot;hidden&quot;});
                    }
                }
                if (location[0] &gt;= 0 &amp;&amp; location[0] &lt;= lx &amp;&amp; location[1] &gt;= 0 &amp;&amp; location[1] &lt;= ly) {
                    for (i = location[0] * ly + location[1]; i &lt; circlesFg.length; i = i + lx * ly) {
                        var center = circlesFg[i].data(&quot;position&quot;);
                        var canHover = circlesFg[i].data(&quot;canHover&quot;);
                        if ((canHover === 1) &amp;&amp; (Math.abs(mouse[0] - center[0]) &lt;= cR) &amp;&amp; (Math.abs(mouse[1] - center[1]) &lt;= cR)) {
                            that.lineV.translate(center[0] - that.linePosition[0], 0).attr('stroke', that.getColor(circlesFg[i].data('colorType'))).show();
                            that.lineH.translate(0, center[1] - that.linePosition[1]).attr('stroke', that.getColor(circlesFg[i].data('colorType'))).show();
                            that.linePosition = center;
                            if (conf.legendDimen !== &quot;NoTagDimen&quot;) {
                                floatTag.html('&lt;div style=&quot;text-align: center;margin:auto;color:#ffffff&quot;&gt;' + circlesFg[i].data(&quot;legend&quot;) + '&lt;/div&gt;');
                                floatTag.css({&quot;visibility&quot; : &quot;visible&quot;});
                            }
                            that.preIndex = i;
                            break;
                        }
                    }
                }
            });
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_createCanvas">
    createCanvas
  </h3>
  

  <p>创建canvas</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>ScatterplotMatrix.prototype.createCanvas()</td> 
      <td></td>
      <td>createCanvas</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>ScatterplotMatrix.prototype.createCanvas = function () {
        var conf = this.defaults;
        this.node.style.position = &quot;relative&quot;;
        this.canvas = new Raphael(this.node, conf.width, conf.height);
        this.floatTag = DataV.FloatTag()(this.node);
        this.floatTag.css({&quot;visibility&quot;: &quot;hidden&quot;});
    };

    //根据不同类别得到颜色值
    ScatterplotMatrix.prototype.getColor = function (circleType) {
        var color = DataV.getColor();
        return color[circleType % color.length][0];
    };

    //绘制函数
    ScatterplotMatrix.prototype.render = function (options) {
        this.setOptions(options);
        this.canvas.clear();
        this.setAxis();
        this.drawDiagram();
        //var dEnd = new Date();
        //alert(dEnd.getTime() - dBegin.getTime());
    };

    //计算每个circle的圆心位置
    ScatterplotMatrix.prototype.circleCenter = function (index, xDimen, yDimen) {
        var conf = this.defaults,
            source = this.source,
            y = this.y,
            x = this.x,
            dimensionsX = conf.dimensionsX,
            dimensionsY = conf.dimensionsY,
            dimensionType = conf.dimensionType;

        var xPos = x[xDimen](source[index][xDimen]),
            yPos = y[yDimen](source[index][yDimen]);

        return [xPos, yPos];
    };

    return ScatterplotMatrix;
});</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/stream" class="api">
  <h2>charts/stream: API索引</h2>
  <ul class="indexs">
  
    <li>
      <a href="#_Stream">Stream</a>
    </li>

    <li>
      <a href="#Stream_dimension">dimension</a>
    </li>

    <li>
      <a href="#_setOptions">setOptions</a>
    </li>

    <li>
      <a href="#_getDigitData">getDigitData</a>
    </li>

    <li>
      <a href="#_getInfo">getInfo</a>
    </li>

    <li>
      <a href="#_setSource">setSource</a>
    </li>

    <li>
      <a href="#_setTimeRange">setTimeRange</a>
    </li>

    <li>
      <a href="#_layout">layout</a>
    </li>

    <li>
      <a href="#_getColor">getColor</a>
    </li>

    <li>
      <a href="#_generatePaths">generatePaths</a>
    </li>

    <li>
      <a href="#_createLegend">createLegend</a>
    </li>

    <li>
      <a href="#_createNavi">createNavi</a>
    </li>

    <li>
      <a href="#_getMaxPercentage">getMaxPercentage</a>
    </li>

    <li>
      <a href="#_createPercentage">createPercentage</a>
    </li>

    <li>
      <a href="#_createStreamPaths">createStreamPaths</a>
    </li>

    <li>
      <a href="#_createAxis">createAxis</a>
    </li>

    <li>
      <a href="#_getMaxY">getMaxY</a>
    </li>

    <li>
      <a href="#_mapPathSource">mapPathSource</a>
    </li>

    <li>
      <a href="#_generateArea">generateArea</a>
    </li>

    <li>
      <a href="#_clearCanvas">clearCanvas</a>
    </li>

    <li>
      <a href="#_reRender">reRender</a>
    </li>

    <li>
      <a href="#_render">render</a>
    </li>

    <li>
      <a href="#_resize">resize</a>
    </li>

    <li>
      <a href="#_on">on</a>
    </li>

    <li>
      <a href="#_animate">animate</a>
    </li>

  </ul>
  <hr />

  

  <table class="table">
  

  
  </table>
  
  
  <h3 id="_Stream">
    Stream
  </h3>
  

  <p>Stream构造函数<br />Create stream in a dom node with id "chart", width is 500; height is 600px;</p>

<h2>Options</h2>

<ul>
<li><code>width</code> 宽度，默认为节点宽度</li>
</ul>

<h2>Examples</h2>

<div class="highlight"><pre lang="">var stream = new Stream("chart", {"width": 500, "height": 600});
</pre></div>

  <table class="table">
  
    <tr>
      <td>声明</td>
      <td>Stream</td> 
      <td></td>
      <td>Stream</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>node(Mix)</td>
      <td colspan="2">The dom node or dom node Id</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>options(Object)</td>
      <td colspan="2">options json object for determin stream style.</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>var Stream = DataV.extend(DataV.Chart, {
        initialize: function (node, options) {
            this.type = &quot;Stream&quot;;
            this.node = this.checkContainer(node);

            this.level = 0;
            // Properties
            this.defaults.offset = &quot;zero&quot;;//&quot;expand&quot;;
            this.defaults.order = &quot;default&quot;;
            this.defaults.columnNameUsed = &quot;auto&quot;;
            this.defaults.rowNameUsed = &quot;auto&quot;;
            this.defaults.topInterval = 0;
            this.defaults.bottomInterval = 0;
            this.defaults.legend = true;
            this.defaults.axis = true;
            this.defaults.pathLabel = true;
            this.defaults.fontSize = 12;
            this.defaults.heightWidthRatio = 0.618;
            //this.defaults.axisTickNumber = 8; // axis ticks number
    
            this.defaults.indexMargin = 3; // if dates.length &lt; indexMargin * 2 + 1, do not show label
    
            this.userConfig = {&quot;more&quot;: true, &quot;max&quot;: 20, &quot;other&quot;: 0.1};

            this.timeRange = [];
            // Canvas
            this.defaults.width = 750;
            this.defaults.height = 360;
            this.defaults.totalWidth = 820;
            this.defaults.naviBackWidth = 80;
            this.defaults.legendHeight = 50;
            this.defaults.legendWidth = 150;
            this.defaults.legendIndent = 21;
            this.defaults.axisHeight = 30;
            this.defaults.margin = [0, 40, 0, 40];

            this.defaults.customEventHandle = {&quot;mousemove&quot;: null};

            //test related
            this.defaults.testMakeup = false;
            this.defaults.testDays = 30;
            this.defaults.testDataType = 0; //0: random; 1: false random; 2: same; &gt;2: small change;
    
            this.setOptions(options);
            this.createCanvas();
        }
    });</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="Stream_dimension">
    dimension
  </h3>
  

  <p>Stream图纬度描述</p>

  <table class="table">
  
    <tr>
      <td>属性</td>
      <td>Stream.dimension</td> 
      <td>Stream</td>
      <td>dimension</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.dimension = {};</code></pre></td>
    </tr>
  
  </table>
  
  

  <p>流向纬度，例如，时间</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.dimension.stream = {
        type: &quot;string&quot;,
        required: true
    };</code></pre></td>
    </tr>
  
  </table>
  
  

  <p>堆叠纬度，例如，按类目</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.dimension.stack = {
        type: &quot;string&quot;,
        required: true
    };</code></pre></td>
    </tr>
  
  </table>
  
  

  <p>值纬度，在流向和堆叠纬度上的值</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.dimension.value = {
        type: &quot;number&quot;,
        required: true
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setOptions">
    setOptions
  </h3>
  

  <p>设置自定义选项</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.setOptions()</td> 
      <td></td>
      <td>setOptions</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.setOptions = function (options) {
        _.extend(this.defaults, options);

        if (options &amp;&amp; options.width) {
            this.defaults.totalWidth = this.defaults.width;
            this.defaults.width = this.defaults.totalWidth - this.defaults.margin[1]
                - this.defaults.margin[3] - this.defaults.legendWidth;
            if (!options.height) {
                this.defaults.autoHeight = true;
                this.defaults.height = this.defaults.width * this.defaults.heightWidthRatio;
            } else {
                this.defaults.autoHeight = false;
            }
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_getDigitData">
    getDigitData
  </h3>
  

  <p>获取数据</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.getDigitData()</td> 
      <td></td>
      <td>getDigitData</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>source(Array)</td>
      <td colspan="2">从二维数组中，获取纯数据的部分（排除掉列名后）</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.getDigitData = function (source) {
		//get first column name, row name and digitData;
        var conf = this.defaults,
            firstRow = source[0],
            firstColumn,
            digitData;

        var i, j, l, ll;

        firstColumn = source.map(function (d) {
            return d[0];
        });

        if (this.hasRowName()) {
            if (this.hasColumnName()) {
                //row names, column names
                this.rowName = firstColumn.slice(1);
                this.columnName = firstRow.slice(1);
                digitData = source.map(function (d) {
                    return d.slice(1);
                }).slice(1);
            } else {
                //row names, no column names
                this.rowName = firstColumn;
                this.columnName = undefined;
                digitData = source.map(function (d) {
                    return d.slice(1);
                });
            }
        } else {
            if (this.hasColumnName()) {
                //no row names, column names
                this.rowName = undefined;
                this.columnName = firstRow;
                digitData = source.slice(1);
            } else {
                //no row names, no column names
                if (conf.columnNameUsed === &quot;auto&quot; &amp;&amp; conf.rowNameUsed === &quot;auto&quot; &amp;&amp; !DataV.isNumeric(source[0][0])) {
                    throw new Error(&quot;Please specify whether there are column names or row names&quot;);
                }
                this.rowName = undefined;
                this.columnName = undefined;
                digitData = source;
            }
        }
        for (i = 0, l = digitData.length; i &lt; l; i++) {
            for (j = 0, ll = digitData[0].length; j &lt; ll; j++) {
                digitData[i][j] = parseFloat(digitData[i][j]);
            }
        }
		return digitData;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_getInfo">
    getInfo
  </h3>
  

  <p>获取信息数据</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.getInfo()</td> 
      <td></td>
      <td>getInfo</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.getInfo = function () {
		var allInfos = [];
		var i, j, l, ll;
		var infos, info;
        var column;
        var digitData = this.digitData;
        var descending = function (a, b) {
                return b.value - a.value;
            };
		for (i = 0, l = this.digitData.length; i &lt; l; i++) {
			infos = allInfos[i] = [];
			infos.ratio = this.rowSum[i] / this.total;
			infos.value = this.rowSum[i];
			infos.name = this.rowName[i];
			infos.id = i;
		}
        for (i = 0, l = digitData.length; i &lt; l; i++) {
            column = [];
            for (j = 0, ll = digitData[0].length; j &lt; ll; j++) {
                allInfos[i][j] = column[j] = {
                    &quot;date&quot;: this.columnName[j],
                    &quot;id&quot;: i,
                    &quot;name&quot;: allInfos[i].name,
                    &quot;tip&quot;: &quot;&lt;b&gt;&quot; + allInfos[i].name + &quot;&lt;/b&gt;&lt;br/&gt;占比:&quot;
                        + (Math.round(digitData[i][j] / this.columnSum[j] * 10000) / 100) + &quot;%&lt;br/&gt;&quot;,
                    &quot;total&quot;: allInfos[i].ratio,
                    //&quot;value&quot;: columnTotal[i]
                    &quot;value&quot; : digitData[i][j],
                    &quot;index&quot; : j,
                    &quot;rowInfo&quot; : allInfos[i],
                    &quot;ratio&quot; : digitData[i][j] / this.columnSum[j]
                };
            }

            column.sort(descending);

            for (j = 0, ll = column.length; j &lt; ll; j++) {
                column[j].rank = j;
            }
        }
        return allInfos;
	};</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setSource">
    setSource
  </h3>
  

  <p>设置数据源</p>

<h2>Examples</h2>

<p>例如下面的数组表示2个人在一年4个季度的消费。第一个人在4个季度里消费了1、2、3、9元。第二个人消费了3、4、6、3元。</p>

<div class="highlight"><pre lang="">[
 [1,2,3,9],
 [3,4,6,3]
]
</pre></div>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.setSource()</td> 
      <td></td>
      <td>setSource</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>source(Array)</td>
      <td colspan="2">二维数组的数据源</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.setSource = function (source) {
        this.rawData = source;
		this.digitData = this.getDigitData(this.rawData);

        //get date, sort and allInfos;
        //date
        this.date = source[0].slice(1, source[0].length);
        this.timeRange = [0, this.date.length - 1];
        //sort
        this.digitData = this.sort(this.digitData);
		this.allInfos = this.getInfo(this.digitData);

        this.level = 0;
        this.getLevelSource();
        //this.source = this.remapSource(digitData);
        this.canAnimate = false;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setTimeRange">
    setTimeRange
  </h3>
  

  <p>If useString is true, start and end are date string, else start and end are index number</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.setTimeRange()</td> 
      <td></td>
      <td>setTimeRange</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>start(Number,String)</td>
      <td colspan="2">起始范围</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>end(Number,String)</td>
      <td colspan="2">结束范围</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>useString(Boolean)</td>
      <td colspan="2">是否是字符串</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.setTimeRange = function (start, end, useString) {
        var idx1, idx2;
        if (useString) {
            idx1 = _.indexOf(this.date, start);
            idx2 = _.indexOf(this.date, end);
        } else {
            idx1 = start;
            idx2 = end;
        }

        var min = Math.min(idx1, idx2);
        var max = Math.max(idx1, idx2);
        if (min === max) {
            throw new Error(&quot;start index and end index can not be same.&quot;);
        }
        if (min &lt; 0 || max &gt; this.date.length - 1) {
            throw new Error(&quot;start index or end index is beyond the time range.&quot;);
        }

        this.timeRange = [min, max];
        this.getLevelSource();
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_layout">
    layout
  </h3>
  

  <p>生成布局</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.layout()</td> 
      <td></td>
      <td>layout</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.layout = function () {
        var conf = this.defaults;
        d3.layout.stack().offset(conf.offset).order(conf.order)(this.source);
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_getColor">
    getColor
  </h3>
  

  <p>根据选择方案获取颜色数据</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.getColor()</td> 
      <td></td>
      <td>getColor</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>colorJson(Object)</td>
      <td colspan="2">颜色方案</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>Array</td>
      <td colspan="2">返回颜色数据</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.getColor = function (colorJson) {
        var colorMatrix = DataV.getColor();
        var color;
        var colorStyle = colorJson || {};
        var colorMode = colorStyle.mode || 'default';
        var i, l;

        switch (colorMode) {
        case &quot;gradient&quot;:
            l = this.source.length;
            var colorL = Math.round(l / 5);
            if (colorL &gt; colorMatrix.length - 1) {
                colorL = colorMatrix.length - 1;
            }
            var testColor = [colorMatrix[0][0], colorMatrix[colorL][0]];
            var test1 = DataV.gradientColor(testColor, &quot;special&quot;);
            var testColorMatrix = [];
            var testColorMatrix1 = [];
            for (i = 0; i &lt; l; i++) {
                testColorMatrix.push([test1(i / (l - 1)), test1(i / (l - 1))]);
            }

            for (i = (l - 1); i &gt;= 0; i--) {
                testColorMatrix1.push(testColorMatrix[i]);
            }

            colorMatrix = testColorMatrix;
            
            break;
        case &quot;random&quot;:
        case &quot;default&quot;:
            break;
        }

        var ratio = colorStyle.ratio || 0;
        if (ratio &lt; 0) { ratio = 0; }
        if (ratio &gt; 1) { ratio = 1; }
        var colorArray = [];
        for (i = 0, l = colorMatrix.length; i &lt; l; i++) {
            var colorFunc = d3.interpolateRgb.apply(null, [colorMatrix[i][0], colorMatrix[i][1]]);
            colorArray.push(colorFunc(ratio));
        }
        color = d3.scale.ordinal().range(colorArray);

        return color;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_generatePaths">
    generatePaths
  </h3>
  

  <p>生成路径</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.generatePaths()</td> 
      <td></td>
      <td>generatePaths</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.generatePaths = function () {
        this.createNavi();
        this.createPercentage();
        this.createAxis();
        this.createStreamPaths();
        this.createLegend();
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_createLegend">
    createLegend
  </h3>
  

  <p>创建图例</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.createLegend()</td> 
      <td></td>
      <td>createLegend</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.createLegend = function () {
        var conf = this.defaults,
            //paper = this.legendPaper,
            legends = [],
            m = [10, 20, 10, 20],
            left = m[3],
            top = m[0],
            lineHeight = 25,
            legendInterval = 10,
            width = conf.legendWidth - conf.legendIndent,
            r0 = 5,
            r1 = 7,
            circleW = 18,
            x,
            y,
            circle,
            text,
            box,
            ul,
            li,
            color = this.getColor({mode: conf.colorMode}),
            i,
            l,
            leftHeight,
            legendHeight,
            legendTopMargin,
            hoverIn = function (e) {
                var index = e.data.index;
                var stream = e.data.stream;
                var path = stream.paths[index];
                //stream.legends[stream.preIndex]
                stream.preIndex = index;
                stream.legends[index].css({&quot;background&quot;: &quot;#dddddd&quot;});
                path.attr({&quot;opacity&quot;: 0.5});
            },
            hoverOut = function (e) {
                var index = e.data.index;
                var stream = e.data.stream;
                var path = stream.paths[index];
                stream.preIndex = index;
                stream.legends[index].css({&quot;background&quot;: &quot;white&quot;});
                path.attr({&quot;opacity&quot;: 1.0});
            };

        ul = $(&quot;&lt;ul/&gt;&quot;);
        ul.css({
            &quot;margin&quot;: &quot;0px 0px 0px 10px&quot;,
            &quot;padding-left&quot;: &quot;0px&quot;
        });
        $(this.legend).append(ul);

        for (i = 0, l = this.infos.length; i &lt; l; i++) {
            li = $(&quot;&lt;li&gt;&quot; + &quot;&lt;span style=\&quot;color: black\&quot;&gt;&quot; + this.infos[i][0].name + &quot;&lt;/span&gt;&quot; + &quot;&lt;/li&gt;&quot;);
            li.css({&quot;list-style-type&quot;: &quot;square&quot;,
                    &quot;list-style-position&quot;: &quot;inside&quot;,
                    //&quot;background&quot;: &quot;gray&quot;,
                    &quot;color&quot;: color(i),
                    //&quot;display&quot;: &quot;inline&quot;,
                    &quot;white-space&quot;: &quot;nowrap&quot;,
                    &quot;padding-left&quot;: 5
                    });
            ul.append(li);
            li.mouseenter({&quot;index&quot;: i, &quot;stream&quot;: this}, hoverIn);
            li.mouseleave({&quot;index&quot;: i, &quot;stream&quot;: this}, hoverOut);
            legends.push(li);
        }
        this.legends = legends;
        //paper.setSize(width, top + lineHeight + m[2]);

        //height and margin
        leftHeight = $(this.rightContainer).height();
        legendHeight = $(this.legend).height();
        $(this.leftContainer).css({
            &quot;height&quot;: leftHeight
        });
        if (leftHeight &gt; legendHeight) {
            $(this.legend).css({&quot;margin-top&quot;: leftHeight - legendHeight - 30});
        } else {
            $(this.legend).css({&quot;margin-top&quot;: 0});
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_createNavi">
    createNavi
  </h3>
  

  <p>创建导航</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.createNavi()</td> 
      <td></td>
      <td>createNavi</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.createNavi = function () {
        if (!this.userConfig.more) {
            $(this.navi).css({
                &quot;visibility&quot;: &quot;hidden&quot;,
                &quot;position&quot;: &quot;absolute&quot;
            });
        } else {
            $(this.navi).css({&quot;visibility&quot;: &quot;visible&quot;,
                &quot;position&quot;: &quot;relative&quot;
            });
        }
        var i,
            span;
        $(this.naviTrace).empty();
        for (i = 0; i &lt;= this.level; i++) {
            $(this.naviTrace).append($(&quot;&lt;span&gt; &gt; &lt;/span&gt;&quot;));
            span = document.createElement(&quot;span&quot;);
            span.data = {level: i};
            span = $(span)
                .html(i === 0 ? &quot;第1层&quot; : &quot;第&quot; + (i + 1) + &quot;层&quot;)
                .appendTo($(this.naviTrace));
            if (i !== this.level) {
                span.css({&quot;cursor&quot;: &quot;pointer&quot;, &quot;color&quot;: &quot;#1E90FF&quot;})
                    .addClass(&quot;navi&quot;);
                    //.data(&quot;level&quot;, i);
            }
        }
        if (this.level &gt; 0) {
            this.naviBack.style.visibility = &quot;visible&quot;;
        } else {
            this.naviBack.style.visibility = &quot;hidden&quot;;
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_getMaxPercentage">
    getMaxPercentage
  </h3>
  

  <p>获取最大百分比</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.getMaxPercentage()</td> 
      <td></td>
      <td>getMaxPercentage</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.getMaxPercentage = function () {
        this.maxPercentage = this.allInfos.reduce(function (a, b, i, array) {
            return [{total: a[0].total + b[0].total}];
        })[0].total;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_createPercentage">
    createPercentage
  </h3>
  

  <p>生成百分比数据</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.createPercentage()</td> 
      <td></td>
      <td>createPercentage</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.createPercentage = function () {
        if (!this.userConfig.more) {
            return;
        }
        var conf = this.defaults;
        var maxY = this.getMaxY(),
            y;
        if (this.firstRender) {
            this.getMaxPercentage();
        }

        maxY /= this.maxPercentage;
        y = maxY &gt; 0.1
            ? (1 - maxY) * conf.height + conf.fontSize * 2 / 3
            : (1 - maxY) * conf.height - conf.fontSize * 2 / 3;

        if (this.firstRender) {
            this.percentageRect = this.percentagePaper.rect(0, (1 - maxY) * conf.height,
                    conf.margin[3], maxY * conf.height)
                .attr({&quot;fill&quot;: &quot;#f4f4f4&quot;, &quot;stroke&quot;: &quot;#aaa&quot;, &quot;stroke-width&quot;: 0.5});
            this.percentageText = this.percentagePaper.text(conf.margin[3] / 2, y,
                    Math.round(maxY * 100) + &quot;%&quot;)
                .attr({&quot;text-anchor&quot;: &quot;middle&quot;});
        } else {
            this.percentageRect.animate({&quot;y&quot;: (1 - maxY) * conf.height, &quot;height&quot;: maxY * conf.height}, 750);
            this.percentageText.attr({&quot;text&quot;: Math.round(maxY * 100) + &quot;%&quot;})
                .animate({&quot;y&quot;: y}, 750);
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_createStreamPaths">
    createStreamPaths
  </h3>
  

  <p>生成Stream路径</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.createStreamPaths()</td> 
      <td></td>
      <td>createStreamPaths</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.createStreamPaths = function () {
        var canvas = this.canvas,
            paths = [],
            labels = [],
            area = this.generateArea(),
            color = this.getColor({mode: this.defaults.colorMode}),
            conf = this.defaults,
            i,
            l,
            _area,
            pathLegend,
            path,
            pathLegendMouseOver = function () {
                var path = this.path,
                    anchorIndex = path.index;
                path.paths.forEach(function (d, i, array) {
                    if (i !== anchorIndex) {
                        array[i].attr({&quot;fill&quot;: d3.interpolateRgb.apply(null, [array[i].color, &quot;#fff&quot;])(0.5)});
                    }
                });
				this.style.backgroundColor = d3.interpolateRgb.apply(null, [path.color, &quot;#fff&quot;])(0.8);
            },
            
            pathLegendMouseOut = function () {
                var path = this.path,
                    anchorIndex = path.index;
                path.paths.forEach(function (d, i, array) {
                    if (i !== anchorIndex) {
                        array[i].attr({&quot;fill&quot;: array[i].color});
                    }
                });
				path.legend.style.backgroundColor = path.color;
            },

            getLabelLocation = function (locArray, el) {
                var x = 0,
                    y = 0,
                    i;
                var ratioMargin = 0.15;
                var index = 0;
                var max = 0;
                var box = el.getBBox();
                var xInterval;
                var minTop, maxBottom;
                var showLabel = true;
                var loc;
                var height;

                xInterval = Math.ceil(box.width / (locArray[1].x - locArray[0].x) / 2);
                if (xInterval === 0) {
                    xInterval = 1;
                }

                locArray.forEach(function (d, i, array) {
                    var m = Math.max(ratioMargin * array.length, xInterval);
                    if (i &gt;= m &amp;&amp; i &lt;= array.length - m) {
                        if (d.y &gt; max) {
                            minTop = d.y0 - d.y;
                            maxBottom = d.y0;
                            max = d.y;
                            index = i;
                        }
                    }
                });
                for (i = index - xInterval; i &lt;= index + xInterval; i++) {
                    if (i &lt; 0 || i &gt;= locArray.length) {
                        height = 0;
                        showLabel = false;
                        break;
                        //return;
                    }
                    loc = locArray[i];
                    //top's y is small
                    if (loc.y0 - loc.y &gt; minTop) {
                        minTop = loc.y0 - loc.y;
                    }
                    if (loc.y0 &lt; maxBottom) {
                        maxBottom = loc.y0;
                    }
                }

                if (showLabel &amp;&amp; maxBottom - minTop &gt;= box.height * 0.8) {
                    x = locArray[index].x;
                    y = (minTop + maxBottom) / 2;
                    //y = locArray[index].y0 - locArray[index].y / 2;
                } else {
                    showLabel = false;
                }

                return {x: x,
                        y: y,
                        showLabel: showLabel};
            },

            getLabelLocation_old2 = function (locArray, conf) {
                var x, y, height = 0, i;
                var indexMargin = Math.min(conf.indexMargin, Math.floor((locArray.length - 1) / 2));
                var ratioMargin = 0.15;
                var index = indexMargin;
                var max = 0;
                if (locArray.length &gt;= conf.indexMargin * 2 + 1) {
                    locArray.forEach(function (d, i, array) {
                        var m = Math.max(indexMargin, ratioMargin * array.length);
                        if (i &gt;= m &amp;&amp; i &lt;= array.length - m) {
                            if (d.y &gt; max) {
                                max = d.y;
                                index = i;
                            }
                        }
                    });
                    x = locArray[index].x;
                    y = locArray[index].y0 - locArray[index].y / 2;
                    for (i = index - indexMargin; i &lt;= index + indexMargin; i++) {
                        height += locArray[i].y;
                    }
                    height = height / (2 * indexMargin + 1);
                } else {
                    x = -100;
                    y = -100;
                    height = 0;
                }

                return {
                    x: x,
                    y: y,
                    height: height
                };
            };

        canvas.rect(0, 0, conf.width, conf.height)
            .attr({&quot;stroke&quot;: &quot;none&quot;,
                    &quot;fill&quot;: &quot;#e0e0e0&quot;});
        for (i = 0, l = this.source.length; i &lt; l; i++) {
            _area = area(this.pathSource[i]);
            path = canvas.path(_area).attr({fill: color(i),
                    stroke: color(i),
                    &quot;stroke-width&quot;: 1,
                    &quot;stroke-linejoin&quot;: &quot;round&quot;,
                    &quot;transform&quot;:  &quot;t0,&quot; + conf.topInterval
                    });
            path.color = color(i);
            path.index = i;
            path.info = this.infos[i];

            path.paths = paths;
            path.topTrans = conf.topInterval;
            path.bottomTrans = conf.bottomInterval;
            path.stream = this;

            path.node.streamPath = path;
            path.node.setAttribute(&quot;class&quot;, &quot;streamPath rvml&quot;);

            //path.click(pathClick);
            //path.mouseover(pathMouseOver);
            //path.mouseout(pathMouseOut);
            //path.mousemove(pathMouseMove);

            paths[path.index] = path;
            //brush canvas background
        }

        //label
        for (i = 0, l = paths.length; i &lt; l; i++) {
            path = paths[i];
            path.label = this.canvas.text(0, 0,
                    conf.pathLabel ?
                    path.info[0].name + &quot; &quot; + (Math.round(path.info[0].total * 10000) / 100) + &quot;%&quot; : &quot;&quot;)
                .attr({&quot;text-anchor&quot;: &quot;middle&quot;,
                        &quot;fill&quot;: &quot;white&quot;,
                        &quot;font-size&quot;: conf.fontSize,
                        &quot;font-family&quot;: &quot;微软雅黑&quot;});
            path.labelLoc = getLabelLocation(this.pathSource[i], path.label);

            if (path.labelLoc.showLabel) {
                path.label.attr({&quot;x&quot;: path.labelLoc.x,
                                &quot;y&quot;: path.labelLoc.y});
            } else {
                path.label.attr({&quot;opacity&quot;: 0});
                //path.labelOpacity = 1;
            }
            if (i === 0 &amp;&amp; path.info[0].id === -1) {
                path.attr({&quot;cursor&quot;: &quot;pointer&quot;});
                path.label.attr({&quot;cursor&quot;: &quot;pointer&quot;});
            }
            labels.push(path.label);
            path.label.node.setAttribute(&quot;class&quot;, &quot;streamPath rvml&quot;);
        }

        $(this.canvas.canvas).unbind();

        var mouseenter = function (e) {
                var stream = e.data.stream;
                stream.indicatorLine.attr({&quot;stroke&quot;: &quot;#000&quot;});
                stream.highlightLine.attr({&quot;stroke&quot;: &quot;white&quot;});
                stream.floatTag.css({&quot;visibility&quot; : &quot;visible&quot;});
                stream.axisPopText.show();
                stream.axisPopBubble.show();
            };

        var mouseleave = function (e) {
                var stream = e.data.stream,
                    circle;
                stream.indicatorLine.attr({&quot;stroke&quot;: &quot;none&quot;});
                stream.highlightLine.attr({&quot;stroke&quot;: &quot;none&quot;});
                stream.floatTag.css({&quot;visibility&quot; : &quot;hidden&quot;});
                stream.axisPopText.hide();
                stream.axisPopBubble.hide();
                //recover prepath;
                if (typeof stream.prePath !== 'undefined') {
                    stream.prePath.attr({&quot;opacity&quot;: 1, &quot;stroke-width&quot;: 1});
                    // set legend
                    //circle = stream.legends[stream.prePath.index].circle;
                    //circle.attr({&quot;r&quot;: circle.data(&quot;r0&quot;), &quot;opacity&quot;: 1});
                    stream.legends[stream.prePath.index].css({&quot;background&quot;: &quot;white&quot;});
                    stream.prePath = undefined;
                }
            };

        var click = function (e) {
                var stream = e.data.stream,
                    position;
                if (typeof stream.prePath !== 'undefined'
                        &amp;&amp; stream.prePath.info[0].id === -1) {
    
                    //hidden
                    stream.indicatorLine.attr({&quot;stroke&quot;: &quot;none&quot;});
                    stream.highlightLine.attr({&quot;stroke&quot;: &quot;none&quot;});
                    stream.floatTag.css({&quot;visibility&quot; : &quot;hidden&quot;});

                    stream.level += 1;

                    //set cover
                    position = $(this).parent().position();
                    $(stream.cover).css({left: position.left + &quot;px&quot;,
                                        top: position.top + &quot;px&quot;});
                    stream.cover.style.visibility = &quot;visible&quot;;
                    stream.coverMouse = {x: e.pageX, y: e.pageY};

                    //redraw
                    stream.getLevelSource();
                    stream.reRender();

                    //hidden
                    stream.indicatorLine.attr({&quot;stroke&quot;: &quot;none&quot;});
                    stream.highlightLine.attr({&quot;stroke&quot;: &quot;none&quot;});
                    stream.floatTag.css({&quot;visibility&quot; : &quot;hidden&quot;});

                    stream.paths.forEach(function (d, i, array) {
                        d.attr({transform: &quot;s1,0.001,0,&quot; + stream.defaults.height});
                        d.label.hide();
                        d.animate({transform: &quot;t0,0&quot;}, 750, &quot;linear&quot;, function () {
                            stream.cover.style.visibility = &quot;hidden&quot;;
                            if (typeof stream.coverMouse !== 'undefined') {
                                stream.indicatorLine.attr({&quot;stroke&quot;: &quot;#000&quot;});
                                stream.highlightLine.attr({&quot;stroke&quot;: &quot;white&quot;});
                                stream.floatTag.css({&quot;visibility&quot; : &quot;visible&quot;});
                                $(stream.canvas.canvas).trigger(&quot;mousemove&quot;,
                                    [stream.coverMouse.x, stream.coverMouse.y]);
                                stream.coverMouse = undefined;
                            }
                            //if (d.labelOpacity === 1)
                            if (d.labelLoc.showLabel) {
                                d.label.show();
                            }
                        });
                    });
                }
            };

        var mousemove = function (e, pageX, pageY) {
                var stream = e.data.stream;
                var offset = $(this).parent().offset();
                var position = $(this).parent().position();
                //var offset = $(this).offset();
                var x = (e.pageX || pageX) - offset.left,
                    y = (e.pageY || pageY) - offset.top;
                var floatTag,
                    floatTagWidth,
                    floatTagHeight,
					mouseToFloatTag = {x: 20, y: 20};
                var path,
                    pathSource = stream.pathSource,
                    pathSourceP,
                    pathIndex,
                    circle;
                var i, l;
                var xIdx = Math.floor((x / (stream.defaults.width
                                / (stream.source[0].length - 1) / 2) + 1) / 2);
                var pathsourceP,
                    lineX;

                //get path
                path = undefined;
                pathSource = stream.pathSource;
                for (i = 0, l = pathSource.length; i &lt; l; i++) {
                    if (y &gt;= pathSource[i][xIdx].y0 - pathSource[i][xIdx].y &amp;&amp; y &lt;= pathSource[i][xIdx].y0) {
                        path = stream.paths[i];
                        pathIndex = i;
                        break;
                    }
                }
                if (typeof path === 'undefined') {
                    return;
                }


                //recover prepath;
                if (typeof stream.prePath !== 'undefined') {
                    stream.prePath.attr({&quot;opacity&quot;: 1, &quot;stroke-width&quot;: 1});
                    // set legend
                    stream.legends[stream.prePath.index].css({&quot;background&quot;: &quot;white&quot;});
                }
                //change new path;
                stream.prePath = path;
                path.attr({&quot;opacity&quot;: 0.5, &quot;stroke-width&quot;: 0});

                // set legend
                stream.legends[stream.prePath.index].css({&quot;background&quot;: &quot;#dddddd&quot;});

                //set indicator and highlight line
                lineX = stream.defaults.width * xIdx / (stream.source[0].length - 1);
                pathSourceP = pathSource[pathSource.length - 1][xIdx];
                stream.indicatorLine.attr({path: &quot;M&quot; + lineX
                        + &quot; &quot; + (pathSourceP.y0 - pathSourceP.y)
                        + &quot;V&quot; + pathSource[0][xIdx].y0});

                pathSourceP = pathSource[pathIndex][xIdx];
                stream.highlightLine.attr({path: &quot;M&quot; + lineX
                        + &quot; &quot; + (pathSourceP.y0 - pathSourceP.y)
                        + &quot;V&quot; + pathSourceP.y0});
                if (pathIndex === 0 &amp;&amp; path.info[0].id === -1) {
                    stream.highlightLine.attr({&quot;cursor&quot;: &quot;pointer&quot;});
                } else {
                    stream.highlightLine.attr({&quot;cursor&quot;: &quot;auto&quot;});
                }

                floatTag = stream.floatTag;
                floatTag.html(path.info[xIdx].tip);

                //axis pop bubble
                stream.axisPopText.attr({&quot;text&quot;: stream.date[xIdx + stream.timeRange[0]]})
                    .transform(&quot;t&quot; + (lineX + stream.defaults.margin[3]) + &quot;,0&quot;);
                stream.axisPopBubble.transform(&quot;t&quot; + (lineX + stream.defaults.margin[3]) + &quot;,0&quot;);

                //customevent;
                if (stream.defaults.customEventHandle.mousemove) {
                    stream.defaults.customEventHandle.mousemove.call(stream,
                            {&quot;timeIndex&quot;: xIdx, &quot;pathIndex&quot;: pathIndex});
                }
            };
        var $canvas = $(this.canvas.canvas);
        $canvas.bind(&quot;mouseenter&quot;, {&quot;stream&quot;: this}, mouseenter);
        $canvas.bind(&quot;mouseleave&quot;, {&quot;stream&quot;: this}, mouseleave);
        $canvas.bind(&quot;click&quot;, {&quot;stream&quot;: this}, click);
        $canvas.bind(&quot;mousemove&quot;, {&quot;stream&quot;: this}, mousemove);

        this.paths = paths;
        this.labels = labels;
        this.indicatorLine = canvas.path(&quot;M0 &quot; + conf.topInterval + &quot;V&quot; + (conf.height - conf.bottomInterval))
            .attr({stroke: &quot;none&quot;, &quot;stroke-width&quot;: 1, &quot;stroke-dasharray&quot;: &quot;- &quot;});
        this.highlightLine = canvas.path(&quot;M0 &quot; + conf.topInterval + &quot;V&quot; + (conf.height - conf.bottomInterval))
            .attr({stroke: &quot;none&quot;, &quot;stroke-width&quot;: 2});
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_createAxis">
    createAxis
  </h3>
  

  <p>创建坐标轴</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.createAxis()</td> 
      <td></td>
      <td>createAxis</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.createAxis = function () {
        //all date strings' format are same, string length are same
        var conf = this.defaults,
            date = this.date.slice(this.timeRange[0], this.timeRange[1] + 1),
            left = conf.margin[3],
            //left = conf.margin[3] + conf.legendWidth,
            right = conf.totalWidth - conf.margin[1] - conf.legendWidth,
            tempWord,
            tickNumber,
            getPopPath = function (El) {
                //down pop
                var x = 0,
                    y = 0,
                    size = 4,
                    cw = 23,
                    bb = {height: 8};
                if (El) {
                    bb = El.getBBox();
                    bb.height *= 0.6;
                    cw = bb.width / 2 - size;
                }
                return [
                    'M', x, y,
                    'l', size, size, cw, 0,
                    'a', size, size, 0, 0, 1, size, size,
                    'l', 0, bb.height,
                    'a', size, size, 0, 0, 1, -size, size,
                    'l', -(size * 2 + cw * 2), 0,
                    'a', size, size, 0, 0, 1, -size, -size,
                    'l', 0, -bb.height,
                    'a', size, size, 0, 0, 1, size, -size,
                    'l', cw, 0,
                    'z'
                ].join(',');
            };

        this.dateScale = d3.scale.linear()
            .domain([0, date.length - 1])
            .range([left, right]);

        tempWord = this.axisPaper.text(0, 0, date[0]);
        tickNumber = Math.floor((right - left)
                / tempWord.getBBox().width / 2) + 1;
        tempWord.remove();
        //tickNumber = 4;

        Axis().scale(this.dateScale)
            .ticks(tickNumber)
            //.ticks(conf.axisTickNumber)
            .tickSize(6, 3, 3)
            .tickAttr({&quot;stroke&quot;: &quot;none&quot;})
            .minorTickAttr({&quot;stroke&quot;: &quot;none&quot;})
            .domainAttr({&quot;stroke&quot;: &quot;none&quot;})
            //.tickTextAttr({&quot;font-size&quot;: conf.fontSize})
            .tickFormat(function (d) {
                return date[d] || &quot;&quot;;
            })(this.axisPaper);//.attr({transform: &quot;t0,&quot; + (conf.height - 0)});

        this.axisPopText = this.axisPaper.text(0, 11, date[0])
            .attr({ &quot;text-anchor&quot;: &quot;middle&quot;,
                    &quot;fill&quot;: &quot;#fff&quot;,
                    //&quot;font-size&quot;: conf.fontSize,
                    &quot;transform&quot;: &quot;t&quot; + left + &quot;,0&quot;})
            .hide();
        this.axisPopBubble = this.axisPaper.path(getPopPath(this.axisPopText))
            .attr({ &quot;fill&quot;: &quot;#000&quot;,
                    //&quot;opacity&quot;: 0,
                    &quot;transform&quot;: &quot;t&quot; + left + &quot;,0&quot;})
            .toBack()
            .hide();
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_getMaxY">
    getMaxY
  </h3>
  

  <p>获取纵轴最大值</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.getMaxY()</td> 
      <td></td>
      <td>getMaxY</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.getMaxY = function () {
        return d3.max(this.source, function (d) {
            return d3.max(d, function (d) {
                return d.y0 + d.y;
            });
        });
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_mapPathSource">
    mapPathSource
  </h3>
  

  <p>映射路径源</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.mapPathSource()</td> 
      <td></td>
      <td>mapPathSource</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.mapPathSource = function () {
        var conf = this.defaults,
            maxX = this.source[0].length - 1,//this.digitData[0].length - 1,
            maxY = this.getMaxY(),
            width = conf.width,
            height = conf.height - conf.topInterval - conf.bottomInterval;
        var i, j, l, l2, s, ps;
        this.pathSource = [];
        for (i = 0, l = this.source.length; i &lt; l; i++) {
            this.pathSource[i] = [];
            for (j = 0, l2 = this.source[0].length; j &lt; l2; j++) {
                s = this.source[i][j];
                ps = this.pathSource[i][j] = {};
                ps.x = s.x * width / maxX;
                ps.y0 = height - s.y0 * height / maxY;
                ps.y = s.y * height / maxY;
            }
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_generateArea">
    generateArea
  </h3>
  

  <p>生成区域</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.generateArea()</td> 
      <td></td>
      <td>generateArea</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.generateArea = function () {
        this.mapPathSource();
        return d3.svg.area().x(function (d) {
            return d.x;
        }).y0(function (d) {
            return d.y0;
        }).y1(function (d) {
            return d.y0 - d.y;
        });
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_clearCanvas">
    clearCanvas
  </h3>
  

  <p>清除画布</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.clearCanvas()</td> 
      <td></td>
      <td>clearCanvas</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.clearCanvas = function () {
        this.canvas.clear();
        this.legend.innerHTML = &quot;&quot;;
        this.axisPaper.clear();
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_reRender">
    reRender
  </h3>
  

  <p>重绘图表</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.reRender()</td> 
      <td></td>
      <td>reRender</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.reRender = function (options) {
        this.setOptions(options);
        this.clearCanvas();
        this.layout();
        this.generatePaths();
        this.canAnimate = true;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_render">
    render
  </h3>
  

  <p>绘制图表</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.render()</td> 
      <td></td>
      <td>render</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.render = function (options) {
        this.firstRender = true;
        this.setOptions(options);
        this.clearCanvas();
        this.layout();
        this.generatePaths();
        this.firstRender = false;
        this.canAnimate = true;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_resize">
    resize
  </h3>
  

  <p>重设图表</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.resize()</td> 
      <td></td>
      <td>resize</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.resize = function (options) {
        var conf = this.defaults;

        if (!options.width &amp;&amp; !options.height) {
            throw new Error(&quot;no width and height input&quot;);
        } else if (options.width &amp;&amp; !options.height) {
            if (conf.autoHeight) {
                this.setOptions({&quot;width&quot;: options.width});
            } else {
                this.setOptions({&quot;width&quot;: options.width, &quot;height&quot;: conf.height});
            }
        } else if (!options.width &amp;&amp; options.height) {
            this.setOptions({&quot;width&quot;: conf.totalWidth, &quot;height&quot;: options.height});
        } else {
            this.setOptions({&quot;width&quot;: options.width, &quot;height&quot;: options.height});
        }

        this.node.innerHTML = &quot;&quot;;
        this.createCanvas();
        this.reRender();
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_on">
    on
  </h3>
  

  <p>侦听自定义事件</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.on()</td> 
      <td></td>
      <td>on</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>eventName(String)</td>
      <td colspan="2">事件名</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>callback(Function)</td>
      <td colspan="2">事件回调函数</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.on = function (eventName, callback) {
        if (typeof this.defaults.customEventHandle[eventName] !== 'undefined') {
            this.defaults.customEventHandle[eventName] = callback;
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_animate">
    animate
  </h3>
  

  <p>设置动画</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.animate()</td> 
      <td></td>
      <td>animate</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>options(Object)</td>
      <td colspan="2">选项对象</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>timeDuration(Number)</td>
      <td colspan="2">时间</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.animate = function (options, timeDuration) {
        //must after render if new Source has been set;
        if (!this.canAnimate) {
            throw new Error(&quot;Function animate must be called after render if new Source has been set.&quot;);
        }
        var time = 0,
            area,
            color,
            i,
            l;
        if (arguments.length &gt; 1) {
            time = timeDuration;
        }

        //this.setOptions(options);
        if (options.offset || options.order) {
            this.source = this.remapSource(this.digitData);
            this.layout();
        }
        area = this.generateArea();
        color = this.getColor();
        for (i = 0, l = this.source.length; i &lt; l; i++) {
            var _area = area(this.source[i]);
            var anim = Raphael.animation({path: _area, fill: color(i)}, time);
            this.paths[i].animate(anim);
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/tree" class="api">
  <h2>charts/tree: API索引</h2>
  <ul class="indexs">
  
    <li>
      <a href="#_Tree">Tree</a>
    </li>

    <li>
      <a href="#Tree_dimension">dimension</a>
    </li>

    <li>
      <a href="#_render">render</a>
    </li>

  </ul>
  <hr />

  

  <table class="table">
  

  
  </table>
  
  
  <h3 id="_Tree">
    Tree
  </h3>
  

  <p>Tree的构造函数</p>

<h2>Examples</h2>

<div class="highlight"><pre lang="">var tree = new Tree("container");
tree.setSource(source);
tree.render();
</pre></div>

<h2>Options</h2>

<ul>
<li><code>width</code>: 画布的宽度</li>
<li><code>height</code>: 画布的高度</li>
</ul>

  <table class="table">
  
    <tr>
      <td>声明</td>
      <td>Tree</td> 
      <td></td>
      <td>Tree</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>var Tree = DataV.extend(DataV.Chart, {
        initialize: function (node, options) {
            this.type = &quot;Tree&quot;;
            this.node = this.checkContainer(node);

            this.addlink = {};

            // Properties
            this.treeDepth = 0;
            this.font = {};

            // Canvas
            this.defaults.width = 750;
            this.defaults.height = 760;
            this.defaults.deep = 180;
            this.defaults.radius = 15;

            this.setOptions(options);
            this.createCanvas();
        }
    });</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="Tree_dimension">
    dimension
  </h3>
  

  <p>饼图纬度描述</p>

  <table class="table">
  
    <tr>
      <td>属性</td>
      <td>Tree.dimension</td> 
      <td>Tree</td>
      <td>dimension</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Tree.dimension = {};</code></pre></td>
    </tr>
  
  </table>
  
  

  <p>ID标签</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Tree.dimension.id = {
        type: &quot;string&quot;,
        required: true
    };</code></pre></td>
    </tr>
  
  </table>
  
  

  <p>父ID标签</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Tree.dimension.pid = {
        type: &quot;string&quot;,
        required: true
    };

    Tree.prototype.hierarchyTableToJson = function (table) {
        if (table[0][0] === &quot;ID&quot;) {
            table = table.slice(1);
        }

        var rootID;
        var hierarchy = {};
        var addlink = {}; //for multi-fathernode
        // var ids = _.pluck(table, 0);
        // var pids = _.pluck(table, 3);
        // var roots = _.difference(pids, ids);
        // if (roots.length === 0) {
        //     throw new Error(&quot;root node is empty&quot;);
        // } else if (roots.length &gt; 1) {
        //     throw new Error(&quot;root nodes are too many&quot;);
        // }

        table.forEach(function (d, i) {
            if (d[0] === &quot;&quot;) {
                throw new Error(&quot;ID can not be empty(line:&quot; + (i + 1) + &quot;).&quot;);
            }
            if (!d[3]) {
                if (rootID) {
                    throw new Error(&quot;2 or more lines have an empty parentID(line:&quot; + (i + 1) + &quot;).&quot;);
                } else {
                    rootID = d[0];
                }
            }
            if (hierarchy[d[0]]) {
                throw new Error(&quot;2 or more lines have same ID: &quot; + d[0] + &quot;(line:&quot; + (i + 1) + &quot;).&quot;);
            }

            var value = &quot;&quot;;
            var j, length;
            if (d.length &gt; 4) {
                for (j = 4, length = d.length; j &lt; length; j++) {
                    if (j &lt; length - 1) {
                        value = value + d[j] + &quot;,&quot;;
                    } else {
                        value = value + d[j];
                    }
                }
            }
            hierarchy[d[0]] = {name: d[1], size: d[2], child: [], id: d[0], value: value};
        });
        if (!rootID) {
            throw new Error(&quot;No root node defined.&quot;);
        }
        table.forEach(function (d, i) {
            if (d[3]) {
                var record;
                var ids = d[3].split(',');
                if (ids.length === 1) {
                    record = hierarchy[d[3]];
                    record.child.push(d[0]);
                } else {
                    record = hierarchy[ids[0]];
                    record.child.push(d[0]);
                    addlink[d[0]] = {child: [], path: [], pnode: []};

                    var j, length;
                    for (j = 1, length = ids.length; j &lt; length;  j++) {
                        addlink[d[0]].child.push(ids[j]);
                    }
                }
                if (!record) {
                    throw new Error(&quot;Can not find parent with ID &quot; + d[3] + &quot;(line:&quot; + (i + 1) + &quot;).&quot;);
                }
            }
        });

        this.addlink = addlink;

        var recurse = function (rootID) {
            var record = hierarchy[rootID];
            if (record.child.length === 0) {
                if (isNaN(parseFloat(record.size))) {
                    throw new Error(&quot;Leaf node's size is not a number(ID:&quot; + (rootID + 1) + &quot;).&quot;);
                } else {
                    return {
                        name: record.name,
                        size: record.size,
                        num: record.id,
                        children: null,
                        draw: false,
                        value: record.value
                    };
                }
            } else {
                var childNode = [];
                record.child.forEach(function (d) {
                    childNode.push(recurse(d));
                });
                return {name: record.name, children: childNode, num: record.id, draw: false, value: record.value};
            }
        };

        return recurse(rootID);
    };

    Tree.prototype.setSource = function (source) {
        var conf = this.defaults;

        this.rawData = this.hierarchyTableToJson(source);
        this.source = this.remapSource(source);
        
        this.source.x0 = conf.width / 2;
        this.source.y0 = conf.radius * 10;

        this.source.children.forEach(function collapse(d) {
            if (d.children) {
                // d._children = d.children;
                // d._children.forEach(collapse);
                // d.children = null;
                d._children = null;
                d.children.forEach(collapse);
            }
        });
    };

    Tree.prototype.remapSource = function (data) {
        return this.hierarchyTableToJson(data);
        // return data;
    };

    Tree.prototype.layout = function () {
        var conf = this.defaults;
        var tree = d3.layout.tree()
            .size([conf.width, conf.height]);

        this.nodesData = tree.nodes(this.source);

        var treedepth = 0;
        var id = 0;

        this.nodesData.forEach(function (d) {
            if (d.depth &gt; treedepth) {
                treedepth = d.depth;
            }
        });

        this.treeDepth = treedepth;
        conf.deep = conf.height / (treedepth + 1);

        this.nodesData.forEach(function (d) {
            d.y = conf.radius * 3 + d.depth * conf.deep;
            d.id = id;
            id++;
        });
    };

    Tree.prototype.getColor = function () {
        var colorMatrix = DataV.getColor();
        var color;
        if (colorMatrix.length &gt; 1 &amp;&amp; colorMatrix[0].length &gt; 1) {
            color = [colorMatrix[0][0], colorMatrix[1][0]];
        } else {
            color = colorMatrix[0];
        }

        return DataV.gradientColor(color, &quot;special&quot;);
    };

    Tree.prototype.createCanvas = function () {
        var conf = this.defaults;
        this.canvas = new Raphael(this.node, conf.width, conf.height);
        this.node.style.position = &quot;relative&quot;;
        this.floatTag = DataV.FloatTag()(this.node);

        this.floatTag.css({&quot;visibility&quot;: &quot;hidden&quot;});

        this.DOMNode = $(this.canvas.canvas);
        var that = this;
        this.DOMNode.click(function (event) {
            that.trigger(&quot;click&quot;, event);
        });
        this.DOMNode.dblclick(function (event) {
            that.trigger(&quot;dblclick&quot;, event);
        });

        var mousewheel = document.all ? &quot;mousewheel&quot; : &quot;DOMMouseScroll&quot;;
        this.DOMNode.bind(mousewheel, function (event) {
            that.trigger(&quot;mousewheel&quot;, event);
        });

        this.DOMNode.bind(&quot;contextmenu&quot;, function (event) {
            that.trigger(&quot;contextmenu&quot;, event);
        });

        this.DOMNode.delegate(&quot;circle&quot;, &quot;click&quot;, function (event) {
            that.trigger(&quot;circle_click&quot;, event);
        });

        this.DOMNode.delegate(&quot;circle&quot;, &quot;mouseover&quot;, function (event) {
            that.trigger(&quot;circle_mouseover&quot;, event);
        });

        this.DOMNode.delegate(&quot;circle&quot;, &quot;mouseout&quot;, function (event) {
            that.trigger(&quot;circle_mouseout&quot;, event);
        });
    };

    Tree.prototype.zoom = function (d) {
        var multiple = d || 2;
        var conf = this.defaults;
        conf.width = conf.width * multiple;

        if (conf.height &lt;= this.treeDepth * conf.deep) {
            conf.height = conf.height * multiple;
        }

        //this.createCanvas();
        this.canvas.setSize(conf.width, conf.height);
        this.canvas.setViewBox(0, 0, conf.width, 800);
        this.defaults = conf;

        this.render();
    };


    Tree.prototype.getLinkPath = function (fx, fy, tx, ty) {
        var conf = this.defaults;

        var c1x = fx;
        var c1y = fy + (ty - fy) / 2;
        var c2x = tx;
        var c2y = ty - (ty - fy) / 2;

        var link_path = [[&quot;M&quot;, fx, fy + conf.radius],
            [&quot;C&quot;, c1x, c1y, c2x, c2y, tx, ty - conf.radius]];

        return link_path;
    };

    Tree.prototype.generatePaths = function () {
        var canvas = this.canvas;
        var source = this.source;
        var conf = this.defaults;
        var radius = conf.radius;
        //canvas.clear();
        var color = this.getColor();
        // var font = this.getFont();
        var font_family = '微软雅黑';
        var font_size = 8;
        var treedepth = this.treeDepth;
        var nodesData = this.nodesData;

        var n = 0;

        var addlink = this.addlink;
        var node;
        var num = 0;

        var nodes = canvas.set();
        var path = [];
        var textpath = [];
        
        var tree = this;
        var nodeupdate = function () {
            tree.update(this.data(&quot;num&quot;));
        };

        $(this.node).append(this.floatTag);

        var i, nodesLength;
        for (i = 0, nodesLength = nodesData.length; i &lt; nodesLength;  i++) {
            var d =  nodesData[i];
            var parent = d.parent;

            if (addlink[d.num]) {
                var j, k, childLength;
                for (j = 0, childLength = addlink[d.num].child.length; j &lt; childLength; j++) {
                    for (k = 0; k &lt; nodesLength;  k++) {
                        if (nodesData[k].num === addlink[d.num].child[j]) {
                            addlink[d.num].pnode[j] = k;
                            addlink[d.num].path[j] = canvas.path()
                                .attr({ stroke:  &quot;#939598&quot;, &quot;stroke-width&quot;: 0.5});
                        }
                    }
                }
            }

            var startX;
            var startY;

            if (parent &amp;&amp; d.draw) {
                startX = parent.x;
                startY = parent.y;
            } else {
                startX = d.x;
                startY = d.y;
            }
            if (parent) {
                path.push(canvas.path().attr({stroke:  &quot;#939598&quot;, &quot;stroke-width&quot;: 0.5}));
            }

            nodes.push(
                canvas.circle(startX, startY, radius)
                    .attr({fill: color(d.depth / treedepth),
                        stroke: &quot;#ffffff&quot;,
                        &quot;stroke-width&quot;: 1,
                        &quot;fill-opacity&quot;: 0.4,
                        &quot;data&quot;: 12})
                    .data(&quot;num&quot;, i)
                    .animate({cx: d.x, cy: d.y}, 500, &quot;backOut&quot;)
            );

            if (d.children || d._children) {
                nodes[i].click(nodeupdate);
            }

            if (d._children) {
                nodes[i].attr({
                    stroke: color(d.depth / treedepth),
                    &quot;stroke-width&quot;: radius,
                    &quot;stroke-opacity&quot;: 0.4,
                    &quot;fill-opacity&quot;: 1,
                    &quot;r&quot;: radius / 2
                });
            }

            if (d.children) {
                textpath.push(canvas.text(d.x, d.y - radius - 7, d.name).attr({'font-size': 12}));
            } else {
                textpath.push(canvas.text(d.x, d.y + radius + 7, d.name).attr({'font-size': 12}));
            }
        }

        // var back = function(pid, x, y){
        //     s.forEach(function (d, i){
        //         if (d.data('pid') == pid){
        //             d.animate({cx: x, cy: y}, 200, &quot;backOut&quot;);
        //             if (nodes[i].children)
        //             back(d.data('num'), d.attr('cx'), d.attr('cy'));
        //         }
        //     });
        // };

        // s.forEach(function(d, i) {
        //     d.click(function(){
        //         if (nodes[i].children)
        //         back(d.data('num'), d.attr('cx'), d.attr('cy'));
        //         tree.update(d.data(&quot;num&quot;));
        //     });
        // });
        var floatTag = this.floatTag;
        nodes.forEach(function (d, i) {
            $(d.node).attr('value', nodesData[i].value);
            var textY = textpath[i].attr('y');
            var thisradius = d.attr('r');
            var thisstrokewidth = d.attr('stroke-width');
            d.mouseover(function () {
                if (!nodesData[i]._children) {
                    this.animate({r: thisradius + 2, &quot;fill-opacity&quot;: 0.75}, 100);
                } else {
                    this.animate({r: thisradius + 2, &quot;stroke-opacity&quot;: 0.75}, 100);
                }

                textpath[i].attr({'font-size': 20});

                if (i &gt; 0) {
                    if (!nodesData[i].children) {
                        textpath[i].animate({'y': textY + 12}, 100, &quot;backOut&quot;);
                    } else {
                        textpath[i].animate({'y': textY - 12}, 100, &quot;backOut&quot;);
                    }
                }

                var getFline = function (node, num) {
                    var parent = node.parent;
                    if (parent) {
                        path[node.id - 1].attr({&quot;stroke-width&quot;: 4, &quot;stroke-opacity&quot;: num});
                        if ( num &gt; 0.5) {
                            num = num - 0.1;
                        }
                        getFline(parent, num);
                    }
                };

                getFline(nodesData[i], 0.9);

                var thisparent = nodesData[i].parent;
                var j, textpathLength;
                for (j = 0, textpathLength = textpath.length; j &lt; textpathLength; j++) {
                    var parent = nodesData[j].parent;
                    if (parent === thisparent &amp;&amp; j !== i) {
                        textpath[j].animate({'fill-opacity': 0.4});
                    }
                }

                console.log(nodesData[i]);
                floatTag.html('&lt;div style = &quot;text-align: center;margin:auto;color:#ffffff&quot;&gt;' + nodesData[i].name + '&lt;/div&gt;');
                floatTag.css({&quot;visibility&quot; : &quot;visible&quot;});
            })
            .mouseout(function () {
                floatTag.css({&quot;visibility&quot; : &quot;hidden&quot;});
                if (!nodesData[i]._children) {
                    this.animate({r: thisradius, &quot;fill-opacity&quot;: 0.4}, 100);
                } else {
                    this.animate({r: thisradius, &quot;stroke-width&quot;: thisstrokewidth, &quot;stroke-opacity&quot;: 0.4}, 100);
                }
                textpath[i].attr({'font-size': 12});
                textpath[i].animate({'y': textY}, 100, &quot;backOut&quot;);

                var getFline = function (node) {
                    var parent = node.parent;
                    if (parent) {
                        path[node.id - 1].attr({&quot;stroke-width&quot;: 0.5, &quot;stroke-opacity&quot;: 1});
                        getFline(parent);
                    }
                };
                getFline(nodesData[i]);

                var thisparent = nodesData[i].parent;
                var j, textpathLength;
                for (j = 0, textpathLength = textpath.length; j &lt; textpathLength; j++) {
                    var parent = nodesData[j].parent;
                    if (parent === thisparent &amp;&amp; j !== i) {
                        textpath[j].animate({'fill-opacity': 1});
                    }
                }
            });
        });

        nodes.onAnimation(function () {
            var pathNum = 0;
            var i, nodeslength;
            
            for (i = 1, nodeslength = nodes.length; i &lt; nodeslength;  i++) {
                var d = nodes[i];
                var node = nodesData[i];
                var parent = node.parent;
                
                path[pathNum]
                    .attr({path: tree.getLinkPath(parent.x, parent.y, d.attr(&quot;cx&quot;), d.attr(&quot;cy&quot;))});
                    
                pathNum++;

                if (addlink[node.num]) {
                    var j, k, linkchildLength, nodesLength;
                    for (j = 0, linkchildLength = addlink[node.num].child.length; j &lt; linkchildLength; j++) {
                        for (k = 0, nodesLength = nodesData.length; k &lt; nodesLength;  k++) {
                            var anparent = nodesData[k];
                            if (anparent.num === addlink[node.num].child[j]) {
                                var link_path = tree.getLinkPath(anparent.x, anparent.y, d.attr(&quot;cx&quot;), d.attr(&quot;cy&quot;));
                                addlink[node.num].path[j].attr({path: link_path});
                            }
                        }
                    }
                }
            }
        });

        this.nodes = nodes;
        this.path = path;
        this.textpath = textpath;
    };
    
    Tree.prototype.update = function (i) {
        var source = this.source;
        var conf = this.defaults;

        source.children.forEach(function clearDraw(d) {
            d.draw = false;
            if (d.children) {
                d.children.forEach(clearDraw);
            }
        });

        source.children.forEach(function find(d) {
            if (d.id === i) {
                if (d.children) {
                    d._children = d.children;
                    d.children = null;
                } else {
                    d.children = d._children;
                    if (d.children) {
                        d.children.forEach(function drawn(child) {
                            child.draw = true;
                            if (child.children) {
                                child.children.forEach(drawn);
                            }
                        });
                    }
                    d._children = null;
                }
            } else {
                if (d.children) {
                    d.children.forEach(find);
                }
            }
        });
        this.source = source;
        this.source.x0 = conf.width / 2;
        this.source.y0 = conf.radius * 2;
        this.render();
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_render">
    render
  </h3>
  

  <p>渲染Tree</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Tree.prototype.render()</td> 
      <td></td>
      <td>render</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Tree.prototype.render = function (options) {
        this.canvas.clear();
        this.setOptions(options);
        this.layout();
        // var st2 = new Date().getTime();
        this.generatePaths();
        // var et = new Date().getTime();
        //this.canvas.renderfix();
    };

    return Tree;
});</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/treemap" class="api">
  <h2>charts/treemap: API索引</h2>
  <ul class="indexs">
  
    <li>
      <a href="#_Treemap">Treemap</a>
    </li>

    <li>
      <a href="#_createCanvas">createCanvas</a>
    </li>

    <li>
      <a href="#_getColor">getColor</a>
    </li>

    <li>
      <a href="#_setSource">setSource</a>
    </li>

    <li>
      <a href="#_clearCanvas">clearCanvas</a>
    </li>

    <li>
      <a href="#_reRender">reRender</a>
    </li>

    <li>
      <a href="#_render">render</a>
    </li>

    <li>
      <a href="#_on">on</a>
    </li>

  </ul>
  <hr />

  

  <table class="table">
  

  
  </table>
  
  
  <h3 id="_Treemap">
    Treemap
  </h3>
  

  <p>Treemap构造函数，继承自Chart</p>

<h2>Options</h2>

<ul>
<li><code>width</code> 数字，图片宽度，默认为750，表示图片高750px</li>
<li><code>height</code> 数字，图片高度，默认为500</li>
<li><code>showBackTag</code> 布尔值，回退操作导航条是否显示，默认为 true, 显示；设为false则不显示</li>
<li><code>backHeight</code> 数字，回退操作导航条宽度，默认为20</li>
<li><code>level1BorderWidth</code> 数字，一级方框的边框宽度，默认为1(1px),不建议修改</li>
<li><code>level2BorderWidth</code> 数字，二级方框的边框宽度，默认为1(1px)，不建议修改</li>
<li><code>fontSizeRatio</code> 数字，表示图中文字大小。默认为1.0(1倍), 若设为2.0，字体大小会加倍;</li>
<li><code>customEvent</code> 函数对象，其中有4个自定义函数。<code>leafNodeClick</code> 函数，表示点击叶子节点的事件响应，默认为空函数; <code>hoverIn</code> 函数，表示鼠标移进方框的事件响应，默认为空函数; <code>hoverOut</code> 函数，表示鼠标移出方框的事件响应，默认为空函数; <code>mouseover</code> 函数，表示在方框内移动鼠标的事件响应，默认为设置浮框的内容，可以替换它修改浮框内容; 这些函数可以在创建对象或setOption()时一起设置，也可以通过on函数单独设置。</li>
</ul>

<h2>Examples</h2>

<p>create treemap in a dom node with id "chart", width is 500; height is 600px;</p>

<div class="highlight"><pre lang="">var treemap = new Treemap("chart", {"width": 500, "height": 600});
</pre></div>

  <table class="table">
  
    <tr>
      <td>声明</td>
      <td>Treemap</td> 
      <td></td>
      <td>Treemap</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>node(Object)</td>
      <td colspan="2">The dom node or dom node Id</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>options(Object)</td>
      <td colspan="2">JSON object for determin treemap style</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>var Treemap = DataV.extend(DataV.Chart, {
        initialize: function (node, options) {
            this.type = &quot;Treemap&quot;;
            this.node = this.checkContainer(node);

            // Properties
            this.selectedTreeNodes = [];//array of nodes on the path from root to recent node
            this.treeNodeJson = {};
            this.level_ = 2;

            this.floatTag;//浮框对象，这是个可操作的对象。

            // Canvas
            this.defaults.width = 750;
            this.defaults.height = 500;

            this.defaults.showBackTag = true;
            this.defaults.backHeight = 20;

            this.defaults.level1BorderWidth = 1;
            this.defaults.level2BorderWidth = 1;
            this.defaults.fontSizeRatio = 1.0;

            //event
            this.defaults.customEvent = {
                leafNodeClick : function () {},
                hoverIn : function () {},
                hoverOut : function () {},
                mousemove : function () {
                    var jqNode = this.jqNode,
                        treemap = jqNode.treemap,
                        floatTag = treemap.floatTag;
    
                    //set floatTag content
                    floatTag.html('&lt;div style = &quot;text-align: center;margin:auto;color:' +
                        //+ jqNode.color
                        '&quot;#fff&quot;&gt;' + jqNode.treemapNode.name + '&lt;/div&gt;' +
                        '&lt;div style = &quot;text-align: center; margin:auto;color:' +
                        '&quot;#fff&quot;&gt;' + jqNode.treemapNode.value + '&lt;/div&gt;');
                }
            };

            this.setOptions(options);
            this.createCanvas();
        }
    });</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_createCanvas">
    createCanvas
  </h3>
  

  <p>Create dom node relate to treemap</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Treemap.prototype.createCanvas()</td> 
      <td></td>
      <td>createCanvas</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Treemap.prototype.createCanvas = function () {
        var conf = this.defaults,
            floatStyle,
            container = this.node,
            backStyle,
            canvasStyle;

        this.node.style.position = &quot;relative&quot;;

        if (conf.showBackTag) {
            this.backTag = document.createElement(&quot;div&quot;);
            backStyle = this.backTag.style;
            backStyle.width = conf.width + &quot;px&quot;;
            backStyle.height = conf.backHeight + &quot;px&quot;;
            backStyle.paddingLeft = &quot;5px&quot;;
            container.appendChild(this.backTag);
        }

        this.canvas = document.createElement(&quot;div&quot;);
        canvasStyle = this.canvas.style;
        canvasStyle.position = &quot;relative&quot;;
        canvasStyle.width = conf.width + &quot;px&quot;;
        canvasStyle.height = conf.height + &quot;px&quot;;
        container.appendChild(this.canvas);

        this.floatTag = DataV.FloatTag()(this.canvas);

        this.floatTag.css({&quot;visibility&quot;: &quot;hidden&quot;});

        //this.canvas.appendChild(this.floatTag);
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_getColor">
    getColor
  </h3>
  

  <p>获取颜色</p>

<h2>Examples</h2>

<div class="highlight"><pre lang="">// 获取第二种颜色的渐变色。
{mode: "gradient", index: 1}
// 获取最深的离散色。
{mode: "random", ratio: 0}
// 获取最浅的离散色。
{mode: "random", ratio: 1}
// 获取适中的离散色。
{mode: "random", ratio: 0.5}
</pre></div>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Treemap.prototype.getColor()</td> 
      <td></td>
      <td>getColor</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>colorJson(Object)</td>
      <td colspan="2">Way to get color from color theme matrix</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>Array</td>
      <td colspan="2">返回颜色数组</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Treemap.prototype.getColor = function (colorJson) {
        var colorMatrix = DataV.getColor();
        var color;
        var colorStyle = colorJson || {};
        var colorMode = colorStyle.mode || 'default';
        var i, l;

        switch (colorMode) {
        case &quot;multiColorGradient&quot;:
            //color = d3.interpolateHsl.apply(null, [&quot;red&quot;, &quot;blue&quot;]);
            //color = d3.interpolateHsl.apply(null, [colorMatrix[0][0], colorMatrix[colorMatrix.length - 1][0]]);
            //color = DataV.gradientColor([&quot;#f5f5f6&quot;, &quot;#f6f5f5&quot;], 'special');
            //color = DataV.gradientColor([colorMatrix[0][0], colorMatrix[colorMatrix.length - 1][0]], 'special');
            //color = d3.interpolateRgb.apply(null, [colorMatrix[0][0], colorMatrix[colorMatrix.length - 1][0]]);

            color = (function () {
                var c = [];
                colorMatrix.forEach(function (d, i) {
                    c.push(d[0]);
                });
                return function (ratio) {
                    var index = (c.length - 1) * ratio;
                    var floor = Math.floor(index);
                    var ceil = Math.ceil(index);
                    if (floor === ceil) {
                        return c[floor];
                    } else {
                        return d3.interpolateRgb.apply(null, [c[floor], c[ceil]])(index - floor);
                    }
                };
            }());
            //color = d3.interpolateRgb.apply(null, [&quot;green&quot;, &quot;purple&quot;]);
            break;
        case &quot;gradient&quot;:
            var index = colorJson.index || 0;
            index = index &lt; 0 ? 0 : Math.min(index, colorMatrix.length - 1);
            color = d3.interpolateRgb.apply(null, [colorMatrix[index][0], colorMatrix[index][1]]);
            break;
        case &quot;random&quot;:
        case &quot;default&quot;:
            var ratio = colorStyle.ratio || 0;
            if (ratio &lt; 0) { ratio = 0; }
            if (ratio &gt; 1) { ratio = 1; }
            var colorArray = [];
            for (i = 0, l = colorMatrix.length; i &lt; l; i++) {
                var colorFunc = d3.interpolateRgb.apply(null, [colorMatrix[i][0], colorMatrix[i][1]]);
                colorArray.push(colorFunc(ratio));
            }
            color = d3.scale.ordinal().range(colorArray);
            break;
        }
        return color;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setSource">
    setSource
  </h3>
  

  <p>设置数据源</p>

<h2>Examples</h2>

<p>treemap数据输入的格式可以是二维数组。例如下面的数组表示2000年4个季度的天数。<br />第1季度下面还列出了1-3月的天数。数组的第一行为四个固定的字符串"ID"，"name"，"size"和"parentID"。<br />四列数据分别表示层次数据集中各结点的ID，名称，大小和父节点ID。叶子节点必须有大小，根结点不能有父节点ID。各结点的ID、名称必须要有。</p>

<div class="highlight"><pre lang=""> [
     ["ID", "name", "size", "parentID"],
     [0, "2000",  ,  ],
     [1, "season1",  , 0],
     [2, "January", 31, 1],
     [3, "February", 29, 1],
     [4, "Match", 31, 1],
     [5, "season2", 91, 0],
     [6, "season3", 92, 0],
     [7, "season4", 92, 0]
 ]
</pre></div>

<p>数据还可以是json格式。每个结点都有<code>name</code>，如果是父节点则还有<code>children</code>，如果为叶节点则还有<code>size</code>。以上数组数据对应的json数据如下：</p>

<div class="highlight"><pre lang="">{
  "name": "2000",
  "children": [
     {
      "name": "season1",
      "children": [
           {"name": "January", "size": 31},
           {"name": "February", "size": 29},
           {"name": "Match", "size": 31}
         ]
     },
     {"name": "season2", "size": 91},
     {"name": "season3", "size": 92},
     {"name": "season4", "size": 92},
  ]
}
</pre></div>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Treemap.prototype.setSource()</td> 
      <td></td>
      <td>setSource</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>source(Array,Object)</td>
      <td colspan="2">json or 2-d array</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Treemap.prototype.setSource = function (source) {
        if (source instanceof Array) {
            this.rawData = this._arrayToJson(source);
        } else {
            this.rawData = source;
        }
        this.source = this._remapSource(this.rawData);
        this.selectedTreeNodes = [this.source[0]];
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_clearCanvas">
    clearCanvas
  </h3>
  

  <p>清除画布</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Treemap.prototype.clearCanvas()</td> 
      <td></td>
      <td>clearCanvas</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Treemap.prototype.clearCanvas = function () {
        var canvas = this.canvas;
        canvas.innerHTML = &quot;&quot;;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_reRender">
    reRender
  </h3>
  

  <p>计算布局，并重新渲染图表</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Treemap.prototype.reRender()</td> 
      <td></td>
      <td>reRender</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Treemap.prototype.reRender = function (options) {
        this.clearCanvas();
        this.setOptions(options);
        this._create2LevelJson(this.selectedTreeNodes[this.selectedTreeNodes.length - 1]);
        this.layout();
        this._setBackTag();
        this.generatePaths();
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_render">
    render
  </h3>
  

  <p>计算布局位置，并渲染图表</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Treemap.prototype.render()</td> 
      <td></td>
      <td>render</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Treemap.prototype.render = function (options) {
        this.clearCanvas();
        this.setOptions(options);
        this._getNodeTheme = undefined;
        this.selectedTreeNodes = this.selectedTreeNodes.slice(0, 1);
        this._create2LevelJson(this.selectedTreeNodes[0]);
        this.layout();
        this._setBackTag();
        this.generatePaths();
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_on">
    on
  </h3>
  

  <p>设置自定义事件</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Treemap.prototype.on()</td> 
      <td></td>
      <td>on</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Treemap.prototype.on = function (eventName, callback) {
        if ($.inArray(eventName, [&quot;leafNodeClick&quot;, &quot;hoverIn&quot;, &quot;hoverOut&quot;, &quot;mousemove&quot;]) !== -1) {
            this.defaults.customEvent[eventName] = callback;
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
    </div>
  </div>
</div>
      <footer class="footer">
        <div class="container">
          <p class="pull-right">
            <a href="#">Back to top</a>
          </p>
          <p>此文档通过doxmate生成。主题借鉴Bootstrap API文档风格，注解基于<a href="https://github.com/visionmedia/dox">Dox</a>。欢迎关注doxmate作者<a href="http://weibo.com/shyvo" target="_blank">@朴灵</a></p>
          <ul class="footer-links">
            <li><a href="https://github.com/visionmedia/dox">Dox主页</a></li>
            <li><a href="http://html5ify.com/doxmate">Doxmate主页</a></li>
            <li><a href="https://github.com/JacksonTian/doxmate/issues?state=open">提交bug</a></li>
          </ul>
      </div>
    </footer>
    <script>
      $(function() {
        $('pre').addClass('prettyprint');
        $('td pre').removeClass('prettyprint');
        prettyPrint();
        var $window = $(window);
        $('.bs-docs-sidenav').affix({
          offset: {
            top: function () {
              return $window.width() <= 980 ? 290 : 210
            },
            bottom: 270
          }
        });
        $(".content").find('h1, h2, h3, h4, h5, h6').each(function () {
          var node = $(this);
          if (!node.attr("id")) {
            node.attr("id", "index_" + node.text());
          }
          node.css("paddingTop", 40);
        });
      });
    </script>
  
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-17170593-4']);
      _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  
  </body>
</html>