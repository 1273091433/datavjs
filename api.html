<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>datavjs Documentation</title>
    <meta name="keywords" content="DataV" />
    <meta name="description" content="DataV.js is a JavaScript library for data visualization" />
    <script src="assets/prettify.js"></script>
    <script src="assets/jquery-1.8.2.min.js"></script>
    <script src="bootstrap/js/bootstrap.min.js"></script>
    <link rel="stylesheet" type="text/css" href="bootstrap/css/bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="assets/base.css" />
  </head>
  <body>
    <div class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="brand" href="./index.html">datavjs</a>
          <div class="nav-collapse collapse">
            <ul class="nav">
              <li>
                <a href="./api.html">API Docs</a>
              </li>
              
              <li>
                <a href="./butterfly.html">butterfly</a>
              </li>
              
              <li>
                <a href="./changelog.html">changelog</a>
              </li>
              
              <li>
                <a href="./CodingStyle.html">CodingStyle</a>
              </li>
              
              <li>
                <a href="./force文档.html">force文档</a>
              </li>
              
              <li>
                <a href="./note.html">note</a>
              </li>
              
              <li>
                <a href="./stream文档.html">stream文档</a>
              </li>
              
              <li>
                <a href="./treemap文档.html">treemap文档</a>
              </li>
              
            </ul>
          </div>
        </div>
      </div>
    </div>
    <header class="jumbotron subhead">
      <div class="container">
        <h1>datavjs <small>Version: 0.0.1 By @DataV</small></h1>
        <p class="lead">
          DataV.js is a JavaScript library for data visualization
        </p>
      </div>
    </header>
<div class="container content">
  <div class="row">
    <div class="span3 bs-docs-sidebar">
      <ul class="nav nav-list bs-docs-sidenav affix">

  <li>
    <a href="#api_datav"><i class="icon-chevron-right"></i>datav</a>
  </li>

  <li>
    <a href="#api_charts/axis"><i class="icon-chevron-right"></i>charts/axis</a>
  </li>

  <li>
    <a href="#api_charts/brush"><i class="icon-chevron-right"></i>charts/brush</a>
  </li>

  <li>
    <a href="#api_charts/bubble"><i class="icon-chevron-right"></i>charts/bubble</a>
  </li>

  <li>
    <a href="#api_charts/bullet"><i class="icon-chevron-right"></i>charts/bullet</a>
  </li>

  <li>
    <a href="#api_charts/bundle"><i class="icon-chevron-right"></i>charts/bundle</a>
  </li>

  <li>
    <a href="#api_charts/chord"><i class="icon-chevron-right"></i>charts/chord</a>
  </li>

  <li>
    <a href="#api_charts/flow"><i class="icon-chevron-right"></i>charts/flow</a>
  </li>

  <li>
    <a href="#api_charts/force"><i class="icon-chevron-right"></i>charts/force</a>
  </li>

  <li>
    <a href="#api_charts/matrix"><i class="icon-chevron-right"></i>charts/matrix</a>
  </li>

  <li>
    <a href="#api_charts/parallel"><i class="icon-chevron-right"></i>charts/parallel</a>
  </li>

  <li>
    <a href="#api_charts/pie"><i class="icon-chevron-right"></i>charts/pie</a>
  </li>

  <li>
    <a href="#api_charts/scatterplotMatrix"><i class="icon-chevron-right"></i>charts/scatterplotMatrix</a>
  </li>

  <li>
    <a href="#api_charts/stream"><i class="icon-chevron-right"></i>charts/stream</a>
  </li>

  <li>
    <a href="#api_charts/tree"><i class="icon-chevron-right"></i>charts/tree</a>
  </li>

  <li>
    <a href="#api_charts/treemap"><i class="icon-chevron-right"></i>charts/treemap</a>
  </li>

</ul>

    </div>
    <div class="span9">
      
        <section id="api_datav" class="api">
  <h2>datav: API索引</h2>
  <ul class="indexs">
  
    <li>
      <a href="#_DataV">DataV</a>
    </li>

    <li>
      <a href="#DataV_version">version</a>
    </li>

    <li>
      <a href="#DataV_Themes">Themes</a>
    </li>

    <li>
      <a href="#DataV_changeTheme">changeTheme</a>
    </li>

    <li>
      <a href="#DataV_getColor">getColor</a>
    </li>

    <li>
      <a href="#DataV_getDiscreteColor">getDiscreteColor</a>
    </li>

    <li>
      <a href="#DataV_gradientColor">gradientColor</a>
    </li>

    <li>
      <a href="#DataV_json">json</a>
    </li>

    <li>
      <a href="#DataV_csv">csv</a>
    </li>

    <li>
      <a href="#DataV_isNumeric">isNumeric</a>
    </li>

    <li>
      <a href="#_Chart">Chart</a>
    </li>

    <li>
      <a href="#_getType">getType</a>
    </li>

    <li>
      <a href="#_checkContainer">checkContainer</a>
    </li>

    <li>
      <a href="#_setOptions">setOptions</a>
    </li>

    <li>
      <a href="#DataV_extend">extend</a>
    </li>

    <li>
      <a href="#DataV_FloatTag">FloatTag</a>
    </li>

  </ul>
  <hr />

  

  <table class="table">
  

  
  </table>
  
  
  <h3 id="_DataV">
    DataV
  </h3>
  

  <p>DataV全局命名空间对象定义</p>

  <table class="table">
  
    <tr>
      <td>函数</td>
      <td>DataV()</td> 
      <td></td>
      <td>DataV</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>var DataV = function () {};</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="DataV_version">
    version
  </h3>
  

  <p>版本号</p>

  <table class="table">
  
    <tr>
      <td>属性</td>
      <td>DataV.version</td> 
      <td>DataV</td>
      <td>version</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>DataV.version = &quot;0.0.1&quot;;</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="DataV_Themes">
    Themes
  </h3>
  

  <p>全局主题对象</p>

  <table class="table">
  
    <tr>
      <td>属性</td>
      <td>DataV.Themes</td> 
      <td>DataV</td>
      <td>Themes</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>DataV.Themes = {};</code></pre></td>
    </tr>
  
  </table>
  
  

  <p>默认主题</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>DataV.Themes[&quot;default&quot;] = DataV.Themes.theme0 = {
         COLOR_ARGS: [
            [&quot;#3dc6f4&quot;, &quot;#8ce3ff&quot;],
            [&quot;#214fd9&quot;, &quot;#7396ff&quot;],
            [&quot;#4f21d9&quot;, &quot;#9673ff&quot;],
            [&quot;#c43df2&quot;, &quot;#e38cff&quot;],
            [&quot;#d8214f&quot;, &quot;#ff7396&quot;],
            [&quot;#f3c53c&quot;, &quot;#ffe38c&quot;]
        ]

        //FONT_ARGS: {HEADER_FAMILY:&quot;微软雅黑&quot;, HEADER_SIZE: 20, PAGE_FAMILY:&quot;微软雅黑&quot;, PAGE_SIZE: 5}
    };</code></pre></td>
    </tr>
  
  </table>
  
  

  <p>主题1</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>DataV.Themes.theme1 = {
        COLOR_ARGS: [
            [&quot;#e72e8b&quot;, &quot;#ff7fbf&quot;],
            [&quot;#d94f21&quot;, &quot;#ff9673&quot;],
            [&quot;#f3c53c&quot;, &quot;#ffe38c&quot;],
            [&quot;#8be62f&quot;, &quot;#bfff7f&quot;],
            [&quot;#14cc14&quot;, &quot;#66ff66&quot;],
            [&quot;#2fe68a&quot;, &quot;#7fffc0&quot;]
        ]

        //FONT_ARGS: {HEADER_FAMILY:&quot;微软雅黑&quot;, HEADER_SIZE: 20, PAGE_FAMILY:&quot;微软雅黑&quot;, PAGE_SIZE: 5}
    };</code></pre></td>
    </tr>
  
  </table>
  
  

  <p>主题2</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>DataV.Themes.theme2 = {
        COLOR_ARGS: [
            [&quot;#2f8ae7&quot;, &quot;#7fc0ff&quot;],
            [&quot;#8a2ee7&quot;, &quot;#bf7fff&quot;],
            [&quot;#f33dc6&quot;, &quot;#ff8ce3&quot;],
            [&quot;#8be62f&quot;, &quot;#bfff7f&quot;],
            [&quot;#14cc14&quot;, &quot;#66ff66&quot;],
            [&quot;#2fe68a&quot;, &quot;#7fffc0&quot;]
        ]
        //FONT_ARGS: {HEADER_FAMILY:&quot;微软雅黑&quot;, HEADER_SIZE: 20, PAGE_FAMILY:&quot;微软雅黑&quot;, PAGE_SIZE: 10}
    };
    DataV.Themes.theme3 = {
        COLOR_ARGS: [
            [&quot;#2f8ae7&quot;, &quot;#896DA3&quot;],
            [&quot;#8e34df&quot;, &quot;#FFADA6&quot;],
            [&quot;#f738c0&quot;, &quot;#65FCFC&quot;],
            [&quot;#84e653&quot;, &quot;#555566&quot;],
            [&quot;#0cc53e&quot;, &quot;#db3f7c&quot;],
            [&quot;#00e793s&quot;, &quot;#db3f7c&quot;]
        ]
        //FONT_ARGS: {HEADER_FAMILY:&quot;微软雅黑&quot;, HEADER_SIZE: 20, PAGE_FAMILY:&quot;微软雅黑&quot;, PAGE_SIZE: 10}
    };
    DataV.Themes.theme4 = {
        COLOR_ARGS: [
            [&quot;#d94f21&quot;, &quot;#7a88d1&quot;],
            [&quot;#579ce2&quot;, &quot;#87bdf4&quot;],
            [&quot;#3bb4df&quot;, &quot;#7fd1ef&quot;],
            [&quot;#a380ff&quot;, &quot;#baa0ff&quot;],
            [&quot;#a164c5&quot;, &quot;#c28fe1&quot;],
            [&quot;#d93a92&quot;, &quot;#ec74b6&quot;],
            [&quot;#b82377&quot;, &quot;#d569a7&quot;],
            [&quot;#bb3ca3&quot;, &quot;#d381c2&quot;],
            [&quot;#da2d57&quot;, &quot;#ec6b8a&quot;],
            [&quot;#4ca716&quot;, &quot;#4ca716&quot;],
            [&quot;#5b63c2&quot;, &quot;#8e93d7&quot;],
            [&quot;#15a9a3&quot;, &quot;#4ecac5&quot;],
            [&quot;#a9ab48&quot;, &quot;#e8c670&quot;],
            [&quot;#2aa5f5&quot;, &quot;#73c4fa&quot;],
            [&quot;#f67e10&quot;, &quot;#feb648&quot;],
            [&quot;#1faa77&quot;, &quot;#62c8a2&quot;],
            [&quot;#eb4f20&quot;, &quot;#f58563&quot;],
            [&quot;#ffc000&quot;, &quot;#ffd659&quot;],
            [&quot;#f16ebc&quot;, &quot;#f6a1d3&quot;],
            [&quot;#d23457&quot;, &quot;#e27b92&quot;]
        ]
    };

    DataV.Themes.current = &quot;default&quot;;
    DataV.Themes._currentTheme = null;</code></pre></td>
    </tr>
  
  </table>
  
  

  <p>获取当前主题的属性</p>

  <table class="table">
  

    <tr>
      <td>返回</td>
      <td>Mix</td>
      <td colspan="2">返回当前主题的属性值</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>DataV.Themes.get = function (key) {
        if (!DataV.Themes._currentTheme) {
            DataV.Themes._currentTheme = DataV.Themes[DataV.Themes.current];
        }
        return DataV.Themes._currentTheme[key] || DataV.Themes[&quot;default&quot;][key];
    };</code></pre></td>
    </tr>
  
  </table>
  
  

  <p>设置自定义主题</p>

  <table class="table">
  

    <tr>
      <td>参数</td>
      <td>themeName(String)</td>
      <td colspan="2">主题名称</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>theme(Object)</td>
      <td colspan="2">主题对象json, contain attribute &quot;COLOR_ARGS&quot;, theme.COLOR_ARGS is a 2-d array;</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>DataV.Themes.set = function (themeName, theme) {
        if (arguments.length &lt; 2) {
            throw new Error(&quot;Arguments format error. should be: (themsName, theme)&quot;);
        } else if (typeof theme !== &quot;object&quot;) {
            throw new Error(&quot;second argument theme should be a json object&quot;);
        } else if (!theme[&quot;COLOR_ARGS&quot;]) {
            throw new Error(&quot;theme.COLOR_ARGS needed&quot;);
        } else if (!theme[&quot;COLOR_ARGS&quot;] instanceof Array) {
            throw new Error(&quot;theme.COLOR_ARGS should be an array&quot;);
        } else if (!(theme[&quot;COLOR_ARGS&quot;][0] instanceof Array)) {
            throw new Error(&quot;theme.COLOR_ARGS[0] should be an array&quot;);
        }
        DataV.Themes[themeName] = theme;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="DataV_changeTheme">
    changeTheme
  </h3>
  

  <p>切换当前主题</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>DataV.changeTheme()</td> 
      <td>DataV</td>
      <td>changeTheme</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>themeName(String)</td>
      <td colspan="2">主题名称</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>Boolean</td>
      <td colspan="2">返回是否切换成功</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>DataV.changeTheme = function (themeName) {
        var ret = DataV.Themes[themeName];
        if (ret) {
            DataV.Themes.current = themeName;
            DataV.Themes._currentTheme = null;
        }
        return !!ret;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="DataV_getColor">
    getColor
  </h3>
  

  <p>获取当前主题的颜色配置</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>DataV.getColor()</td> 
      <td>DataV</td>
      <td>getColor</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>Array</td>
      <td colspan="2">颜色参数列表</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>DataV.getColor = function () {
        var theme = DataV.Themes;
        var color = theme.get(&quot;COLOR_ARGS&quot;);
        return color;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="DataV_getDiscreteColor">
    getDiscreteColor
  </h3>
  

  <p>根据当前主题的颜色配置方案，获取生成离散颜色的函数</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>DataV.getDiscreteColor()</td> 
      <td>DataV</td>
      <td>getDiscreteColor</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>Function</td>
      <td colspan="2">离散函数</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>DataV.getDiscreteColor = function () {
        var color = DataV.getColor();
        if (!_.isArray(color)) {
            throw new Error(&quot;The color should be Array&quot;);
        }
        var colorCount = color.length;
        var gotColor = [];

        if (_.isArray(color[0])) {
            for (var i = 0; i &lt; colorLineCount ; i++) {
                getColor.push(color[i][0]);
            }
        } else {
            gotColor = color;
        }

        return function (num) {
            var thisColor = gotColor;
            var thisColorCount = colorCount;

            return thisColor[num % thisolorCount];
        };
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="DataV_gradientColor">
    gradientColor
  </h3>
  

  <p>获取渐变颜色，用于生成渐变效果</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>DataV.gradientColor()</td> 
      <td>DataV</td>
      <td>gradientColor</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>color(Array)</td>
      <td colspan="2">颜色数组</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>method(String)</td>
      <td colspan="2">生成渐变色的方法，默认值为normal。如果为normal将采用D3的interpolateRgb算法，如果为special，则用Rapheal的HSB算法</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>Function</td>
      <td colspan="2">返回生成算法</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>DataV.gradientColor = function (color, method) {
        if (!_.isArray(color)) {
            throw new Error(&quot;The color should be Array&quot;);
        }

        var startColor = color[0];
        var colorColor;
        var colorCount = color.length;

        var hsb;
        if (colorCount === 1) {
            hsb = Raphael.color(color[0]);
            endColor = Raphael.hsb(hsb.h / 360, (hsb.s -30) / 100, 1);
        } else {
            endColor = color[colorCount - 1];
        }

        method = method || &quot;normal &quot;;

        if (method === &quot;special&quot;) {
            return function (num) {
                var startHSB = Raphael.color(startColor);
                var endHSB = Raphael.color(endColor);
                var startH = startHSB.h * 360;
                var endH = endHSB.h * 360;
                var startNum = startHSB.h * 20;
                var endNum = endHSB.h * 20;

                var dH;
                var dNum;
                if (startNum &gt;= endNum) {
                    dH = 360 - startH + endH;
                    dNum = colorCount - startNum + endNum;
                } else {
                    dH = endH - startH;
                    dNum = endNum - startNum;
                }
                
                var h = (startH + dH * num) / 360;
                var s = (70 + Math.abs(4 - (startNum + dNum * num) % 8) * 5) / 100;
                var b = (100 - Math.abs(4 - (startNum + dNum * num) % 8) * 5) / 100;

                return Raphael.hsb(h, s, b);
            };
        } else {
            return d3.interpolateRgb.apply(null, [startColor, endColor]);
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="DataV_json">
    json
  </h3>
  

  <p>请求一个JSON文件</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>DataV.json()</td> 
      <td>DataV</td>
      <td>json</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>url(String)</td>
      <td colspan="2">JSON文件地址</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>callback(Function)</td>
      <td colspan="2">回调函数</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>DataV.json = function (url, callback) {
        d3.json(url, callback);
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="DataV_csv">
    csv
  </h3>
  

  <p>请求一个CSV文件，并解析</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>DataV.csv()</td> 
      <td>DataV</td>
      <td>csv</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>url(String)</td>
      <td colspan="2">CSV文件地址</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>callback(Function)</td>
      <td colspan="2">回调函数，得到解析后的结果</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>DataV.csv = function (url, callback) {
        d3.text(url, &quot;text/csv&quot;, function (text) {
            callback(text &amp;&amp; d3.csv.parseRows(text));
        });
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="DataV_isNumeric">
    isNumeric
  </h3>
  

  <p>判断输入是否是数字</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>DataV.isNumeric()</td> 
      <td>DataV</td>
      <td>isNumeric</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>obj(Mix)</td>
      <td colspan="2">输入内容</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>Boolean</td>
      <td colspan="2">返回输入是否是数字</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>DataV.isNumeric = function (obj) {
        return !isNaN(parseFloat(obj)) &amp;&amp; isFinite(obj);
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_Chart">
    Chart
  </h3>
  

  <p>所有Chart的源定义</p>

<h2>Examples</h2>

<div class="highlight"><pre lang="">   var Stream = DataV.extend(DataV.Chart, {
       initialize: function () {
           this.type = "Stream";
       },
       clearCanvas: function () {
           this.canvas.clear();
           this.legend.innerHTML = "";
       }
   });
</pre></div>

  <table class="table">
  
    <tr>
      <td>函数</td>
      <td>Chart()</td> 
      <td></td>
      <td>Chart</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>var Chart = function () {
        this.type = &quot;Chart&quot;;
        this.defaults = {};
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_getType">
    getType
  </h3>
  

  <p>返回当前Chart的类型</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Chart.prototype.getType()</td> 
      <td></td>
      <td>getType</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>String</td>
      <td colspan="2">Chart类型</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Chart.prototype.getType = function () {
        return this.type;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_checkContainer">
    checkContainer
  </h3>
  

  <p>If node is string, return Element by string as id. If node is Dom element, return node.</p>

<h2>Examples</h2>

<div class="highlight"><pre lang="">chart.checkContainer("id");
chart.checkContainer(document.getElementById("id"));
chart.checkContainer($("#id"));
</pre></div>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Chart.prototype.checkContainer()</td> 
      <td></td>
      <td>checkContainer</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>node(Mix)</td>
      <td colspan="2">The element Id or Dom element</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>Object</td>
      <td colspan="2">返回找到的DOM节点</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Chart.prototype.checkContainer = function (node) {
        if (!node) {
            throw new Error(&quot;Please specify which node to render.&quot;);
        }
        if (typeof node === &quot;string&quot;) {
            return document.getElementById(node);
        } else if (node.nodeName) {//DOM-element
            return node;
        } else if (node instanceof jQuery &amp;&amp; node.size() &gt; 0) {
            return node[0];
        }
        throw new Error(&quot;Please specify which node to render.&quot;);
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setOptions">
    setOptions
  </h3>
  

  <p>设置自定义选项</p>

<h2>Examples</h2>

<p>Set width 500px, height 600px;</p>

<div class="highlight"><pre lang="">{"width": 500, "height": 600}
</pre></div>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Chart.prototype.setOptions()</td> 
      <td></td>
      <td>setOptions</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>options(Object)</td>
      <td colspan="2">自定义选项对象</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>Object</td>
      <td colspan="2">覆盖后的图表选项对象</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Chart.prototype.setOptions = function (options) {
        return _.extend(this.defaults, options);
    };

    DataV.Chart = Chart;</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="DataV_extend">
    extend
  </h3>
  

  <p>继承</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>DataV.extend()</td> 
      <td>DataV</td>
      <td>extend</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>parent(Function)</td>
      <td colspan="2">父类</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>properties(Object)</td>
      <td colspan="2">新属性</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>Function</td>
      <td colspan="2">新的子类</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>DataV.extend = function (parent, properties) {
        if (typeof parent !== &quot;function&quot;) {
            properties = parent;
            parent = function () {};
        }

        properties = properties || {};
        var sub = function () {
            // Call the parent constructor.
            parent.apply(this, arguments);
            // Only call initialize in self constructor.
            if (this.constructor === parent &amp;&amp; this.initialize) {
                this.initialize.apply(this, arguments);
            }
        };
        sub.prototype = new parent();
        sub.prototype.constructor = parent;
        $.extend(sub.prototype, properties);
        return sub;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="DataV_FloatTag">
    FloatTag
  </h3>
  

  <p>浮动标签</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>DataV.FloatTag()</td> 
      <td>DataV</td>
      <td>FloatTag</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>DataV.FloatTag = function () {
        var _mousemove = function (e) {
            var jqNode = e.data.jqNode;
            var container = e.data.container;
            var mouseToFloatTag = {x: 20, y: 20};
            var offset = $(container).offset();
            if (!(e.pageX &amp;&amp; e.pageY)) {return false;}
            var x = e.pageX - offset.left,
                y = e.pageY - offset.top;
            var position = $(container).position();

            setContent.call(this);

            //set floatTag location
            floatTagWidth = jqNode.outerWidth();
            floatTagHeight = jqNode.outerHeight();
            if (floatTagWidth + x + 2 * mouseToFloatTag.x &lt;=  $(container).width()) {
                x += mouseToFloatTag.x;
            } else {
                x = x - floatTagWidth - mouseToFloatTag.x;
            }
            if (y &gt;= floatTagHeight + mouseToFloatTag.y) {
                y = y - mouseToFloatTag.y - floatTagHeight;
            } else {
                y += mouseToFloatTag.y;
            }
            jqNode.css(&quot;left&quot;,  x  + &quot;px&quot;);
            jqNode.css(&quot;top&quot;,  y + &quot;px&quot;);
        };

        var setContent = function () {};

        function floatTag(cont) {
            var container = cont;
            var jqNode = $(&quot;&lt;div/&gt;&quot;).css({
                &quot;border&quot;: &quot;1px solid&quot;,
                &quot;border-color&quot;: $.browser.msie ? &quot;rgb(0, 0, 0)&quot; : &quot;rgba(0, 0, 0, 0.8)&quot;,
                &quot;background-color&quot;: $.browser.msie ? &quot;rgb(0, 0, 0)&quot; : &quot;rgba(0, 0, 0, 0.75)&quot;,
                &quot;color&quot;: &quot;white&quot;,
                &quot;border-radius&quot;: &quot;2px&quot;,
                &quot;padding&quot;: &quot;12px 8px&quot;,
                //&quot;line-height&quot;: &quot;170%&quot;,
                //&quot;opacity&quot;: 0.7,
                &quot;font-size&quot;: &quot;12px&quot;,
                &quot;box-shadow&quot;: &quot;3px 3px 6px 0px rgba(0,0,0,0.58)&quot;,
                &quot;font-familiy&quot;: &quot;宋体&quot;,
                &quot;z-index&quot;: 10000,
                &quot;text-align&quot;: &quot;center&quot;,
                &quot;visibility&quot;: &quot;hidden&quot;,
                &quot;position&quot;: &quot;absolute&quot;
            });
            $(container).append(jqNode)
                .mousemove({&quot;jqNode&quot;: jqNode, &quot;container&quot;: container}, _mousemove);
            return jqNode;
        }

        floatTag.setContent = function (sc) {
            if (arguments.length === 0) {
                return setContent;
            }
            setContent = sc;
        };
        return floatTag;
    };

    return DataV;
});</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/axis" class="api">
  <h2>charts/axis: API索引</h2>
  <ul class="indexs">
  
    <li>
      <a href="#_d3_scaleExtent">d3_scaleExtent</a>
    </li>

    <li>
      <a href="#_d3_scaleRange">d3_scaleRange</a>
    </li>

    <li>
      <a href="#_d3_svg_axisSubdivide">d3_svg_axisSubdivide</a>
    </li>

    <li>
      <a href="#_axis">axis</a>
    </li>

    <li>
      <a href="#axis_scale">scale</a>
    </li>

    <li>
      <a href="#axis_orient">orient</a>
    </li>

    <li>
      <a href="#axis_ticks">ticks</a>
    </li>

    <li>
      <a href="#axis_tickFormat">tickFormat</a>
    </li>

    <li>
      <a href="#axis_tickSize">tickSize</a>
    </li>

    <li>
      <a href="#axis_tickPadding">tickPadding</a>
    </li>

    <li>
      <a href="#axis_tickSubdivide">tickSubdivide</a>
    </li>

    <li>
      <a href="#axis_tickAttr">tickAttr</a>
    </li>

    <li>
      <a href="#axis_tickTextAttr">tickTextAttr</a>
    </li>

    <li>
      <a href="#axis_minorTickAttr">minorTickAttr</a>
    </li>

    <li>
      <a href="#axis_domainAttr">domainAttr</a>
    </li>

  </ul>
  <hr />

  

  <table class="table">
  

  
  </table>
  
  
  <h3 id="_d3_scaleExtent">
    d3_scaleExtent
  </h3>
  

  <p>function from d3, get scaleRange of an ordinal scale</p>

  <table class="table">
  
    <tr>
      <td>函数</td>
      <td>d3_scaleExtent()</td> 
      <td></td>
      <td>d3_scaleExtent</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>ordinal(domain,)</td>
      <td colspan="2">scale's range</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>function d3_scaleExtent(domain) {
        var start = domain[0], stop = domain[domain.length - 1];
        return start &lt; stop ? [start, stop] : [stop, start];
    }</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_d3_scaleRange">
    d3_scaleRange
  </h3>
  

  <p>function from d3, get scaleRange of a scale</p>

  <table class="table">
  
    <tr>
      <td>函数</td>
      <td>d3_scaleRange()</td> 
      <td></td>
      <td>d3_scaleRange</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>function d3_scaleRange(scale) {
        return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
    }</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_d3_svg_axisSubdivide">
    d3_svg_axisSubdivide
  </h3>
  

  <p>function from d3, get subticks</p>

  <table class="table">
  
    <tr>
      <td>函数</td>
      <td>d3_svg_axisSubdivide()</td> 
      <td></td>
      <td>d3_svg_axisSubdivide</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>scale(scale,)</td>
      <td colspan="2"></td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>major(ticks,)</td>
      <td colspan="2">ticks of scale</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>number(m,)</td>
      <td colspan="2">of subdivide</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>function d3_svg_axisSubdivide(scale, ticks, m) {
        var subticks = [];
        if (m &amp;&amp; ticks.length &gt; 1) {
            var extent = d3_scaleExtent(scale.domain()),
                i = -1,
                n = ticks.length,
                d = (ticks[1] - ticks[0]) / ++m,
                j,
                v;
            while (++i &lt; n) {
                for (j = m; --j &gt; 0;) {
                    if ((v = +ticks[i] - j * d) &gt;= extent[0]) {
                        subticks.push(v);
                    }
                }
            }
            for (--i, j = 0; ++j &lt; m &amp;&amp; (v = +ticks[i] + j * d) &lt; extent[1];) {
                subticks.push(v);
            }
        }
        return subticks;
    }

    var Axis = function () {
        var scale = d3.scale.linear(),
            orient = &quot;bottom&quot;,
            tickMajorSize = 6,
            tickMinorSize = 6,
            tickEndSize = 6,
            tickPadding = 3,
            tickArguments_ = [10],
            tickFormat_,
            tickSubdivide = 0,

            tickAttr_ = {},
            tickTextAttr_ = {},
            minorTickAttr_ = {},
            domainAttr_ = {};</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_axis">
    axis
  </h3>
  

  <p>@param paper: raphael's paper object.</p>

  <table class="table">
  
    <tr>
      <td>函数</td>
      <td>axis()</td> 
      <td></td>
      <td>axis</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>axisSet:</td>
      <td colspan="2">raphael's set object.</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>function axis(paper) {
            // Ticks for quantitative scale, or domain values for ordinal scale.
            var ticks = scale.ticks ? scale.ticks.apply(scale, tickArguments_) : scale.domain(),
                tickFormat = tickFormat_ === undefined ?
                    (scale.tickFormat ?
                        scale.tickFormat.apply(scale, tickArguments_)
                        : String)
                    : tickFormat_;

            var subticks = d3_svg_axisSubdivide(scale, ticks, tickSubdivide);
            var range = d3_scaleRange(scale);
        
            var axisSet = paper.set();

            switch (orient) {
            case &quot;bottom&quot;:
                subticks.forEach(function (d, i, arr) {
                    var tickX = scale.ticks ? scale(d) : scale(d) + scale.rangeBand() / 2;
                    axisSet.push(paper
                        .path(&quot;M&quot; + tickX + &quot;,&quot; + tickMinorSize + &quot;V0&quot;)
                        .attr(minorTickAttr_));
                });
                ticks.forEach(function (d, i, arr) {
                    var tickX = scale.ticks ? scale(d) : scale(d) + scale.rangeBand() / 2;
                    axisSet.push(paper
                        .path(&quot;M&quot; + tickX + &quot;,&quot; + tickMajorSize + &quot;V0&quot;)
                        .attr(tickAttr_));
                    axisSet.push(paper
                        .text(tickX,  Math.max(tickMajorSize, 0) + tickPadding + 2,
                            typeof tickFormat === &quot;function&quot; ? tickFormat(d) : tickFormat)
                        .attr({&quot;text-anchor&quot;: &quot;middle&quot;})
                        .attr(tickTextAttr_));
                });
                axisSet.push(paper
                    .path(&quot;M&quot; + range[0] + &quot;,&quot; + tickEndSize + &quot;V0H&quot; + range[1] + &quot;V&quot; + tickEndSize)
                    .attr(domainAttr_));
                break;

            case &quot;top&quot;:
                subticks.forEach(function (d, i, arr) {
                    var tickX = scale.ticks ? scale(d) : scale(d) + scale.rangeBand() / 2;
                    axisSet.push(paper
                        .path(&quot;M&quot; + tickX + &quot;,&quot; + -tickMinorSize + &quot;V0&quot;)
                        .attr(minorTickAttr_));
                });
                ticks.forEach(function (d, i, arr) {
                    var tickX = scale.ticks ? scale(d) : scale(d) + scale.rangeBand() / 2;
                    axisSet.push(paper
                        .path(&quot;M&quot; + tickX + &quot;,&quot; + -tickMajorSize + &quot;V0&quot;)
                        .attr(tickAttr_));
                    axisSet.push(paper
                        .text(tickX,  -(Math.max(tickMajorSize, 0) + tickPadding + 2),
                            typeof tickFormat === &quot;function&quot; ? tickFormat(d) : tickFormat)
                        .attr({&quot;text-anchor&quot;: &quot;middle&quot;})
                        .attr(tickTextAttr_));
                });
                axisSet.push(paper
                    .path(&quot;M&quot; + range[0] + &quot;,&quot; + -tickEndSize + &quot;V0H&quot; + range[1] + &quot;V&quot; + -tickEndSize)
                    .attr(domainAttr_));
                break;

            case &quot;left&quot;:
                subticks.forEach(function (d, i, arr) {
                    var tickY = scale.ticks ? scale(d) : scale(d) + scale.rangeBand() / 2;
                    axisSet.push(paper
                        .path(&quot;M&quot; + -tickMinorSize + &quot;,&quot; + tickY + &quot;H0&quot;)
                        .attr(minorTickAttr_));
                });
                ticks.forEach(function (d, i, arr) {
                    var tickY = scale.ticks ? scale(d) : scale(d) + scale.rangeBand() / 2;
                    axisSet.push(paper
                        .path(&quot;M&quot; + -tickMajorSize + &quot;,&quot; + tickY + &quot;H0&quot;)
                        .attr(tickAttr_));
                    axisSet.push(paper
                        .text(-(Math.max(tickMajorSize, 0) + tickPadding),  tickY,
                            typeof tickFormat === &quot;function&quot; ? tickFormat(d) : tickFormat)
                        .attr({&quot;text-anchor&quot;: &quot;end&quot;})
                        .attr(tickTextAttr_));
                });
                axisSet.push(paper
                    .path(&quot;M&quot; + -tickEndSize + &quot;,&quot; + range[0] + &quot;H0V&quot; + range[1] + &quot;H&quot; + -tickEndSize)
                    .attr(domainAttr_));
                break;

            case &quot;right&quot;:
                subticks.forEach(function (d, i, arr) {
                    var tickY = scale.ticks ? scale(d) : scale(d) + scale.rangeBand() / 2;
                    axisSet.push(paper
                        .path(&quot;M&quot; + tickMinorSize + &quot;,&quot; + tickY + &quot;H0&quot;)
                        .attr(minorTickAttr_));
                });
                ticks.forEach(function (d, i, arr) {
                    var tickY = scale.ticks ? scale(d) : scale(d) + scale.rangeBand() / 2;
                    axisSet.push(paper
                        .path(&quot;M&quot; + tickMajorSize + &quot;,&quot; + tickY + &quot;H0&quot;)
                        .attr(tickAttr_));
                    axisSet.push(paper
                        .text(Math.max(tickMajorSize, 0) + tickPadding,  tickY,
                            typeof tickFormat === &quot;function&quot; ? tickFormat(d) : tickFormat)
                        .attr({&quot;text-anchor&quot;: &quot;start&quot;})
                        .attr(tickTextAttr_));
                });
                axisSet.push(paper
                    .path(&quot;M&quot; + tickEndSize + &quot;,&quot; + range[0] + &quot;H0V&quot; + range[1] + &quot;H&quot; + tickEndSize)
                    .attr(domainAttr_));
                break;
            }

            return axisSet;
        }</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="axis_scale">
    scale
  </h3>
  

  <p>get or set axis' scale.</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>axis.scale()</td> 
      <td>axis</td>
      <td>scale</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>axis.scale = function (x) {
            if (!arguments.length) {
                return scale;
            }
            scale = x;
            return axis;
        };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="axis_orient">
    orient
  </h3>
  

  <p>get or set axis' orinet: "bottom", "top", "left", "right", default orient is bottom.</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>axis.orient()</td> 
      <td>axis</td>
      <td>orient</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>axis.orient = function (x) {
            if (!arguments.length) {
                return orient;
            }
            orient = x;
            return axis;
        };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="axis_ticks">
    ticks
  </h3>
  

  <p>get or set axis' ticks number.</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>axis.ticks()</td> 
      <td>axis</td>
      <td>ticks</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>axis.ticks = function () {
            if (!arguments.length) {
                return tickArguments_;
            }
            tickArguments_ = arguments;
            return axis;
        };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="axis_tickFormat">
    tickFormat
  </h3>
  

  <p>get or set axis' ticks format function, it's a function change format style.<br />from one string format to another string format.</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>axis.tickFormat()</td> 
      <td>axis</td>
      <td>tickFormat</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>axis.tickFormat = function (x) {
            if (!arguments.length) {
                return tickFormat_;
            }
            tickFormat_ = x;
            return axis;
        };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="axis_tickSize">
    tickSize
  </h3>
  

  <p>get or set axis' tick size(length of tick line, unit: px).</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>axis.tickSize()</td> 
      <td>axis</td>
      <td>tickSize</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>===(arguments.length)</td>
      <td colspan="2">0, get axis' major tick size.</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>===(arguments.length)</td>
      <td colspan="2">1, set axis' all tick sizes as x.</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>===(arguments.length)</td>
      <td colspan="2">2, get axis' major tick size as x, minor and end size as y.</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>===(arguments.length)</td>
      <td colspan="2">3, get axis' major tick size as x, minor size as y, end size as z.</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>axis.tickSize = function (x, y, z) {
            if (!arguments.length) {
                return tickMajorSize;
            }
            var n = arguments.length - 1;
            tickMajorSize = +x;
            tickMinorSize = n &gt; 1 ? +y : tickMajorSize;
            tickEndSize = n &gt; 0 ? +arguments[n] : tickMajorSize;
            return axis;
        };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="axis_tickPadding">
    tickPadding
  </h3>
  

  <p>get or set axis' tick padding(the distance between tick text and axis).</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>axis.tickPadding()</td> 
      <td>axis</td>
      <td>tickPadding</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>is(x)</td>
      <td colspan="2">a number, unit is px;</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>axis.tickPadding = function (x) {
            if (!arguments.length) {
                return tickPadding;
            }
            tickPadding = +x;
            return axis;
        };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="axis_tickSubdivide">
    tickSubdivide
  </h3>
  

  <p>get or set axis' sub tick divide number(divide number between two major ticks).</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>axis.tickSubdivide()</td> 
      <td>axis</td>
      <td>tickSubdivide</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>axis.tickSubdivide = function (x) {
            if (!arguments.length) {
                return tickSubdivide;
            }
            tickSubdivide = +x;
            return axis;
        };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="axis_tickAttr">
    tickAttr
  </h3>
  

  <p>get or set axis' tick attribute(Raphael format).</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>axis.tickAttr()</td> 
      <td>axis</td>
      <td>tickAttr</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>axis.tickAttr = function (x) {
            if (!arguments.length) {
                return tickAttr_;
            }
            tickAttr_ = x;
            return axis;
        };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="axis_tickTextAttr">
    tickTextAttr
  </h3>
  

  <p>get or set axis' tick text attribute(Raphael format).</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>axis.tickTextAttr()</td> 
      <td>axis</td>
      <td>tickTextAttr</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>axis.tickTextAttr = function (x) {
            if (!arguments.length) {
                return tickTextAttr_;
            }
            tickTextAttr_ = x;
            return axis;
        };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="axis_minorTickAttr">
    minorTickAttr
  </h3>
  

  <p>get or set axis' minor tick attribute(Raphael format).</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>axis.minorTickAttr()</td> 
      <td>axis</td>
      <td>minorTickAttr</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>axis.minorTickAttr = function (x) {
            if (!arguments.length) {
                return minorTickAttr_;
            }
            minorTickAttr_ = x;
            return axis;
        };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="axis_domainAttr">
    domainAttr
  </h3>
  

  <p>get or set axis' domain(axis line) attribute(Raphael format).</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>axis.domainAttr()</td> 
      <td>axis</td>
      <td>domainAttr</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>axis.domainAttr = function (x) {
            if (!arguments.length) {
                return domainAttr_;
            }
            domainAttr_ = x;
            return axis;
        };
      
        return axis;
    };

    return Axis;
});</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/brush" class="api">
  <h2>charts/brush: API索引</h2>
  <ul class="indexs">
  
    <li>
      <a href="#_d3_svg_brushRedrawX">d3_svg_brushRedrawX</a>
    </li>

    <li>
      <a href="#_d3_svg_brushRedrawY">d3_svg_brushRedrawY</a>
    </li>

    <li>
      <a href="#_d3_scaleExtent">d3_scaleExtent</a>
    </li>

    <li>
      <a href="#_d3_scaleRange">d3_scaleRange</a>
    </li>

    <li>
      <a href="#_d3_svg_brushMove1">d3_svg_brushMove1</a>
    </li>

    <li>
      <a href="#_d3_svg_brushMove">d3_svg_brushMove</a>
    </li>

    <li>
      <a href="#_d3_svg_brushKeydown">d3_svg_brushKeydown</a>
    </li>

    <li>
      <a href="#_d3_svg_brushKeyup">d3_svg_brushKeyup</a>
    </li>

    <li>
      <a href="#_d3_svg_brushUp">d3_svg_brushUp</a>
    </li>

    <li>
      <a href="#_down">down</a>
    </li>

    <li>
      <a href="#_brush">brush</a>
    </li>

    <li>
      <a href="#brush_left">left</a>
    </li>

    <li>
      <a href="#brush_top">top</a>
    </li>

    <li>
      <a href="#brush_width">width</a>
    </li>

    <li>
      <a href="#brush_height">height</a>
    </li>

    <li>
      <a href="#brush_x">x</a>
    </li>

    <li>
      <a href="#brush_y">y</a>
    </li>

    <li>
      <a href="#brush_extent">extent</a>
    </li>

  </ul>
  <hr />

  

  <p>lobal d3,Raphael,$</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>;(function (name, definition) {
    if (typeof define === 'function') { // Module
        define(definition);
    } else { // Assign to common namespaces or simply the global object (window)
        this[name] = definition(function (id) { return this[id];});
    }
})('Brush', function (require) {

    var d3_svg_brush,
        d3_svg_brushDispatch,
        d3_svg_brushTarget,
        d3_svg_brushX,
        d3_svg_brushY,
        d3_svg_brushExtent,
        d3_svg_brushDrag,
        d3_svg_brushResize,
        d3_svg_brushCenter,
        d3_svg_brushOffset,
        d3_svg_brushEls;</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_d3_svg_brushRedrawX">
    d3_svg_brushRedrawX
  </h3>
  

  <p>set foreground and resizers' x and width;</p>

  <table class="table">
  
    <tr>
      <td>函数</td>
      <td>d3_svg_brushRedrawX()</td> 
      <td></td>
      <td>d3_svg_brushRedrawX</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>function d3_svg_brushRedrawX(brushEls, extent) {
        brushEls.fg.attr({&quot;x&quot;: extent[0][0],
                        &quot;width&quot;: extent[1][0] - extent[0][0] });
        brushEls.resizerSet.forEach(function (el) {
            var orient = el.data(&quot;resizeOrient&quot;);

            if (orient === &quot;n&quot; ||
                    orient === &quot;s&quot; ||
                    orient === &quot;w&quot; ||
                    orient === &quot;nw&quot; ||
                    orient === &quot;sw&quot;) {
                el.attr({&quot;x&quot;: extent[0][0] - 2});
            } else { // &quot;e&quot; &quot;ne&quot; &quot;se&quot;
                el.attr({&quot;x&quot;: extent[1][0] - 2});
            }
            if (orient === &quot;n&quot; || orient === &quot;s&quot;) {
                el.attr({&quot;width&quot;: extent[1][0] - extent[0][0]});
            }
        });</code></pre></td>
    </tr>
  
  </table>
  
  

  <p>g.select(".extent").attr("x", extent[0][0]);<br />        g.selectAll(".n,.s,.w,.nw,.sw").attr("x", extent[0][0] - 2);<br />        g.selectAll(".e,.ne,.se").attr("x", extent[1][0] - 3);<br />        g.selectAll(".extent,.n,.s").attr("width", extent[1][0] - extent[0][0]);</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>}</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_d3_svg_brushRedrawY">
    d3_svg_brushRedrawY
  </h3>
  

  <p>set foreground and resizers' y and height;</p>

  <table class="table">
  
    <tr>
      <td>函数</td>
      <td>d3_svg_brushRedrawY()</td> 
      <td></td>
      <td>d3_svg_brushRedrawY</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>function d3_svg_brushRedrawY(brushEls, extent) {
        brushEls.fg.attr({&quot;y&quot;: extent[0][1],
                        &quot;height&quot;: extent[1][1] - extent[0][1] });
        brushEls.resizerSet.forEach(function (el) {
            var orient = el.data(&quot;resizeOrient&quot;);
            if (orient === &quot;n&quot; ||
                    orient === &quot;e&quot; ||
                    orient === &quot;w&quot; ||
                    orient === &quot;nw&quot; ||
                    orient === &quot;ne&quot;) {
                el.attr({&quot;y&quot;: extent[0][1] - 3});
            } else { // &quot;s&quot; &quot;se&quot; &quot;sw&quot;
                el.attr({&quot;y&quot;: extent[1][1] - 4});
            }
            if (orient === &quot;e&quot; || orient === &quot;w&quot;) {
                el.attr({&quot;height&quot;: extent[1][1] - extent[0][1]});
            }
        });</code></pre></td>
    </tr>
  
  </table>
  
  

  <p>g.select(".extent").attr("y", extent[0][1]);<br />        g.selectAll(".n,.e,.w,.nw,.ne").attr("y", extent[0][1] - 3);<br />        g.selectAll(".s,.se,.sw").attr("y", extent[1][1] - 4);<br />        g.selectAll(".extent,.e,.w").attr("height", extent[1][1] - extent[0][1]);</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>}</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_d3_scaleExtent">
    d3_scaleExtent
  </h3>
  

  <p>function from d3, get scaleRange of an ordinal scale</p>

  <table class="table">
  
    <tr>
      <td>函数</td>
      <td>d3_scaleExtent()</td> 
      <td></td>
      <td>d3_scaleExtent</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>ordinal(domain,)</td>
      <td colspan="2">scale's range</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>function d3_scaleExtent(domain) {
        var start = domain[0], stop = domain[domain.length - 1];
        return start &lt; stop ? [start, stop] : [stop, start];
    }</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_d3_scaleRange">
    d3_scaleRange
  </h3>
  

  <p>function from d3, get scaleRange of a scale</p>

  <table class="table">
  
    <tr>
      <td>函数</td>
      <td>d3_scaleRange()</td> 
      <td></td>
      <td>d3_scaleRange</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>function d3_scaleRange(scale) {
        return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
    }</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_d3_svg_brushMove1">
    d3_svg_brushMove1
  </h3>
  

  <p>function from d3, called by d3_svg_brushMove, compute new brush extent after brush moved</p>

  <table class="table">
  
    <tr>
      <td>函数</td>
      <td>d3_svg_brushMove1()</td> 
      <td></td>
      <td>d3_svg_brushMove1</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>function d3_svg_brushMove1(mouse, scale, i) {
        var range = d3_scaleRange(scale),
            r0 = range[0],
            r1 = range[1],
            offset = d3_svg_brushOffset[i],
            size = d3_svg_brushExtent[1][i] - d3_svg_brushExtent[0][i],
            min,
            max;
      
        // When dragging, reduce the range by the extent size and offset.
        if (d3_svg_brushDrag) {
            r0 -= offset;
            r1 -= size + offset;
        }
      
        // Clamp the mouse so that the extent fits within the range extent.
        min = Math.max(r0, Math.min(r1, mouse[i]));
      
        // Compute the new extent bounds.
        if (d3_svg_brushDrag) {
            max = (min += offset) + size;
        } else {
            // If the ALT key is pressed, then preserve the center of the extent.
            if (d3_svg_brushCenter) {
                offset = Math.max(r0, Math.min(r1, 2 * d3_svg_brushCenter[i] - min));
            }
        
            // Compute the min and max of the offset and mouse.
            if (offset &lt; min) {
                max = min;
                min = offset;
            } else {
                max = offset;
            }
        }

        // Update the stored bounds.
        d3_svg_brushExtent[0][i] = min;
        d3_svg_brushExtent[1][i] = max;
    }</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_d3_svg_brushMove">
    d3_svg_brushMove
  </h3>
  

  <p>function from d3, after brush moved, compute new brush extent<br />and redraw foreground and resizer.</p>

  <table class="table">
  
    <tr>
      <td>函数</td>
      <td>d3_svg_brushMove()</td> 
      <td></td>
      <td>d3_svg_brushMove</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>function d3_svg_brushMove(e) {
        if (d3_svg_brushOffset) {
            var bgOffset = $(d3_svg_brushTarget).offset();
            var mouse = [e.pageX - bgOffset.left, e.pageY - bgOffset.top];
            
            if (!d3_svg_brushDrag) {
                // If needed, determine the center from the current extent.
                if (e.altKey) {
                    if (!d3_svg_brushCenter) {
                        d3_svg_brushCenter = [
                            (d3_svg_brushExtent[0][0] + d3_svg_brushExtent[1][0]) / 2,
                            (d3_svg_brushExtent[0][1] + d3_svg_brushExtent[1][1]) / 2
                        ];
                    }
            
                    // Update the offset, for when the ALT key is released.
                    d3_svg_brushOffset[0] = d3_svg_brushExtent[+(mouse[0] &lt; d3_svg_brushCenter[0])][0];
                    d3_svg_brushOffset[1] = d3_svg_brushExtent[+(mouse[1] &lt; d3_svg_brushCenter[1])][1];
                } else {
                    // When the ALT key is released, we clear the center.
                    d3_svg_brushCenter = null;
                }
            }
        
            // Update the brush extent for each dimension.
            if (d3_svg_brushX) {
                d3_svg_brushMove1(mouse, d3_svg_brushX, 0);
                d3_svg_brushRedrawX(d3_svg_brushEls, d3_svg_brushExtent);
            }
            if (d3_svg_brushY) {
                d3_svg_brushMove1(mouse, d3_svg_brushY, 1);
                d3_svg_brushRedrawY(d3_svg_brushEls, d3_svg_brushExtent);
            }
        
            // Notify listeners.
            d3_svg_brushDispatch(&quot;brush&quot;);
        }
    }</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_d3_svg_brushKeydown">
    d3_svg_brushKeydown
  </h3>
  

  <p>function from d3,<br />reset brush offset if user presses "space" key while brushing a new area,<br />to ensure foreground's size unchanged while position changing.</p>

  <table class="table">
  
    <tr>
      <td>函数</td>
      <td>d3_svg_brushKeydown()</td> 
      <td></td>
      <td>d3_svg_brushKeydown</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>function d3_svg_brushKeydown(e) {
        if (e.keyCode === 32 &amp;&amp; d3_svg_brushTarget &amp;&amp; !d3_svg_brushDrag) {
            d3_svg_brushCenter = null;
            d3_svg_brushOffset[0] -= d3_svg_brushExtent[1][0];
            d3_svg_brushOffset[1] -= d3_svg_brushExtent[1][1];
            d3_svg_brushDrag = 2;
            e.stopPropagation();
        }
    }</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_d3_svg_brushKeyup">
    d3_svg_brushKeyup
  </h3>
  

  <p>function from d3,<br />reset brush offset if "space" key up to restore normal drush state.</p>

  <table class="table">
  
    <tr>
      <td>函数</td>
      <td>d3_svg_brushKeyup()</td> 
      <td></td>
      <td>d3_svg_brushKeyup</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>function d3_svg_brushKeyup(e) {
        if (e.keyCode === 32 &amp;&amp; d3_svg_brushDrag === 2) {
            d3_svg_brushOffset[0] += d3_svg_brushExtent[1][0];
            d3_svg_brushOffset[1] += d3_svg_brushExtent[1][1];
            d3_svg_brushDrag = 0;
            e.stopPropagation();
        }
    }</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_d3_svg_brushUp">
    d3_svg_brushUp
  </h3>
  

  <p>function from d3,<br />mouse up and stop brushing.</p>

  <table class="table">
  
    <tr>
      <td>函数</td>
      <td>d3_svg_brushUp()</td> 
      <td></td>
      <td>d3_svg_brushUp</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>function d3_svg_brushUp(e) {
        if (d3_svg_brushOffset) {
            d3_svg_brushMove(e);
            d3_svg_brushEls.resizerSet.forEach(function (resizer) {
                //adjust all resizers
                var orient = resizer.data(&quot;resizeOrient&quot;);
                var size = d3_svg_brush.empty() ? 0 : 6;
                if (orient === &quot;n&quot; || orient === &quot;s&quot;) {
                    resizer.attr({&quot;height&quot;: size});
                } else {
                    resizer.attr({&quot;width&quot;: size});
                }
            });
            d3_svg_brushDispatch(&quot;brushend&quot;);
            d3_svg_brush =
                d3_svg_brushDispatch =
                d3_svg_brushTarget =
                d3_svg_brushX =
                d3_svg_brushY =
                d3_svg_brushExtent =
                d3_svg_brushDrag =
                d3_svg_brushResize =
                d3_svg_brushCenter =
                d3_svg_brushOffset =
                d3_svg_brushEls = null;
            e.stopPropagation();
        }
    }
    
    var d3_svg_brushCursor = {
        n: &quot;ns-resize&quot;,
        e: &quot;ew-resize&quot;,
        s: &quot;ns-resize&quot;,
        w: &quot;ew-resize&quot;,
        nw: &quot;nwse-resize&quot;,
        ne: &quot;nesw-resize&quot;,
        se: &quot;nwse-resize&quot;,
        sw: &quot;nesw-resize&quot;
    };
    var vml_brushCursor = {
        n: &quot;row-resize&quot;,
        e: &quot;col-resize&quot;,
        s: &quot;row-resize&quot;,
        w: &quot;col-resize&quot;,
        nw: &quot;all-scroll&quot;,
        ne: &quot;all-scroll&quot;,
        se: &quot;all-scroll&quot;,
        sw: &quot;all-scroll&quot;
    };

    var Brush  = function () {
        var event = d3.dispatch(&quot;brushstart&quot;, &quot;brush&quot;, &quot;brushend&quot;),
            x, // x-scale, optional
            y, // y-scale, optional
            extent = [[0, 0], [0, 0]], // [x0, y0], [x1, y1]
            e,
            left,
            top,
            width,
            height,
            backgroundAttr = {&quot;fill&quot;: &quot;#dddddd&quot;,
                            &quot;stroke&quot;: &quot;none&quot;,
                            &quot;cursor&quot;: &quot;crosshair&quot;
                            },
            foregroundAttr = {&quot;fill&quot;: &quot;steelblue&quot;,
                            &quot;stroke&quot;: &quot;none&quot;,
                            &quot;cursor&quot;: &quot;move&quot;
                            },
            brushStart = function () {},
            brushing = function () {},
            brushEnd = function () {},

            brushEls = {},
            brushClass;</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_down">
    down
  </h3>
  

  <p>mouse down and start brushing or dragging.</p>

  <table class="table">
  
    <tr>
      <td>函数</td>
      <td>down()</td> 
      <td></td>
      <td>down</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>function down(e) {
            var target = e.target,
                bgOffset;
            
            // Store some global state for the duration of the brush gesture.
            d3_svg_brush = brush;
            d3_svg_brushTarget = $(brushEls.paper.canvas).parent();
            d3_svg_brushExtent = extent;
            bgOffset = $(d3_svg_brushTarget).offset();

            d3_svg_brushOffset = [e.pageX - bgOffset.left, e.pageY - bgOffset.top];
            d3_svg_brushEls = brushEls;
        
            // If the extent was clicked on, drag rather than brush;
            // store the offset between the mouse and extent origin instead.
            d3_svg_brushDrag = target.__brushNodeType__ === &quot;fg&quot; ? true : false;
            if (d3_svg_brushDrag) {
                d3_svg_brushOffset[0] = extent[0][0] - d3_svg_brushOffset[0];
                d3_svg_brushOffset[1] = extent[0][1] - d3_svg_brushOffset[1];
            } else if (/^resize/.test(target.__brushNodeType__)) {
                // If a resizer was clicked on, record which side is to be resized.
                // Also, set the offset to the opposite side.
                d3_svg_brushResize = target.__brushNodeType__.split(&quot;_&quot;)[1];
                d3_svg_brushOffset[0] = extent[+(/w$/.test(d3_svg_brushResize))][0];
                d3_svg_brushOffset[1] = extent[+(/^n/.test(d3_svg_brushResize))][1];
            } else if (e.altKey) {
                // If the ALT key is down when starting a brush, the center is at the mouse.
                d3_svg_brushCenter = d3_svg_brushOffset.slice();
            }
        
            // Restrict which dimensions are resized.
            d3_svg_brushX = !/^(n|s)$/.test(d3_svg_brushResize) &amp;&amp; x;
            d3_svg_brushY = !/^(e|w)$/.test(d3_svg_brushResize) &amp;&amp; y;
        
            // Notify listeners.
            d3_svg_brushDispatch = dispatcher(this, arguments);
            d3_svg_brushDispatch(&quot;brushstart&quot;);
            d3_svg_brushMove(e);
            e.stopPropagation();
        }</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_brush">
    brush
  </h3>
  

  <p>create brush<br />input a Raphael paper, return a brush object.</p>

  <table class="table">
  
    <tr>
      <td>函数</td>
      <td>brush()</td> 
      <td></td>
      <td>brush</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>function brush(paper) {
            var resizes = x &amp;&amp; y ? [&quot;n&quot;, &quot;e&quot;, &quot;s&quot;, &quot;w&quot;, &quot;nw&quot;, &quot;ne&quot;, &quot;se&quot;, &quot;sw&quot;]
                : x ? [&quot;e&quot;, &quot;w&quot;]
                : y ? [&quot;n&quot;, &quot;s&quot;]
                : [];

            if (x) {
                e = d3_scaleRange(x);
                left = e[0];
                width = e[1] - e[0];
            }

            if (y) {
                e = d3_scaleRange(y);
                top = e[0];
                height = e[1] - e[0];
            }

            brushEls.paper = paper;
            brushEls.brushSet = paper.set();
            brushEls.resizerSet = paper.set();
            brushEls.bg = paper.rect(left, top, width, height)
                .attr({&quot;fill&quot;: &quot;#dddddd&quot;,
                        &quot;stroke&quot;: &quot;none&quot;,
                        &quot;cursor&quot;: &quot;crosshair&quot;
                        })
                .attr(backgroundAttr);
            brushEls.bg.node.__brushNodeType__ = &quot;bg&quot;;
            brushEls.bg.node.ondragstart = function () { return false; };//firefox drag bug fix;

            brushClass = &quot;brush&quot; + brushEls.bg.id;

            //$(brushEls.bg.node).addClass(&quot;brush bg rvml&quot;);  // fail to svg
            brushEls.bg.node.setAttribute(&quot;class&quot;, &quot;brush bg rvml &quot; + brushClass);
            brushEls.bg.node.setAttribute(&quot;className&quot;, &quot;brush bg rvml &quot; + brushClass);// IE 6,7

            brushEls.fg = paper.rect(left, top, (x ? 0 : width), (y ? 0 : height))
                .attr({&quot;fill&quot;: &quot;steelblue&quot;,
                        &quot;stroke&quot;: &quot;none&quot;,
                        &quot;cursor&quot;: &quot;move&quot;
                        })
                .attr(foregroundAttr);
            brushEls.fg.node.__brushNodeType__ = &quot;fg&quot;;
            brushEls.fg.node.ondragstart = function () { return false; };//firefox drag bug fix;
            //$(brushEls.fg.node).addClass(&quot;brush fg rvml&quot;);   //fail to svg
            brushEls.fg.node.setAttribute(&quot;class&quot;, &quot;brush fg rvml &quot; + brushClass);
            brushEls.fg.node.setAttribute(&quot;className&quot;, &quot;brush fg rvml &quot; + brushClass);// IE 6,7

            resizes.forEach(function (d) {
                var resizer = paper.rect(left, top, (x ? 6 : width), (y ? 6 : height))
                                .data(&quot;resizeOrient&quot;, d)
                                .attr({&quot;cursor&quot;: d3_svg_brushCursor[d],
                                    &quot;fill&quot;: &quot;white&quot;,
                                    &quot;stroke&quot;: &quot;black&quot;,
                                    &quot;opacity&quot;: 0});
                if (Raphael.vml) {
                    resizer.attr({&quot;cursor&quot;: vml_brushCursor[d]});
                }
                if (brush.empty()) {
                    //hide all resizers
                    if (d === &quot;n&quot; || d === &quot;s&quot;) {
                        resizer.attr({&quot;height&quot;: 0});
                    } else {
                        resizer.attr({&quot;width&quot;: 0});
                    }
                }
                resizer.node.__brushNodeType__ = &quot;resizer_&quot; + d;
                resizer.node.ondragstart = function () { return false; };//firefox drag bug fix;
                //$(resizer.node).addClass(&quot;brush rvml &quot; + d3_svg_brushCursor[d]);  //fail to svg
                resizer.node.setAttribute(&quot;class&quot;, &quot;brush rvml &quot; + brushClass + &quot; &quot; + d3_svg_brushCursor[d]);
                //IE 6,7
                resizer.node.setAttribute(&quot;className&quot;, &quot;brush rvml &quot; + brushClass + &quot; &quot; + d3_svg_brushCursor[d]);
                brushEls.resizerSet.push(resizer);
            });
            
            if (x) {
                d3_svg_brushRedrawX(brushEls, extent);
            }

            if (y) {
                d3_svg_brushRedrawY(brushEls, extent);
            }

            //$(paper.canvas).delegate(&quot;.brush&quot;,&quot;mousedown&quot;, down);
            //$(paper.canvas).undelegate(&quot;.brush&quot;,&quot;mousedown&quot;, down);
            //$(paper.canvas).delegate(&quot;.brush&quot;,&quot;mousedown&quot;, down);
            //$(paper.canvas).off(&quot;mousedown&quot;, &quot;.brush&quot;, down);
            $(paper.canvas).on(&quot;mousedown&quot;, &quot;.&quot; + brushClass,  down);

            brush.brushElements = brushEls;
            return brush;
        }

        // dispatch event, bind data to golbal variant d3.event.
        var dispatcher = function (that, argumentz) {
            return function (type) {
                var e = d3.event;
                try {
                    d3.event = {type: type, target: brush};
                    event[type].apply(that, argumentz);
                } finally {
                    d3.event = e;
                }
            };
        };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="brush_left">
    left
  </h3>
  

  <p>get or set brush's left </p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>brush.left()</td> 
      <td>brush</td>
      <td>left</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>a(z,)</td>
      <td colspan="2">value in brush scale's domain</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>brush.left = function (z) {
            if (!arguments.length) { return left; }
            left = z;
            return brush;
        };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="brush_top">
    top
  </h3>
  

  <p>get or set brush's top </p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>brush.top()</td> 
      <td>brush</td>
      <td>top</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>a(z,)</td>
      <td colspan="2">value in brush scale's domain</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>brush.top = function (z) {
            if (!arguments.length) { return top; }
            top = z;
            return brush;
        };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="brush_width">
    width
  </h3>
  

  <p>get or set brush's width </p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>brush.width()</td> 
      <td>brush</td>
      <td>width</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>a(z,)</td>
      <td colspan="2">value in brush scale's domain</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>brush.width = function (z) {
            if (!arguments.length) { return width; }
            width = z;
            return brush;
        };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="brush_height">
    height
  </h3>
  

  <p>get or set brush's height </p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>brush.height()</td> 
      <td>brush</td>
      <td>height</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>a(z,)</td>
      <td colspan="2">value in brush scale's domain</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>brush.height = function (z) {
            if (!arguments.length) { return height; }
            height = z;
            return brush;
        };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="brush_x">
    x
  </h3>
  

  <p>get or set brush's x scale </p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>brush.x()</td> 
      <td>brush</td>
      <td>x</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>d3's(z,)</td>
      <td colspan="2">sacle object</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>brush.x = function (z) {
            if (!arguments.length) { return x; }
            x = z;
            return brush;
        };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="brush_y">
    y
  </h3>
  

  <p>get or set brush's y scale </p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>brush.y()</td> 
      <td>brush</td>
      <td>y</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>d3's(z,)</td>
      <td colspan="2">sacle object</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>brush.y = function (z) {
            if (!arguments.length) { return y; }
            y = z;
            return brush;
        };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="brush_extent">
    extent
  </h3>
  

  <p>get or set brush's extent in scale's domain format. <br />if both x and y exist, @param z's format is [[x0, y0], [x1, y1]]<br />if only one of x and y exists, @param z's format is [x0, x1] or [y0, y1].</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>brush.extent()</td> 
      <td>brush</td>
      <td>extent</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>brush.extent = function (z) {
            var x0, x1, y0, y1, t;
        
            // Invert the pixel extent to data-space.
            if (!arguments.length) {
                if (x) {
                    x0 = extent[0][0]; x1 = extent[1][0];
                    if (x.invert) {
                        x0 = x.invert(x0); x1 = x.invert(x1);
                    }
                    if (x1 &lt; x0) {
                        t = x0; x0 = x1; x1 = t;
                    }
                }
                if (y) {
                    y0 = extent[0][1]; y1 = extent[1][1];
                    if (y.invert) {
                        y0 = y.invert(y0); y1 = y.invert(y1);
                    }
                    if (y1 &lt; y0) {
                        t = y0; y0 = y1; y1 = t;
                    }
                }
                return x &amp;&amp; y ? [[x0, y0], [x1, y1]] : x ? [x0, x1] : y &amp;&amp; [y0, y1];
            }
        
            // Scale the data-space extent to pixels.
            if (x) {
                x0 = z[0]; x1 = z[1];
                if (y) {
                    x0 = x0[0]; x1 = x1[0];
                }
                if (x.invert) {
                    x0 = x(x0); x1 = x(x1);
                }
                if (x1 &lt; x0) {
                    t = x0; x0 = x1; x1 = t;
                }
                extent[0][0] = x0; extent[1][0] = x1;
            }
            if (y) {
                y0 = z[0]; y1 = z[1];
                if (x) {
                    y0 = y0[1]; y1 = y1[1];
                }
                if (y.invert) {
                    y0 = y(y0); y1 = y(y1);
                }
                if (y1 &lt; y0) {
                    t = y0; y0 = y1; y1 = t;
                }
                extent[0][1] = y0; extent[1][1] = y1;
            }
        
            return brush;
        };
     
        //empty extent and refresh foreground
        brush.clear = function () {
            extent[0][0] = extent[0][1] = extent[1][0] = extent[1][1] = 0;
            brush.refresh();
            return brush;
        };

        //refresh foreground
        brush.refresh = function () {
            if (x) {
                d3_svg_brushRedrawX(brushEls, extent);
            }
            if (y) {
                d3_svg_brushRedrawY(brushEls, extent);
            }
            return brush;
        };

        //remove all brush elements, so users can reset brush attributes and redraw it.
        brush.remove = function () {
            $(paper.canvas).off(&quot;mousedown&quot;, &quot;.&quot; + brushClass,  down);
            brushEls.fg.remove();
            brushEls.bg.remove();
            brushEls.resizerSet.remove();
            return brush;
        };

        // if brush is empty, return true, else false;
        brush.empty = function () {
            return (x &amp;&amp; extent[0][0] === extent[1][0]) || (y &amp;&amp; extent[0][1] === extent[1][1]);
        };

        // set background attribute.
        brush.backgroundAttr  = function (x) {
            if (!arguments.length) { return backgroundAttr; }
            backgroundAttr = x;
            return brush;
        };
        
        // set foreground attribute.
        brush.foregroundAttr = function (x) {
            if (!arguments.length) { return foregroundAttr; }
            foregroundAttr = x;
            return brush;
        };

        $(document).bind(&quot;mousemove&quot;, d3_svg_brushMove)
            .bind(&quot;mouseup&quot;, d3_svg_brushUp)
            .bind(&quot;keydown&quot;, d3_svg_brushKeydown)
            .bind(&quot;keyup&quot;, d3_svg_brushKeyup);
      
        return d3.rebind(brush, event, &quot;on&quot;);
    };

    return Brush;
});</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/bubble" class="api">
  <h2>charts/bubble: API索引</h2>
  <ul class="indexs">
  
    <li>
      <a href="#_Bubble">Bubble</a>
    </li>

  </ul>
  <hr />

  

  <p>lobal Raphael, d3</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>;(function (name, definition) {
    if (typeof define === 'function') { // Module
        define(definition);
    } else { // Assign to common namespaces or simply the global object (window)
        this[name] = definition(function (id) { return this[id];});
    }
})('Bubble', function (require) {
    var DataV = require('DataV');
    var Axis = require('Axis');</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_Bubble">
    Bubble
  </h3>
  

  <p>Recently, bubble graph can represent five dimensions by xaxis,yaxis,size,color and time.<br />       You can stop animation by pause() method, start animation by initControls method;<br />       you can change animation start time by using global variable  this.startTime;<br />       you can visualize a time point's data by generatePaths(time point) method;<br />       an inside method drawAllTime(key) is designed for interaction.</p>

  <table class="table">
  
    <tr>
      <td>声明</td>
      <td>Bubble</td> 
      <td></td>
      <td>Bubble</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>var Bubble = DataV.extend(DataV.Chart, {
        initialize: function (node, options) {
            this.type = &quot;Bubble&quot;;
            this.container = node;
            this.node = this.checkNode(node);
            this.defaults = {};
            // setting display width and height, also they can be changed by options
            this.defaults.width = 800;
            this.defaults.height = 600;
            this.defaults.minRadius = 10;
            this.defaults.maxRadius = 40;
            this.defaults.meshInterval = 20;
            // margin order: left, top, right, bottom
            this.defaults.borderMargin = [200, 30, 0, 80];
            this.defaults.allDimensions = [];
            this.defaults.dimensions = [];
            this.defaults.dimensionType = {};
            this.defaults.dimensionDomain = {};
            this.defaults.dotStrokeColor = {&quot;stroke&quot;: &quot;#fff&quot;};
            this.defaults.colorBarWidth = 40;
            this.defaults.colorBarHeight = 27;
            this.defaults.colorBarBorder = 10;
            this.defaults.skeletonCircleAttr = {
                &quot;fill&quot;: &quot;#000&quot;,
                &quot;fill-opacity&quot;: 0.6,
                &quot;stroke-width&quot;: 0
            };
            this.defaults.skeletonLineAttr = {
                &quot;stroke&quot;: &quot;#000&quot;,
                &quot;stroke-width&quot;: 0.5,
                &quot;stroke-opacity&quot;: 0.5
            };
            this.defaults.colorBarAttr = {
                &quot;stroke&quot;: &quot;#C9C9C9&quot;,
                &quot;stroke-opacity&quot;: 0,
                &quot;r&quot;: 5
            };
            this.defaults.textAttr = {
                &quot;fill&quot;: &quot;#000&quot;,
                &quot;fill-opacity&quot;: 1,
                &quot;font-family&quot;: &quot;雅黑&quot;,
                &quot;font-size&quot;: 12
                };

            this.setOptions(options);
            this.createCanvas();
        }
    });

    // check node: if there is no node or the node is incorrect, throw error
    Bubble.prototype.checkNode = function (node) {
        if (!node) {
            throw new Error(&quot;Please specify which node to render.&quot;);
        }
        if (typeof node === &quot;string&quot;) {
            return document.getElementById(node);
        } else if (node.nodeName) {
            return node;
        }
        throw new Error(&quot;Please specify which node to render.&quot;);
    };

    // set visualization options
    Bubble.prototype.setOptions = function (options) {
        var prop;
        if (options) {
            for (prop in options) {
                if (options.hasOwnProperty(prop)) {
                    this.defaults[prop] = options[prop];
                }
            }
        }
    };

    // create a backCanvas for the visualization
    Bubble.prototype.createCanvas = function () {
        if (!this.node) {
            throw new Error(&quot;Please specify which node to render.&quot;);
        }
        var conf = this.defaults;
            m = conf.borderMargin;
        this.backCanvas = new Raphael(this.node, conf.width, conf.height);
        this.foreCanvas = Raphael(this.node, conf.width, conf.height);
            $(this.node).css(&quot;position&quot;, &quot;relative&quot;);
            $(this.foreCanvas.canvas).css({&quot;position&quot;: &quot;absolute&quot;,
                &quot;zIndex&quot;: 2, &quot;left&quot;: m[0], &quot;top&quot;: m[1]});

        this.canvasF = document.getElementById(this.container);
        canvasStyle = this.canvasF.style;
        canvasStyle.position = &quot;relative&quot;;
        this.floatTag = DataV.FloatTag()(this.canvasF);

        this.floatTag.css({&quot;visibility&quot;: &quot;hidden&quot;});

        $(&quot;#&quot; + this.container).append(this.floatTag);
    };

    // choose bubble graph setted visualization dimens orderly
    Bubble.prototype.chooseDimensions = function (dimen) {
        var conf = this.defaults;
        conf.dimensions = [];
        var strInArray = function (str, array) {
            for (var i = 0, l = array.length; i &lt; l; i++){
                if (array[i] === str) {
                    return true;
                }
            }
            return false;
        };
        for(var i = 0, l = dimen.length; i &lt; l; i++){
            if(strInArray(dimen[i], conf.allDimensions)) {
                conf.dimensions.push(dimen[i]);
            }
        }

        this.timeDimen = conf.dimensions[0];
        this.keyDimen = conf.dimensions[1];
        this.xDimen = conf.dimensions[2];
        this.yDimen = conf.dimensions[3];
        this.sizeDimen = conf.dimensions[4];
        this.colorDimen = conf.dimensions[5];

        this.keys = [];
        this.times = [];
        this.timeKeys = [];
        for (var i = 0, l = this.source.length; i &lt; l; i++) {
            this.keys.push(this.source[i][this.keyDimen]);
            this.times.push(this.source[i][this.timeDimen]);
        }

        this.times.uniq();
        this.keys.uniq();
        for (var i = 0,l = this.times.length; i &lt; l; i++) {
            this.timeKeys.push(i);
        }
        this.startTime = 0;
    };

    // set source, get dimensions data, dimension type, and dimension domain
    // default visualization dimension is setted here
    Bubble.prototype.setSource = function (source) {
        var conf = this.defaults;
        conf.allDimensions = source[0];
        // by default all dimensions show
        conf.dimensions = source[0];

        this.source = [];
        for(var i=1, l=source.length; i &lt; l; i++){
            var dot = {},
                dimen = conf.allDimensions;
            for(var j=0, ll=dimen.length; j &lt; ll; j++){
                dot[dimen[j]] = source[i][j];
            }
            this.source.push(dot);
        }

        // judge dimesions type auto
        conf.dimensionType = {};
        function isNumber(n) {
            return !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);
        }
        for(var i = 0, l = conf.allDimensions.length; i &lt; l; i++){
            var type = &quot;quantitative&quot;;
            for(var j = 1, ll = source.length; j &lt; ll; j++){
                var d = source[j][i];
                if(d &amp;&amp; (! isNumber(d))){
                    type = &quot;ordinal&quot;;
                    break;
                }
            }
            conf.dimensionType[conf.allDimensions[i]] = type;
        }

        // set default dimensionDomain
        for(var i = 0, l = conf.allDimensions.length; i &lt; l; i++){
            var dimen = conf.allDimensions[i];
            if(conf.dimensionType[dimen] === &quot;quantitative&quot;){
                conf.dimensionDomain[dimen] = d3.extent(this.source,
                     function(p){return Math.abs(p[dimen])});
            }else{
                conf.dimensionDomain[dimen] =
                    this.source.map(function(p){return p[dimen]});
            }
        }

        this.timeDimen = conf.dimensions[0];
        this.keyDimen = conf.dimensions[1];
        this.xDimen = conf.dimensions[2];
        this.yDimen = conf.dimensions[3];
        this.sizeDimen = conf.dimensions[4];
        this.colorDimen = conf.dimensions[5];

        this.keys = [];
        this.times = [];
        this.timeKeys = [];
        for (var i = 0, l = this.source.length; i &lt; l; i++) {
            this.keys.push(this.source[i][this.keyDimen]);
            this.times.push(this.source[i][this.timeDimen]);
        }

        this.times.uniq();
        this.keys.uniq();
        for (var i = 0,l = this.times.length; i &lt; l; i++) {
            this.timeKeys.push(i);
        }
        this.startTime = 0;
    };

    // different visualization scale is defined here
    Bubble.prototype.getScale = function() {
        var conf = this.defaults;
            m = conf.borderMargin,
            w = conf.width - m[0] - m[2],
            h = conf.height - m[1] - m[3],
            colorData = [],
            maxRadius = conf.maxRadius,
            minRadius = conf.minRadius,
            backCanvas = this.backCanvas,
            xDimen = this.xDimen,
            yDimen = this.yDimen,
            sizeDimen = this.sizeDimen,
            colorDimen = this.colorDimen,
            timeDimen = this.timeDimen,
            xMin = conf.dimensionDomain[xDimen][0],
            yMin = conf.dimensionDomain[yDimen][0],
            xMax = conf.dimensionDomain[xDimen][1],
            yMax = conf.dimensionDomain[yDimen][1],
            xBorder = (maxRadius + 30) * (xMax - xMin)/w,
            yBorder = (maxRadius + 30) * (yMax - yMin)/h,
            xDomain = [xMin - xBorder, xMax + xBorder],
            yDomain = [yMin - yBorder, yMax + yBorder];

        this.x = {}; 
        this.x[xDimen] = d3.scale.linear()
            .domain(xDomain).range([m[0], m[0] + w]);
        this.y = {};
        this.y[yDimen] = d3.scale.linear()
            .domain(yDomain).range([h, 0]);
        this.z = {};
        this.z[sizeDimen] = d3.scale.linear()
            .domain(conf.dimensionDomain[sizeDimen]).range([minRadius, maxRadius]); 
        this.c = {};
        this.c[colorDimen] = this.colorDB({mode: &quot;random&quot;, ratio: 0.5});

        for (var i = 0, l = this.keys.length; i &lt; l; i++) {
            c0 = this.getColorData(this.keys[i]);
            colorData.push(c0);
        }
        colorData.uniq();

        // draw colorbar
        var tagArea = [20, (conf.height - m[3] - colorData.length * 23), 200, 220],
            rectBn = backCanvas.set(),
            underBn = [];
        for (var i = 0, l = colorData.length; i &lt; l; i++) {
            var c = this.c[colorDimen](colorData[i]);
            // background to add interaction
            underBn.push(backCanvas.rect(tagArea[0] + 10, tagArea[1] + 10 + (20 + 3) * i, 120, 20)
                .attr({&quot;fill&quot;: &quot;#ebebeb&quot;, &quot;stroke&quot;: &quot;none&quot;}).hide());
            // real colorbar
            backCanvas.rect(tagArea[0] + 10 + 3, tagArea[1] + 10 + (20 + 3) * i + 6, 16, 8)
                .attr({&quot;fill&quot;: c, &quot;stroke&quot;: &quot;none&quot;});
            // colorbar text
            backCanvas.text(tagArea[0] + 10 + 3 + 16 + 8, tagArea[1] + 10 + (20 + 3) * i + 10, colorData[i])
                .attr({&quot;fill&quot;: &quot;black&quot;, &quot;fill-opacity&quot;: 1, &quot;font-family&quot;: &quot;Verdana&quot;, &quot;font-size&quot;: 12})
                .attr({&quot;text-anchor&quot;: &quot;start&quot;});
            // just for interaction -- selction
            rectBn.push(backCanvas.rect(tagArea[0] + 10, tagArea[1] + 10 + (20 + 3) * i, 50, 20)
                .attr({&quot;fill&quot;: &quot;white&quot;, &quot;fill-opacity&quot;: 0, &quot;stroke&quot;: &quot;none&quot;})
                .data(&quot;type&quot;, i).data(&quot;colorType&quot;, colorData[i]));
        }

        // add interaction for colorbar
        this.interactionType = null;
        that = this;
        rectBn.forEach(function (d) {
            d.hover(function () {
                if (!that.interval) {
                    for (var i = 0, l = underBn.length; i &lt; l; i++) {
                        if (i === d.data(&quot;type&quot;)) {
                            underBn[i].show();
                            that.interactionType = d.data(&quot;colorType&quot;);
                            that.generatePaths(Math.ceil(that.startTime));
                        }
                    }
                }
            },
            function () {
                for (var i = 0, l = underBn.length; i &lt; l; i++) {
                    if (i === d.data(&quot;type&quot;)) {
                        underBn[i].hide();
                        that.interactionType = null;
                    }
                }
            });
        });

        // pause, restart and related control function
        // var restart = backCanvas.rect(m[0] - conf.colorBarHeight - 2, m[1] + h + 30, conf.colorBarHeight,
        //     conf.colorBarHeight).attr({&quot;fill&quot;: &quot;#aaa&quot;, &quot;fill-opacity&quot;: 0.9}).attr(conf.dotStrokeColor);
        // var playButtonShadow = backCanvas.rect(0,0,15,15,2).attr({&quot;stroke&quot;: &quot;none&quot;,&quot;fill&quot;: &quot;#606060&quot;, &quot;fill-opacity&quot;:0.4});
        var playButtonBack = backCanvas.rect(0,0,24,24,2).attr({&quot;stroke&quot;: &quot;none&quot;,&quot;fill&quot;: &quot;#d6d6d6&quot;});
        var startPatternPath = &quot;M7,18L19,12L7,6V18z&quot;;
        var stopPatternPathL = &quot;M7,7sh4v10sh-4z&quot;;
        var stopPatternPathR = &quot;M13,7sh4v10sh-4z&quot;;
        // var buttonBack = backCanvas.rect(0,0,24,24).attr({&quot;fill&quot;: &quot;#606060&quot;});
        var startPattern = backCanvas.path(startPatternPath).attr({&quot;stroke-width&quot;: 0, &quot;stroke-linejoin&quot;: &quot;round&quot;, &quot;fill&quot;: &quot;#606060&quot;});
        var stopPattern = backCanvas.set();
        stopPattern.push(backCanvas.path(stopPatternPathL));
        stopPattern.push(backCanvas.path(stopPatternPathR));
        stopPattern.attr({&quot;stroke-width&quot;: 0, &quot;stroke-linejoin&quot;: &quot;round&quot;, &quot;fill&quot;: &quot;#606060&quot;});

        // playButtonShadow.transform(&quot;t&quot; + (m[0] - conf.colorBarHeight + 3 + 4) + &quot;,&quot; + (m[1] + h + 33 + 4));
        playButtonBack.transform(&quot;t&quot; + (m[0] - conf.colorBarHeight) + &quot;,&quot; + (m[1] + h + 33));
        startPattern.transform(&quot;t&quot; + (m[0] - conf.colorBarHeight) + &quot;,&quot; + (m[1] + h + 33));
        stopPattern.transform(&quot;t&quot; + (m[0] - conf.colorBarHeight) + &quot;,&quot; + (m[1] + h + 33));
        startPattern.attr({&quot;stroke-width&quot;: 0, &quot;stroke-linejoin&quot;: &quot;round&quot;, &quot;fill-opacity&quot;: 0});

        var playButton = backCanvas.set();
        playButton.push(playButtonBack);
        playButton.push(startPattern);
        playButton.push(stopPattern);

        // var reTest = backCanvas.path(startPattern).attr({&quot;stroke-linejoin&quot;: &quot;round&quot;}).transform(&quot;t&quot; + (m[0] - conf.colorBarHeight + 3) + &quot;,&quot; + (m[1] + h + 33));
        // backCanvas.path(stopPatternL).attr({&quot;stroke-linejoin&quot;: &quot;round&quot;}).transform(&quot;t&quot; + (m[0] - conf.colorBarHeight + 3) + &quot;,&quot; + (m[1] + h + 33));
        // backCanvas.path(stopButtonL).attr({&quot;stroke-linejoin&quot;: &quot;round&quot;}).transform(&quot;t&quot; + (m[0] - conf.colorBarHeight + 3 + 6) + &quot;,&quot; + (m[1] + h + 33));

        playButton.dblclick(
            function() {
                that.clearAnimation();
                that.render();
            }
        );
        playButton.click(
            function() {
                if (that.interval) {
                    stopPattern.attr({&quot;fill-opacity&quot;: 0});
                    startPattern.attr({&quot;fill-opacity&quot;: 1});
                    that.pause();
                } else {
                    startPattern.attr({&quot;fill-opacity&quot;: 0});
                    stopPattern.attr({&quot;fill-opacity&quot;: 1});
                    that.initControls();
                }
                    
            }
        );
        playButton.hover(
            function() {
                startPattern.attr({&quot;fill&quot;: &quot;#ffffff&quot;});
                stopPattern.attr({&quot;fill&quot;: &quot;#ffffff&quot;});
            },
            function() {
                startPattern.attr({&quot;fill&quot;: &quot;#606060&quot;});
                stopPattern.attr({&quot;fill&quot;: &quot;#606060&quot;});
            }
        );

    };

    // draw x-axis, y-axis and related parts
    Bubble.prototype.renderAxis = function () {
        var conf = this.defaults;
            m = conf.borderMargin,
            w = conf.width - m[0] - m[2],
            h = conf.height - m[1] - m[3],
            colorData = [],
            maxRadius = conf.maxRadius,
            minRadius = conf.minRadius,
            yaxis = Axis().orient(&quot;left&quot;),
            xaxis = Axis().orient(&quot;bottom&quot;),
            backCanvas = this.backCanvas,
            xDimen = this.xDimen,
            yDimen = this.yDimen,
            xMin = conf.dimensionDomain[xDimen][0],
            yMin = conf.dimensionDomain[yDimen][0],
            xMax = conf.dimensionDomain[xDimen][1],
            yMax = conf.dimensionDomain[yDimen][1],
            xBorder = (maxRadius + 30) * (xMax - xMin)/w,
            yBorder = (maxRadius + 30) * (yMax - yMin)/h,
            xDomain = [xMin - xBorder, xMax + xBorder],
            yDomain = [yMin - yBorder, yMax + yBorder],
            axixX = d3.scale.linear().domain(xDomain).range([0, w]),
            axixY = d3.scale.linear().domain(yDomain).range([h, 0]);

        backCanvas.clear();

        xaxis.scale(axixX)
            .tickSubdivide(1)
            .tickSize(6, 3, 0)
            .tickPadding(5)
            .tickAttr({&quot;stroke&quot;: &quot;#929292&quot;})
            .tickTextAttr({&quot;font-size&quot;: &quot;10px&quot;, &quot;fill&quot;: &quot;#929292&quot;})
            .minorTickAttr({&quot;stroke&quot;: &quot;#929292&quot;})
            .domainAttr({&quot;stroke-width&quot;: 1, &quot;stroke&quot;: &quot;#929292&quot;})
            (backCanvas).attr({transform: &quot;t&quot; + m[0] + &quot;,&quot; + (m[1] + h)});

        yaxis.scale(axixY)
            .tickSubdivide(1)
            .tickSize(6, 3, 0)
            .tickPadding(5)
            .tickAttr({&quot;stroke&quot;: &quot;#929292&quot;})
            .tickTextAttr({&quot;font-size&quot;: &quot;10px&quot;, &quot;fill&quot;: &quot;#929292&quot;})
            .minorTickAttr({&quot;stroke&quot;: &quot;#929292&quot;})
            .domainAttr({&quot;stroke-width&quot;: 1, &quot;stroke&quot;: &quot;#929292&quot;})
            (backCanvas).attr({transform: &quot;t&quot; + m[0] + &quot;,&quot; + m[1]});

        var xText = backCanvas.text(m[0] + w/2, m[1] + h + 40, this.xDimen);
        xText.attr({&quot;font-size&quot;: &quot;15px&quot;, &quot;font-family&quot;: &quot;Arial&quot;, &quot;fill&quot;: &quot;#000000&quot;});
        var yText = backCanvas.text(m[0] - 50, m[1] + h/2, this.yDimen);
        yText.attr({&quot;font-size&quot;: &quot;15px&quot;, &quot;font-family&quot;: &quot;Arial&quot;, &quot;fill&quot;: &quot;#000000&quot;}).transform(&quot;r-90&quot;);     
    };

    // color database
    Bubble.prototype.colorDB = function (colorJson) {
        var colorMatrix = DataV.getColor();
        var color;
        var colorStyle = colorJson || {};
        var colorMode = colorStyle.mode || 'default';
        var i, l;

        switch (colorMode) {
        case &quot;gradient&quot;:
            var index = colorJson.index || 0;
            index = index &lt; 0 ? 0 : Math.min(index, colorMatrix.length - 1);
            color = d3.interpolateRgb.apply(null, [colorMatrix[index][0], colorMatrix[index][1]]);
            break;
        case &quot;random&quot;:
        case &quot;default&quot;:
            var ratio = colorStyle.ratio || 0;
            if (ratio &lt; 0) { ratio = 0; }
            if (ratio &gt; 1) { ratio = 1; }
            var colorArray = [];
            for (i = 0, l = colorMatrix.length; i &lt; l; i++) {
                var colorFunc = d3.interpolateRgb.apply(null, [colorMatrix[i][0], colorMatrix[i][1]]);
                colorArray.push(colorFunc(ratio));
            }
            color = d3.scale.ordinal().range(colorArray);
            break;
        }
        return color;
    };

    // main visualization method where bubble is drawed inside
    // a time point is the method's only parameter
    Bubble.prototype.generatePaths = function (time) {
        var conf = this.defaults,
            m = conf.borderMargin,
            meshInterval = conf.meshInterval,
            realWidth = conf.width - m[0] - m[2],
            realHeight = conf.height - m[1] - m[3],
            labelSize = 18,
            labelXDistance = realHeight * 0.86,
            foreCanvas = this.foreCanvas,
            x0, y0, r0, c0,
            x, y, r, c, skeletonRadius = 2,
            timeKeys = this.timeKeys,
            keys = this.keys,
            dots = [],
            dotBubbleSet = [];

        // $(&quot;#&quot; + this.node).append(this.floatTag);

        if (time &lt; this.times.length - 1) {
            this.startTime = time;
        } else {
            this.startTime = 0;
        }
        
        foreCanvas.clear();

        // draw mesh
        var meshes = foreCanvas.set(),
            verticleMeshNum = realWidth / meshInterval,
            horizontalMeshNUm = realHeight / meshInterval;
        for (var i = 1;i &lt; verticleMeshNum;i++) {
            meshes.push(foreCanvas.path(&quot;M&quot;+(i * meshInterval)+&quot; &quot;+0+&quot;L&quot;+(i * meshInterval)+
                &quot; &quot;+(realHeight-1)).attr({&quot;stroke&quot;: &quot;#ebebeb&quot;, &quot;stroke-width&quot;: 1}));
        }
        for (var i = 1;i &lt; horizontalMeshNUm;i++) {
            meshes.push(foreCanvas.path(&quot;M&quot;+1+&quot; &quot;+(realHeight - (i * meshInterval))+&quot;L&quot;+realWidth+
                &quot; &quot;+(realHeight - (i * meshInterval))).attr({&quot;stroke&quot;: &quot;#ebebeb&quot;, &quot;stroke-dasharray&quot;: &quot;-&quot;, &quot;stroke-width&quot;: 0.5}));
        }

        // get all data by time and key dimension data
        for (var i = 0, l = keys.length; i &lt; l; i++) {
            x0 = this.interpolateData(time, timeKeys, this.getKeyData(xDimen, keys[i]));
            y0 = this.interpolateData(time, timeKeys, this.getKeyData(yDimen, keys[i]));
            r0 = this.interpolateData(time, timeKeys, this.getKeyData(sizeDimen, keys[i]));
            c0 = this.getColorData(keys[i]);

            var dot = {key: keys[i], x0: x0, y0: y0, r0: r0, c0: c0, year: this.times[time.toFixed(0)]};
            dots.push(dot);
        }

        var floatTag = this.floatTag;
        var tip = '&lt;b&gt;' + that.keyDimen + ':{key}&lt;/b&gt;&lt;br/&gt;&lt;b&gt;' 
                    + that.xDimen + ':{xDimen}&lt;/b&gt;&lt;br/&gt;&lt;b&gt;'
                    + that.yDimen + ':{yDimen}&lt;/b&gt;&lt;br/&gt;&lt;b&gt;'
                    + that.sizeDimen + ':{sizeDimen}&lt;/b&gt;&lt;br/&gt;&lt;b&gt;'
                    + that.colorDimen + ':{colorDimen}&lt;/b&gt;&lt;br/&gt;&lt;b&gt;'
                    + that.timeDimen + ':{timeDimen}&lt;/b&gt;';


        // control the time label
        var label = foreCanvas.text(20, m[1] + h + 15, this.times[time.toFixed(0)]);
        label.attr({&quot;font-size&quot;: labelSize, &quot;fill&quot;: &quot;#606060&quot;, &quot;text-anchor&quot;: &quot;start&quot;});

        dots.sort(function(b,a) { return a.r0 &lt; b.r0 ? -1 : a.r0 &gt; b.r0 ? 1 : 0; });

        // draw the circles
        for (var i = 0, l = dots.length; i &lt; l; i++) {          
            var dot = dots[i],
                x = this.x[xDimen](dot.x0) - m[0],
                y = this.y[yDimen](dot.y0),
                r = this.z[sizeDimen](dot.r0),
                c = this.c[colorDimen](dot.c0),
                dotBubble = foreCanvas.circle(x, y, r);
            dotBubble.attr({&quot;stroke-width&quot;:0, &quot;fill&quot;: c, &quot;fill-opacity&quot;: 0.5})
                .data(&quot;key&quot;, dot.key).data(&quot;colorType&quot;, dot.c0);
            dotBubbleSet.push(dotBubble);
        }

        // add hover and click effect for all circles
        dotBubbleSet.forEach(function (d, i) {
            tip = tip.replace('{key}', dots[i].key);
                    tip = tip.replace('{xDimen}', dots[i].x0);
                    tip = tip.replace('{yDimen}', dots[i].y0);
                    tip = tip.replace('{sizeDimen}', dots[i].r0);
                    tip = tip.replace('{colorDimen}', dots[i].c0);
                    tip = tip.replace('{timeDimen}', time);
            d.hover(
                function () {
                    floatTag.html ( '&lt;div style = &quot;text-align: left;margin:auto;color:'
                        //+ jqNode.color
                        + &quot;#ffffff&quot;
                        + '&quot;&gt;' + tip + '&lt;/div&gt;'
                        );
                    floatTag.css({&quot;visibility&quot; : &quot;visible&quot;});
                    if (!that.choose) {
                        d.attr({&quot;stroke-width&quot;: 1, &quot;stroke&quot;: &quot;#f00&quot;, &quot;fill-opacity&quot;: 0.8});
                        meshes.attr({&quot;stroke&quot;: &quot;#d6d6d6&quot;, &quot;stroke-dasharray&quot;: &quot;-&quot;, &quot;stroke-width&quot;: 1});
                        for (var j = 0, l = dotBubbleSet.length; j &lt; l ; j++) {
                            if (j != i) {
                               dotBubbleSet[j].attr({&quot;stroke-width&quot;: 0, &quot;fill-opacity&quot;: 0.2});
                            }
                        }
                    }
                },
                function () {
                    floatTag.css({&quot;visibility&quot; : &quot;hidden&quot;});
                    if (!that.choose) {
                        d.attr({&quot;stroke-width&quot;: 0, &quot;fill-opacity&quot;: 0.5});
                        meshes.attr({&quot;stroke&quot;: &quot;#ebebeb&quot;, &quot;stroke-dasharray&quot;: &quot;-&quot;, &quot;stroke-width&quot;: 1});
                        for (var j = 0, l = dotBubbleSet.length; j &lt; l ; j++) {
                            if (j != i) {
                               dotBubbleSet[j].attr({&quot;stroke-width&quot;: 0, &quot;fill-opacity&quot;: 0.5});
                            }
                        }
                    }
                }
            );

            d.click(
                function() {
                    if (time == Math.ceil(time)) {
                        drawAllTime(this.data(&quot;key&quot;), i);
                    } else {
                        drawAllTime(this.data(&quot;key&quot;), i);
                        this.remove();
                    }
                }
            );
        }); 

        // colorbar interaction for showing all same color history data
        that = this;
        if (this.interactionType) {
            dotBubbleSet.forEach(function (d) {
                if (d.data(&quot;colorType&quot;) == that.interactionType) {
                    drawAllTime(d.data(&quot;key&quot;));
                }
            });
        }  

        // an inside method to visualize a key's all time data 
        function drawAllTime (key, num) {
            if (!that.interval) {
                that.choose = true;
                var floatTag = that.floatTag;

                for (var j = 0, l = dotBubbleSet.length; j &lt; l ; j++) {
                    if (j != num) {
                        dotBubbleSet[j].attr({&quot;stroke-width&quot;: 0, &quot;fill-opacity&quot;: 0.2});
                    }
                }

                meshes.attr({&quot;stroke&quot;: &quot;#d6d6d6&quot;, &quot;stroke-dasharray&quot;: &quot;-&quot;});

                var tip = '&lt;b&gt;' + that.keyDimen + ':{key}&lt;/b&gt;&lt;br/&gt;&lt;b&gt;' 
                    + that.xDimen + ':{xDimen}&lt;/b&gt;&lt;br/&gt;&lt;b&gt;'
                    + that.yDimen + ':{yDimen}&lt;/b&gt;&lt;br/&gt;&lt;b&gt;'
                    + that.sizeDimen + ':{sizeDimen}&lt;/b&gt;&lt;br/&gt;&lt;b&gt;'
                    + that.colorDimen + ':{colorDimen}&lt;/b&gt;&lt;br/&gt;&lt;b&gt;'
                    + that.timeDimen + ':{timeDimen}&lt;/b&gt;';

                for (var i = 0, l = timeKeys.length; i &lt; l; i++) {
                    var x0 = that.interpolateData(timeKeys[i], timeKeys, that.getKeyData(xDimen, key)),
                        y0 = that.interpolateData(timeKeys[i], timeKeys, that.getKeyData(yDimen, key)),
                        r0 = that.interpolateData(timeKeys[i], timeKeys, that.getKeyData(sizeDimen, key)),
                        c0 = that.getColorData(key),
                        x = that.x[xDimen](x0) - m[0],
                        y = that.y[yDimen](y0),
                        r = that.z[sizeDimen](r0),
                        c = that.c[colorDimen](c0),
                        fOpacity = 0.1 + Math.pow(1.5, i)/Math.pow(1.5, l);
                        historyBubble = foreCanvas.circle(x, y, r);
                        historyBubble.attr({&quot;stroke-width&quot;: 0, &quot;fill&quot;: c, &quot;fill-opacity&quot;: fOpacity});

                    tip = tip.replace('{key}', key);
                    tip = tip.replace('{xDimen}', x0);
                    tip = tip.replace('{yDimen}', y0);
                    tip = tip.replace('{sizeDimen}', r0);
                    tip = tip.replace('{colorDimen}', c0);
                    tip = tip.replace('{timeDimen}', that.times[timeKeys[i]]);

                    if (timeKeys[i] == Math.ceil(time)) {
                        historyBubble.attr({&quot;stroke-width&quot;: 1, &quot;stroke&quot;: &quot;#f00&quot;});
                        historyBubble.hover(
                            function () {
                                floatTag.html ( '&lt;div style = &quot;text-align: left;margin:auto;color:'
                                //+ jqNode.color
                                    + &quot;#ffffff&quot;
                                    + '&quot;&gt;' + tip + '&lt;/div&gt;'
                                    );
                                floatTag.css({&quot;visibility&quot; : &quot;visible&quot;});
                                // meshes.attr({&quot;stroke&quot;: &quot;#d6d6d6&quot;, &quot;stroke-dasharray&quot;: &quot;-&quot;});
                            },
                            function () {
                                floatTag.css({&quot;visibility&quot; : &quot;hidden&quot;});
                                // meshes.attr({&quot;stroke&quot;: &quot;#ebebeb&quot;, &quot;stroke-dasharray&quot;: &quot;-&quot;});
                            }
                        );

                    } else {
                        historyBubble.hover(
                            function () {
                                this.attr({&quot;stroke-width&quot;: 1, &quot;stroke&quot;: &quot;#f00&quot;});
                                floatTag.html ( '&lt;div style = &quot;text-align: left;margin:auto;color:'
                                //+ jqNode.color
                                    + &quot;#ffffff&quot;
                                    + '&quot;&gt;' + tip + '&lt;/div&gt;'
                                    );
                                floatTag.css({&quot;visibility&quot; : &quot;visible&quot;});
                                // meshes.attr({&quot;stroke&quot;: &quot;#d6d6d6&quot;, &quot;stroke-dasharray&quot;: &quot;-&quot;});
                            },
                            function () {
                                this.attr({&quot;stroke-width&quot;: 0});
                                floatTag.css({&quot;visibility&quot; : &quot;hidden&quot;});
                                // meshes.attr({&quot;stroke&quot;: &quot;#ebebeb&quot;, &quot;stroke-dasharray&quot;: &quot;-&quot;});
                            }
                        );
                    }

                    historyBubble.click(
                            function () {
                                that.generatePaths(Math.ceil(time));
                                that.choose = false;
                            }
                        );
                }

                var skeletonLineSet = foreCanvas.set();
                for (var i = 1, l = timeKeys.length; i &lt; l; i++) {
                    var x0 = that.interpolateData(timeKeys[i], timeKeys, that.getKeyData(xDimen, key)),
                        y0 = that.interpolateData(timeKeys[i], timeKeys, that.getKeyData(yDimen, key)),
                        x = that.x[xDimen](x0) - m[0],
                        y = that.y[yDimen](y0),
                        x1 = that.interpolateData(timeKeys[i-1], timeKeys, that.getKeyData(xDimen, key)),
                        y1 = that.interpolateData(timeKeys[i-1], timeKeys, that.getKeyData(yDimen, key)),
                        x2 = that.x[xDimen](x1) - m[0],
                        y2 = that.y[yDimen](y1);
                        skeletonLine = foreCanvas.path(&quot;M&quot;+x2+&quot; &quot;+y2+&quot;L&quot;+x+&quot; &quot;+y);
                        skeletonLine.attr(conf.skeletonLineAttr);
                        skeletonLineSet.push(skeletonLine);
                    }

                var skeletonCircleSet = foreCanvas.set();
                for (var i = 0, l = timeKeys.length; i &lt; l; i++) {
                    var x0 = that.interpolateData(timeKeys[i], timeKeys, that.getKeyData(xDimen, key)),
                        y0 = that.interpolateData(timeKeys[i], timeKeys, that.getKeyData(yDimen, key)),
                        r0 = that.interpolateData(timeKeys[i], timeKeys, that.getKeyData(sizeDimen, key)),
                        c0 = that.getColorData(key),
                        x = that.x[xDimen](x0) - m[0],
                        y = that.y[yDimen](y0),
                        r = that.z[sizeDimen](r0),
                        c = that.c[colorDimen](c0),
                        fOpacity = 0.1 + i * 0.9 / timeKeys.length;
                    skeletonCircle = foreCanvas.circle(x,y,skeletonRadius);
                    skeletonCircle.attr(conf.skeletonCircleAttr).attr({&quot;stroke&quot;: c});
                    skeletonCircleSet.push(skeletonCircle);

                    if (timeKeys[i] == Math.ceil(time)) {
                        skeletonCircle.attr({&quot;fill&quot;: &quot;#f00&quot;});
                        skeletonCircle.click(
                            function () {
                                that.generatePaths(Math.ceil(time));
                            }
                        );
                        skeletonCircle.hover(
                            function () {
                                floatTag.html ( '&lt;div style = &quot;text-align: left;margin:auto;color:'
                                //+ jqNode.color
                                    + &quot;#ffffff&quot;
                                    + '&quot;&gt;' + tip + '&lt;/div&gt;'
                                    );
                                floatTag.css({&quot;visibility&quot; : &quot;visible&quot;});
                                skeletonCircleSet.attr({&quot;fill-opacity&quot;: 0.35});
                                this.attr({&quot;fill-opacity&quot;: 1, &quot;r&quot;: 5});
                                // meshes.attr({&quot;stroke&quot;: &quot;#d6d6d6&quot;, &quot;stroke-dasharray&quot;: &quot;-&quot;});
                                skeletonLineSet.attr({&quot;opacity&quot;: 0.35});
                            },
                            function () {
                                floatTag.css({&quot;visibility&quot; : &quot;hidden&quot;});
                                this.attr(conf.dotStrokeColor);
                                skeletonCircleSet.attr({&quot;fill-opacity&quot;: 0.7});
                                this.attr({&quot;r&quot;: skeletonRadius});
                                // meshes.attr({&quot;stroke&quot;: &quot;#ebebeb&quot;, &quot;stroke-dasharray&quot;: &quot;-&quot;});
                                skeletonLineSet.attr({&quot;opacity&quot;: 0.7});
                            }
                        );
                    } else {
                        skeletonCircle.hover(
                            function () {
                                floatTag.html ( '&lt;div style = &quot;text-align: left;margin:auto;color:'
                                //+ jqNode.color
                                    + &quot;#ffffff&quot;
                                    + '&quot;&gt;' + tip + '&lt;/div&gt;'
                                    );
                                floatTag.css({&quot;visibility&quot; : &quot;visible&quot;});
                                skeletonCircleSet.attr({&quot;fill-opacity&quot;: 0.35});
                                this.attr({&quot;fill-opacity&quot;: 1, &quot;r&quot;: 5});
                                // meshes.attr({&quot;stroke&quot;: &quot;#d6d6d6&quot;, &quot;stroke-dasharray&quot;: &quot;-&quot;});
                                skeletonLineSet.attr({&quot;opacity&quot;: 0.35});
                            },
                            function () {
                                floatTag.css({&quot;visibility&quot; : &quot;hidden&quot;});
                                this.attr(conf.dotStrokeColor);
                                skeletonCircleSet.attr({&quot;fill-opacity&quot;: 0.7});
                                this.attr({&quot;r&quot;: skeletonRadius});
                                // meshes.attr({&quot;stroke&quot;: &quot;#ebebeb&quot;, &quot;stroke-dasharray&quot;: &quot;-&quot;});
                                skeletonLineSet.attr({&quot;opacity&quot;: 0.7});
                            }
                        );
                    }
                }

            }
        }     
    };

    // get key's specific dimension data which include all time points 
    Bubble.prototype.getKeyData = function(dimen,key) {
        var data = [];
        for (var i = 0; i &lt; this.source.length; i++) {
            if (this.source[i][this.keyDimen] === key) {
                data.push(this.source[i][dimen]);
            }
        }
        return data;
    }; 

    // get a unique color specified by key
    Bubble.prototype.getColorData = function(key) {
        for (var i = 0; i &lt; this.source.length; i++) {
            if (this.source[i][this.keyDimen] === key) {
                return this.source[i][this.colorDimen];
            }
        }

    };

    // set up an animation
    Bubble.prototype.initControls = function() {  
        var that = this,
            len = this.times.length -1;
            value = this.startTime;

        this.interval = setInterval(function() {
            if (value &lt;= len) {
                that.generatePaths(value);
                value += 0.25;
            } else {
                clearInterval(that.interval);
                that.interval = 0;
            }
        }, 250);
    };

    // interpolated some data between neibourh data point for the animation
    Bubble.prototype.interpolateData = function(year, years, values) {
        var index = Math.ceil(year);
        if (year == years[index]) {
            return values[index];
        }
        var lowerIndex = Math.max(0,index-1);
        var lower = values[lowerIndex];
        var higherIndex = index;
        var higher = values[higherIndex];
        var lowYear = years[lowerIndex];
        var highYear = years[higherIndex];
        var p = (year-lowYear) / (highYear-lowYear);
        var value = +lower + +((higher-lower)*p) ;
        return value;
    };

    // make an array's every element unique by delete other same element 
    Array.prototype.uniq = function () {
        var temp = {},
            len = this.length;

        for (var i = 0; i &lt; len; i++) {
            if (typeof temp[this[i]] == &quot;undefined&quot;) {
                temp[this[i]] = 1;
            }
        }
        this.length = 0;
        len = 0;
        for (var i in temp) {
            this[len++] = i;
        }
        return this;
    };

    // clear animation and related artifacts 
    Bubble.prototype.clearAnimation = function () {
        clearInterval(this.interval);
        this.interval = 0;
        this.backCanvas.clear();
        this.foreCanvas.clear();
    };

    // pause the interval
    Bubble.prototype.pause = function () {
        clearInterval(this.interval);
        this.interval = 0;
    };

    // set the rendering process
    Bubble.prototype.render = function (options) {
        clearInterval(this.interval);
        if (!this.node) {
            throw new Error(&quot;Please specify which node to render.&quot;);
        }
        this.setOptions(options);
        if (!this.interval) {
            this.renderAxis();
        } 
        this.foreCanvas.clear();
 	    this.getScale();
        this.initControls();
    };

    return Bubble;
});</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/bullet" class="api">
  <h2>charts/bullet: API索引</h2>
  <ul class="indexs">
  
  </ul>
  <hr />

  

  <table class="table">
  

  
  </table>
  
  

  <p>lobal d3</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>define(function (require, exports, module) {
    var DataV = require('datav');

    var Bullet = DataV.extend(DataV.Chart, { 
        initialize: function (node, options) {
            this.type = &quot;Bullet&quot;;
            this.node = this.checkNode(node);
            this.defaults = {};
            // Properties
            this.defaults.orient = &quot;horizonal&quot;; // &quot;horizonal&quot;, &quot;vertical&quot;
            this.defaults.axisStyle = &quot;linear&quot;; // &quot;linear&quot;, &quot;log&quot;
            this.defaults.logBase = Math.E;
            this.defaults.margin = [10, 10, 20, 80];//top, right, bottom, left
            this.defaults.centerBarRatio = 0.3;
            this.defaults.markerWidth = 4;
            this.defaults.markerRatio = 0.7;
            this.defaults.titleRatio = 0.6; //title's text height : subtitle's text height = 6:4
            this.defaults.backgroundColor = [&quot;#666&quot;, &quot;#ddd&quot;]; //dark, light
            this.defaults.measureColor = [&quot;steelblue&quot;, &quot;#B0C4DE&quot;]; //dark, light
            this.defaults.markerColor = &quot;#000&quot;,
            this.defaults.tickDivide = 5;</code></pre></td>
    </tr>
  
  </table>
  
  

  <p>users can manupilate these attri below directly<br />            this.axis;<br />            this.scale;<br />            this.logScale; //exist if this.scale is log<br />            this.title;<br />            this.subtitle;<br />            this.data = {<br />                    title: "Sample",<br />                    subtitle: "ratio",<br />                    ranges: [0, 0.5, 0.8, 1],<br />                    measures: [0.7],<br />                    markers: [0.6],<br />                    /<em>* optional *</em> <br />                    rangeTitles: ["below 50%", "top 20% - 50%", "top 20%"],<br />                    measureTitles: ["value is 0.7"],<br />                    markerTitles: ["mean is 0.6"]<br />                    }</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>// canvas
            this.defaults.width = 200;
            this.defaults.height = 80;
            this.setOptions(options);
            this.createCanvas();
        }
    });

    Bullet.prototype.checkNode = function (node) {
        if (!node) {
            throw new Error(&quot;Please specify which node to render.&quot;);
        }
        if (typeof node === &quot;string&quot;) {
            return document.getElementById(node);
        } else if (node.nodeName) {//DOM-element
            return node;
        }
        throw new Error(&quot;Please specify which node to render.&quot;);
    };

    Bullet.prototype.createCanvas = function () {
        var conf = this.defaults;
        this.canvas = new Raphael(this.node, conf.width, conf.height);
    };

    Bullet.prototype.setOptions = function (options) {
        var prop;
        if (options) {
            for (prop in options) {
                if (options.hasOwnProperty(prop)) {
                    this.defaults[prop] = options[prop];
                }
            }
        }
    };

    Bullet.prototype.setSource = function (source) {
        var conf = this.defaults,
            range,
            axisOrient;
        this.data = source;
        if (conf.orient === &quot;horizonal&quot;) {
            axisOrient = &quot;bottom&quot;;
            range = [conf.margin[3], conf.width - conf.margin[1]];
        } else if (conf.orient === &quot;vertical&quot;) {
            axisOrient = &quot;left&quot;;
            range = [conf.height - conf.margin[2], conf.margin[0]];
        }

        if (conf.axisStyle === &quot;linear&quot;) {
            this.scale = d3.scale.linear();
        } else if (conf.axisStyle === &quot;log&quot;) {
            this.scale = d3.scale.log();
        }

        this.data.min = this.data.ranges[0];
        this.data.max = this.data.ranges[this.data.ranges.length - 1];
        this.scale.domain([this.data.min, this.data.max])
            .range(range);

        if (conf.axisStyle === &quot;linear&quot;) {
            this.axis = DataV.Axis().scale(this.scale).orient(axisOrient).ticks(conf.tickDivide).domainAttr({&quot;stroke&quot;: &quot;none&quot;});
        } else if (conf.axisStyle === &quot;log&quot;) {
            this.logScale = d3.scale.linear()
                .domain([Math.log(this.data.min)/Math.log(conf.logBase), Math.log(this.data.max)/Math.log(conf.logBase)])
                .range(range);
            this.axis = DataV.Axis()
                .orient(axisOrient)
                .scale(this.logScale)
                .ticks(conf.tickDivide)
                .tickFormat(function (d) {return Math.round(Math.pow(conf.logBase, d));})
                .domainAttr({&quot;stroke&quot;: &quot;none&quot;});
        }
    };

    Bullet.prototype.generatePaths = function () {
        var conf = this.defaults;
        //get color function
        if (conf.backgroundColor) {
            this.color = d3.interpolateRgb.apply(null, [conf.backgroundColor[0], conf.backgroundColor[1]]);
        }
        if (conf.measureColor) {
            this.measureColor = d3.interpolateRgb.apply(null, [conf.measureColor[0], conf.measureColor[1]]);
        }

        if (conf.orient === &quot;horizonal&quot;) {
            this.paintHorizonal();
        } else if (conf.orient === &quot;vertical&quot;) {
            this.paintVertical();
        }
    };

    // orient horizonal
    Bullet.prototype.paintHorizonal = function () {
        var conf = this.defaults;
        var paper = this.canvas,
            data = this.data,
            m = conf.margin,
            ranges = [],
            measures = [],
            markers = [],
            rangeTitles = [],
            i,
            l,
            rect,
            titleRatio,
            w,
            h = conf.height - m[0] - m[2],
            left;

        //axis
        this.axis(paper).attr({transform: &quot;t&quot; + 0 + ',' + (conf.height - m[2])});
        //color rect
        ranges = data.ranges;
        if (data.rangeTitles) {
            rangeTitles = data.rangeTitles;
        }
        left = m[3];
        for (i = 0, l = ranges.length - 1; i &lt; l; i++) {
            w = this.scale(ranges[i + 1]) - this.scale(ranges[i]);
            rect = paper.rect(left, m[0], w, h)
                .attr({&quot;stroke&quot;: &quot;none&quot;,
                        &quot;fill&quot;: this.color(l === 1 ? 1 : i / (l - 1)),
                        &quot;title&quot;: rangeTitles[i] ? rangeTitles[i] : &quot;&quot;});
            left += w;
        }

        //measure bar
        data.measures.forEach(function (d, i) {
                var mTitles = data.measureTitles;
                var mTitle = mTitles &amp;&amp; mTitles[i] ? mTitles[i] : &quot;&quot;;
                measures.push({measure: d, measureTitle: mTitle});
                });
        measures.sort(function (a, b) { return d3.ascending(a.measure, b.measure) });
        left = this.scale(data.min);
        for (i = 0, l = measures.length; i &lt; l; i++) {
            value = Math.max(data.min, Math.min(data.max, measures[i].measure));
            w = this.scale(value) - left;
            paper.rect(left,
                    m[0] + h * (1 - conf.centerBarRatio) / 2,
                    w,
                    h * conf.centerBarRatio)
                .attr({&quot;stroke&quot;: &quot;none&quot;, &quot;fill&quot;: this.measureColor(l === 1 ? 1 : i / (l - 1)), &quot;title&quot;: measures[i].measureTitle});
            left += w;
        }

        //marker bar
        markers = data.markers;
        for (i = 0, l = markers.length; i &lt; l; i++) {
            paper.rect(this.scale(markers[i]) - conf.markerWidth / 2,
                    m[0] + h * (1 - conf.markerRatio) / 2,
                    conf.markerWidth,
                    h * conf.markerRatio)
                .attr({&quot;stroke&quot;: &quot;none&quot;, &quot;fill&quot;: conf.markerColor,
                        &quot;title&quot;: data.markerTitles &amp;&amp; data.markerTitles[i] ? data.markerTitles[i] : &quot;&quot;});
        }

        //title
        if (data.title) {
            titleRatio = data.subtitle ? conf.titleRatio : 1;
            this.title = paper.text(m[3] - 5, m[0] + h / 2, data.title)
            .attr({&quot;text-anchor&quot;: &quot;end&quot;, &quot;font-weight&quot;: &quot;bold&quot;, &quot;font-size&quot;: h * titleRatio * 0.9});
        }

        //subtitle
        if (data.subtitle) {
            this.subtitle = paper.text(m[3] - 5, conf.height - m[2], data.subtitle)
            .attr({&quot;text-anchor&quot;: &quot;end&quot;, &quot;font-size&quot;: h * (1 - conf.titleRatio) * 0.9});
        }
    };

    // orient vertical
    Bullet.prototype.paintVertical = function () {
        var conf = this.defaults;
        var paper = this.canvas,
            data = this.data,
            m = conf.margin,
            ranges = [],
            measures = [],
            markers = [],
            rangeTitles = [],
            i,
            l,
            rect,
            titleRatio,
            w = conf.width - m[1] - m[3],
            h,
            bottom;

        //axis
        this.axis(paper).attr({transform: &quot;t&quot; + m[3] + ',' + 0});

        //color rect
        ranges = data.ranges;
        if (data.rangeTitles) {
            rangeTitles = data.rangeTitles;
        }
        bottom = conf.height - m[2];
        for (i = 0, l = ranges.length - 1; i &lt; l; i++) {
            h = -this.scale(ranges[i + 1]) + this.scale(ranges[i]);
            rect = paper.rect(m[3], bottom - h, w, h)
                .attr({&quot;stroke&quot;: &quot;none&quot;,
                        &quot;fill&quot;: this.color(l === 1 ? 1 : i / (l - 1)),
                        &quot;title&quot;: rangeTitles[i] ? rangeTitles[i] : &quot;&quot;});
            bottom -= h;
        }

        //measure bar
        data.measures.forEach(function (d, i) {
                var mTitles = data.measureTitles;
                var mTitle = mTitles &amp;&amp; mTitles[i] ? mTitles[i] : &quot;&quot;;
                measures.push({measure: d, measureTitle: mTitle});
                });
        measures.sort(function (a, b) { return d3.ascending(a.measure, b.measure) });
        bottom = this.scale(data.min);
        for (i = 0, l = measures.length; i &lt; l; i++) {
            value = Math.max(data.min, Math.min(data.max, measures[i].measure));
            h = -this.scale(value) + bottom;
            paper.rect(m[3] + w * (1 - conf.centerBarRatio) / 2,
                    bottom - h,
                    w * conf.centerBarRatio,
                    h)
                .attr({&quot;stroke&quot;: &quot;none&quot;, &quot;fill&quot;: this.measureColor(l === 1 ? 1 : i / (l - 1)), &quot;title&quot;: measures[i].measureTitle});
            bottom -= h;
        }

        //marker bar
        markers = data.markers;
        for (i = 0, l = markers.length; i &lt; l; i++) {
            paper.rect(m[3] + w * (1 - conf.markerRatio) / 2,
                    this.scale(markers[i]) - conf.markerWidth / 2,
                    w * conf.markerRatio,
                    conf.markerWidth)
                .attr({&quot;stroke&quot;: &quot;none&quot;, &quot;fill&quot;: conf.markerColor,
                        &quot;title&quot;: data.markerTitles &amp;&amp; data.markerTitles[i] ? data.markerTitles[i] : &quot;&quot;});
        }

        //title
        if (data.title) {
            titleRatio = data.subtitle ? conf.titleRatio : 1;
            m[0] *= 0.9; //some ratio adjust;
            this.title = paper.text((conf.width + m[3] - m[1])/ 2, m[0] * titleRatio / 2, data.title)
            .attr({&quot;text-anchor&quot;: &quot;middle&quot;, &quot;font-weight&quot;: &quot;bold&quot;, &quot;font-size&quot;: m[0] * titleRatio * 0.8});
        }

        //subtitle
        if (data.subtitle) {
            this.subtitle = paper.text((conf.width + m[3] - m[1])/ 2, m[0] * (1 - (1 - titleRatio) / 2), data.subtitle)
            .attr({&quot;text-anchor&quot;: &quot;middle&quot;, &quot;font-size&quot;: m[0] * (1 - titleRatio) * 0.8});
        }
    };

    //clean canvas
    Bullet.prototype.clearCanvas = function () {
        this.canvas.clear();
    };

    //render bullet
    Bullet.prototype.render = function (options) {
        if (!this.node) {
            throw new Error(&quot;Please specify which node to render.&quot;);
        }
        this.setOptions(options);
        this.generatePaths();
    };

    module.exports = Bullet;
});</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/bundle" class="api">
  <h2>charts/bundle: API索引</h2>
  <ul class="indexs">
  
    <li>
      <a href="#_mouseoverNode">mouseoverNode</a>
    </li>

  </ul>
  <hr />

  

  <p>lobal EventProxy, d3, Raphael, self, packages, $</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>// 弦+文字+高亮某弦
;(function (name, definition) {
    if (typeof define === 'function') { // Module
        define(definition);
    } else { // Assign to common namespaces or simply the global object (window)
        this[name] = definition(function (id) { return this[id];});
    }
})('Bundle', function (require) {
    var DataV = require('DataV');

    //构造函数，container参数表示在html的哪个容器中绘制该组件
    //options对象为用户自定义的组件的属性，比如画布大小
    var Bundle = DataV.extend(DataV.Chart, {
        initialize: function (container, options) {
            this.type = &quot;Bundle&quot;;
            this.container = this.checkContainer(container);
            this.defaults = {};
            this.jsn = {};
    
            // 图的半径
            this.defaults.diameter = 960;
            this.defaults.radius = this.defaults.diameter / 2;
            this.defaults.innerRadius = this.defaults.radius - 120;
            this.defaults.tension = 0.85;
    
            this.defaults.color = {
                defaultLineColor: &quot;#4065AF&quot;,
                defaultWordColor: &quot;#000000&quot;,
                lineHoverColor: &quot;#02B0ED&quot;,
                nodeHoverColor: &quot;#02B0ED&quot;,
                importNodesColor: &quot;#5DA714&quot;, //被引用的节点
                exportNodesColor: &quot;#FE3919&quot; //引用当前节点的节点
            };
    
            this.setOptions(options);
            this.createCanvas();
        }
    });

    //设置用户自定义属性
    Bundle.prototype.setOptions = function (options) {
        if (options) {
            var prop;
            for (prop in options) {
                if (options.hasOwnProperty(prop)) {
                    this.defaults[prop] = options[prop];
                    if (prop === &quot;diameter&quot;) {
                        this.defaults.radius = this.defaults.diameter / 2;
                        this.defaults.innerRadius = this.defaults.radius - 120;
                    } else if (prop === &quot;radius&quot;) {
                        this.defaults.diameter = this.defaults.radius * 2;
                        this.defaults.innerRadius = this.defaults.radius - 120;
                    } else if (prop === &quot;innerRadius&quot;) {
                        this.defaults.radius = this.defaults.innerRadius + 120;
                        this.defaults.diameter = this.defaults.radius * 2;
                    } else if (prop === &quot;width&quot;) {
                        this.defaults.diameter = this.defaults.width;
                        this.defaults.radius = this.defaults.diameter / 2;
                        this.defaults.innerRadius = this.defaults.radius - 120;
                    }
                }
            }
        }
    };

    //对原始数据进行处理
    Bundle.prototype.setSource = function (source) {
        if (source[0] &amp;&amp; source[0] instanceof Array) {
            // csv or 2d array source
            if (source[0][0] === &quot;name&quot;) {
                source = source.slice(1); // 从第一行开始，第0行舍去
            }
            var nData = [];
            var imports = [];
            //var isNode = true;
            var nodeNum;
            var that = this;
            source.forEach(function (d, i) {
                if (d[0] === &quot;&quot;) {
                    throw new Error(&quot;name can not be empty(line:&quot; + (i + 1) + &quot;).&quot;);
                }
                if (d[1] !== &quot;&quot;) {
                    imports = d[1].split(&quot; &quot;);
                }
                nData[i] = {
                    name: d[0],
                    imports: imports
                };
            });
            this.jsn = nData;
        } else {
            // json source
            this.jsn = source;
        }
    };

    Bundle.prototype.createCanvas = function () {
        var conf = this.defaults;
        this.canvas = new Raphael(this.container, conf.diameter, conf.diameter);

        //var c = this.canvas.circle(50, 50, 40);
    };

    Bundle.prototype.layout = function () {
        var packages = {
            // Lazily construct the package hierarchy from class names.
            root: function (classes) {
                var map = {};
                function construct(name, data) {
                    var node = map[name], i;
                    if (!node) {
                        node = map[name] = data || {name: name, children: []};
                        if (name.length) {
                            node.parent = construct(name.substring(0, i = name.lastIndexOf(&quot;.&quot;)));
                            node.parent.children.push(node);
                            node.key = name.substring(i + 1);
                        }
                    }
                    return node;
                }
          
                classes.forEach(function (d) {
                    construct(d.name, d);
                });
          
                return map[&quot;&quot;];
            },
        
            // Return a list of imports for the given array of nodes.
            imports: function (nodes) {
                var map = {},
                    imports = [];
          
                // Compute a map from name to node.
                nodes.forEach(function (d) {
                    map[d.name] = d;
                });
          
                // For each import, construct a link from the source to target node.
                nodes.forEach(function (d) {
                    if (d.imports) {
                        d.imports.forEach(function (i) {imports.push({source: map[d.name], target: map[i]});
                            });
                    }
                });
          
                return imports;
            }
        };
        
        var cluster = d3.layout.cluster()
            .size([360, this.defaults.innerRadius]) //.size(角度，半径)
            .sort(null)
            .value(function (d) {
                return d.size;
            });
        this.nodes = cluster.nodes(packages.root(this.jsn));
        this.links = packages.imports(this.nodes);
    };

    Bundle.prototype.render = function () {
        this.layout();
        this.generatePaths();
    };

    Bundle.prototype.generatePaths = function (options) {
        var that = this;

        if (!this.container) {
            throw new Error(&quot;Please specify on which container to render the chart.&quot;);
        }

        var canvas = this.canvas;
        var rNodes = canvas.set();
        var rLinks = canvas.set();

        var bundle = d3.layout.bundle();

        var line = d3.svg.line.radial()
            .interpolate(&quot;bundle&quot;)
            .tension(this.defaults.tension)
            .radius(function (d) {
                return d.y;
            })
            .angle(function (d) {
                return d.x / 180 * Math.PI;
            });

        //定义图中的弦和节点
        var nodes = this.nodes;
        var links = this.links;
        var linksCount = links.length;
        var paths = bundle(links);

        var locateStr = &quot;&quot;; //对文字进行平移和旋转
        var locateBBox = &quot;&quot;; //对文字的bounding box进行平移和旋转
        var r = 0;
        var angle = 0;
        var xTrans = 0;
        var yTrans = 0;
        var anchor; //text-anchor: start or end
        var rotateStr = &quot;&quot;;

        //element data cache
        var nodeRelatedElements = {};// {key: {targetLink: [], sourceLink: [], targetNode: [], sourceNode: []}}
        var nodeElements = {}; //{key: Els}
        var bBoxElements = {}; //{key: Els}

        var i,
            j,
            key,
            textEl,
            bBox,
            bBoxNew,
            tCenterX,
            tCenterY,
            bBoxEl,
            linkEl;

        var mouseoverLink = function () {
            var current = this;
            //var color = that.data(&quot;color&quot;);
            if (rLinks.preLink) {
                rLinks.preLink.attr(&quot;stroke&quot;, that.defaults.color.defaultLineColor)
                    .attr(&quot;stroke-width&quot;, 1)
                    .attr(&quot;stroke-opacity&quot;, 0.6);

            }
            rLinks.preLink = this;

            current.attr(&quot;stroke&quot;, that.defaults.color.lineHoverColor)
                .attr(&quot;stroke-width&quot;, 2)
                .attr(&quot;stroke-opacity&quot;, 1.0)
                .toFront(); //把当前弦移到画布最上层
        };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_mouseoverNode">
    mouseoverNode
  </h3>
  

  <p>var mouseoutLink = function () {<br />            var current = this;<br />            //var color = that.data("color");<br />            current.attr("stroke", that.defaults.color.defaultLineColor)<br />                .attr("stroke-width", 1)<br />                .attr("stroke-opacity", 0.6);<br />        };</p>

  <table class="table">
  
    <tr>
      <td>函数</td>
      <td>mouseoverNode()</td> 
      <td></td>
      <td>mouseoverNode</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>var mouseoverNode = function () {
            var relatedEl = this.data(&quot;relatedElements&quot;);
            //高亮所选节点的文字颜色
            this.data(&quot;relatedNode&quot;).attr({&quot;fill&quot;: that.defaults.color.nodeHoverColor,
                &quot;fill-opacity&quot;: 1.0, &quot;font-weight&quot;: &quot;600&quot;});
            //将包围盒颜色设为透明
            this.attr({&quot;fill&quot;: that.defaults.color.nodeHoverColor, &quot;fill-opacity&quot;: 0.0</code></pre></td>
    </tr>
  
  </table>
  
  

  <p>"font-weight": "600"</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>);
            
            relatedEl.sourceLink.forEach(function (d) { //set green
                d.attr({&quot;stroke&quot;: that.defaults.color.importNodesColor, &quot;stroke-width&quot;: 1, &quot;stroke-opacity&quot;: 0.9})
                    .toFront();
            });
            relatedEl.sourceNode.forEach(function (d) {
                d.attr({&quot;fill&quot;: that.defaults.color.importNodesColor, &quot;font-weight&quot;: &quot;600&quot;});
            });
            relatedEl.targetLink.forEach(function (d) { //set red
                d.attr({&quot;stroke&quot;: that.defaults.color.exportNodesColor, &quot;stroke-width&quot;: 1, &quot;stroke-opacity&quot;: 0.9})
                    .toFront();
            });
            relatedEl.targetNode.forEach(function (d) {
                d.attr({&quot;fill&quot;: that.defaults.color.exportNodesColor, &quot;font-weight&quot;: &quot;600&quot;});
            });
        };

        var mouseoutNode = function () {
            var relatedEl = this.data(&quot;relatedElements&quot;);
            this.data(&quot;relatedNode&quot;).attr({&quot;fill&quot;: that.defaults.color.defaultWordColor,
                &quot;font-weight&quot;: &quot;400&quot;, &quot;fill-opacity&quot;: 1.0});
            relatedEl.targetLink.forEach(function (d) {
                d.attr({&quot;stroke&quot;: that.defaults.color.defaultLineColor, &quot;stroke-width&quot;: 1, &quot;stroke-opacity&quot;: 0.6});
            });
            relatedEl.targetNode.forEach(function (d) {
                d.attr({&quot;fill&quot;: that.defaults.color.defaultWordColor, &quot;font-weight&quot;: &quot;400&quot;});
            });
            relatedEl.sourceLink.forEach(function (d) {
                d.attr({&quot;stroke&quot;: that.defaults.color.defaultLineColor, &quot;stroke-width&quot;: 1, &quot;stroke-opacity&quot;: 0.6});
            });
            relatedEl.sourceNode.forEach(function (d) {
                d.attr({&quot;fill&quot;: that.defaults.color.defaultWordColor, &quot;font-weight&quot;: &quot;400&quot;});
            });
        };

        for (j = 0; j &lt; nodes.length; j++) {
            //若为叶子节点
            if (!nodes[j].children) {
                locateStr = &quot;T&quot; + that.defaults.radius + &quot;,&quot; + that.defaults.radius + &quot;R&quot;; //使用大写T、R、S--绝对，not相对

                //半径: add a padding between lines and words
                r = nodes[j].y + 20;

                //计算旋转角度和水平、竖直方向所需平移的距离
                angle = (nodes[j].x - 90) * Math.PI / 180;
                xTrans = r * Math.cos(angle);
                yTrans = r * Math.sin(angle);

                //计算text-anchor
                if (nodes[j].x &lt; 180) {
                    anchor = &quot;start&quot;;
                } else {
                    anchor = &quot;end&quot;;
                }

                //计算文字方向是否需要旋转180度
                if (nodes[j].x &lt; 180) {
                    rotateStr = &quot;&quot;;
                } else {
                    rotateStr = &quot;R180&quot;;
                }

                //计算文字需要如何经过平移和旋转被排列在圆周上
                locateStr += (nodes[j].x - 90) + rotateStr + &quot;T&quot; + xTrans + &quot;,&quot; + yTrans;

                //绘制文字
                textEl = canvas.text()
                    .attr(&quot;font&quot;, &quot;11px arial&quot;)
                    .data(&quot;color&quot;, that.defaults.color)
                    .attr(&quot;text&quot;, nodes[j].key)
                    //.attr(&quot;title&quot;, nodes[j].size)
                    .transform(locateStr)
                    .attr(&quot;text-anchor&quot;, anchor)
                    .attr(&quot;fill&quot;, that.defaults.color.defaultWordColor);

                //获取旋转平移之前文字的bounding box
                bBox = textEl.getBBox(true);

                //canvas.rect(bBox.x, bBox.y, bBox.width, bBox.height);
                //获取旋转平移之后文字的bounding box
                bBoxNew = textEl.getBBox();
                //adjust vml box center
                if (Raphael.vml) {
                    //vml's word bbox is not related to text-anchor, always middle;
                    //svg's word bbox is related to text-anchor;
                    bBoxNew.x = bBoxNew.x + bBox.width / 2 * Math.cos(angle);
                    bBoxNew.y = bBoxNew.y + bBox.width / 2 * Math.sin(angle);
                }
                //canvas.rect(bBoxNew.x, bBoxNew.y, bBoxNew.width, bBoxNew.height);

                //新旧bounding box的中心坐标变化
                tCenterX = bBoxNew.x + bBoxNew.width / 2 - bBox.x - bBox.width / 2;
                tCenterY = bBoxNew.y + bBoxNew.height / 2 - bBox.y - bBox.height / 2;
                //对bounding box进行平移和旋转
                locateBBox = &quot;T&quot; + tCenterX + &quot;,&quot; + tCenterY + &quot;R&quot; + (nodes[j].x - 90) + rotateStr;

                // 包围盒
                bBoxEl = canvas.rect(bBox.x, bBox.y, bBox.width, bBox.height)
                    .transform(locateBBox)
                    .data(&quot;relatedNode&quot;, textEl)
                    .attr({&quot;fill&quot;: &quot;#fff&quot;, &quot;opacity&quot;: 0.01});
                
                key = nodes[j].key;
                nodeElements[key] = textEl;
                bBoxElements[key] = bBoxEl;
                nodeRelatedElements[key] = {targetLink: [], sourceLink: [], targetNode: [], sourceNode: []};

                rNodes.push(textEl);
            }
        }

        //绘制曲线
        for (i = 0; i &lt; linksCount; i++) {
            var l = paths[i];

            //对paths数组中的每一项进行计算，由路径节点信息得到坐标值
            var spline = line(l);
            var sourceKey = links[i].source.key;
            var targetKey = links[i].target.key;
            var tips = &quot;link source: &quot; + sourceKey  + &quot;\n&quot;
                        + &quot;link target: &quot; + targetKey;

            linkEl = canvas.path(spline)
                //.attr(&quot;stroke&quot;, that.defaults.defaultLineColor)
                .attr(&quot;stroke-opacity&quot;, 0.6)
                .attr(&quot;title&quot;, tips)
                .attr(&quot;d&quot;, spline)
                .attr(&quot;stroke&quot;, that.defaults.color.defaultLineColor)
                .translate(that.defaults.radius, that.defaults.radius)
                .mouseover(mouseoverLink);
                //.mouseout(mouseoutLink);
            linkEl[0].el = linkEl;

            nodeRelatedElements[sourceKey].targetLink.push(linkEl);
            nodeRelatedElements[sourceKey].targetNode.push(nodeElements[targetKey]);
            nodeRelatedElements[targetKey].sourceLink.push(linkEl);
            nodeRelatedElements[targetKey].sourceNode.push(nodeElements[sourceKey]);
            rLinks.push(linkEl);
        }

        $(this.canvas.canvas).mousemove(function (e) {
                    if(!e.target.el &amp;&amp; rLinks.preLink){
                        rLinks.preLink.attr(&quot;stroke&quot;, that.defaults.color.defaultLineColor)
                            .attr(&quot;stroke-width&quot;, 1)
                            .attr(&quot;stroke-opacity&quot;, 0.6);
                        rLinks.preLink = undefined;
                        //console.log(&quot;a&quot;);
                    }
                });

        //bind text words hover event
        for (key in bBoxElements) {
            if (bBoxElements.hasOwnProperty(key)) {
                bBoxElements[key].data(&quot;relatedElements&quot;, nodeRelatedElements[key])
                    .mouseover(mouseoverNode)
                    .mouseout(mouseoutNode);
            }
        }

    };

    return Bundle;
});</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/chord" class="api">
  <h2>charts/chord: API索引</h2>
  <ul class="indexs">
  
    <li>
      <a href="#_Chord">Chord</a>
    </li>

    <li>
      <a href="#_createCanvas">createCanvas</a>
    </li>

    <li>
      <a href="#_getColor">getColor</a>
    </li>

    <li>
      <a href="#_render">render</a>
    </li>

    <li>
      <a href="#_tag">tag</a>
    </li>

    <li>
      <a href="#_setSource">setSource</a>
    </li>

    <li>
      <a href="#_layout">layout</a>
    </li>

    <li>
      <a href="#_chordLayout">chordLayout</a>
    </li>

  </ul>
  <hr />

  

  <p>lobal Raphael, d3, $, define</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>;(function (name, definition) {
    if (typeof define === 'function') { // Module
        define(definition);
    } else { // Assign to common namespaces or simply the global object (window)
        this[name] = definition(function (id) {
            return this[id];
        });
    }
})('Chord', function (require) {
    var DataV = require('DataV');</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_Chord">
    Chord
  </h3>
  

  <p>构造函数</p>

  <table class="table">
  
    <tr>
      <td>声明</td>
      <td>Chord</td> 
      <td></td>
      <td>Chord</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>container(Object)</td>
      <td colspan="2">表示在html的哪个容器中绘制该组件</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>options(Object)</td>
      <td colspan="2">为用户自定义的组件的属性，比如画布大小</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>var Chord = DataV.extend(DataV.Chart, {
        initialize: function (container, options) {
            this.type = &quot;Chord&quot;;
            this.node = this.checkContainer(container);
            this.defaults = {};
            this.matrix = [];
            this.groupNames = []; //数组：记录每个group的名字

            //图的大小设置
            this.defaults.tag = true;
            this.defaults.width = 800;
            this.defaults.height = 800;

            //设置用户指定的属性
            this.setOptions(options);

            this.tagArea = [20, (this.defaults.height - 20 - 220), 200, 220];
            if (this.defaults.tag) {
                this.xOffset = this.tagArea[2];
            } else {
                this.xOffset = 0;
            }

            this.defaults.innerRadius = Math.min((this.defaults.width - this.xOffset), this.defaults.height) * 0.38;
            this.defaults.outerRadius = this.defaults.innerRadius * 1.10;
            //创建画布
            this.createCanvas();
        }
    });</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_createCanvas">
    createCanvas
  </h3>
  

  <p>创建画布</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Chord.prototype.createCanvas()</td> 
      <td></td>
      <td>createCanvas</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Chord.prototype.createCanvas = function () {
        this.canvas = new Raphael(this.node, this.defaults.width, this.defaults.height);
        canvasStyle = this.node.style;
        canvasStyle.position = &quot;relative&quot;;
        this.floatTag = DataV.FloatTag()(this.node);
        this.floatTag.css({
            &quot;visibility&quot;: &quot;hidden&quot;
        });
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_getColor">
    getColor
  </h3>
  

  <p>获取颜色</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Chord.prototype.getColor()</td> 
      <td></td>
      <td>getColor</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>i(Number)</td>
      <td colspan="2">元素类别编号</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>String</td>
      <td colspan="2">返回颜色值</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Chord.prototype.getColor = function (i) {
        var color = DataV.getColor();
        return color[i % color.length][0];
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_render">
    render
  </h3>
  

  <p>绘制弦图</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Chord.prototype.render()</td> 
      <td></td>
      <td>render</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Chord.prototype.render = function () {
        this.layout();
        if (this.defaults.tag) {
            this.tag();
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_tag">
    tag
  </h3>
  

  <p>绘制图例</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Chord.prototype.tag()</td> 
      <td></td>
      <td>tag</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Chord.prototype.tag = function () {
        var that = this;
        var paper = this.canvas;
        var tagArea = this.tagArea;
        var rectBn = paper.set();
        this.underBn = [];
        var underBn = this.underBn;
        for (i = 0; i &lt;= this.groupNum; i++) {
            //底框
            underBn.push(paper.rect(tagArea[0] + 10, tagArea[1] + 10 + (20 + 3) * i, 180, 20).attr({
                &quot;fill&quot;: &quot;#ebebeb&quot;,
                &quot;stroke&quot;: &quot;none&quot;
                //&quot;r&quot;: 3
            }).hide());
            //色框
            paper.rect(tagArea[0] + 10 + 3, tagArea[1] + 10 + (20 + 3) * i + 6, 16, 8).attr({
                &quot;fill&quot;: this.getColor(i),
                &quot;stroke&quot;: &quot;none&quot;
            });
            //文字
            paper.text(tagArea[0] + 10 + 3 + 16 + 8, tagArea[1] + 10 + (20 + 3) * i + 10, this.groupNames[i]).attr({
                &quot;fill&quot;: &quot;black&quot;,
                &quot;fill-opacity&quot;: 1,
                &quot;font-family&quot;: &quot;Verdana&quot;,
                &quot;font-size&quot;: 12
            }).attr({
                &quot;text-anchor&quot;: &quot;start&quot;
            });
            //选框
            rectBn.push(paper.rect(tagArea[0] + 10, tagArea[1] + 10 + (20 + 3) * i, 180, 20).attr({
                &quot;fill&quot;: &quot;white&quot;,
                &quot;fill-opacity&quot;: 0,
                &quot;stroke&quot;: &quot;none&quot;
                //&quot;r&quot;: 3
            })).data(&quot;clicked&quot;, 0);
        }
        rectBn.forEach(function (d, i) {
            d.mouseover(function () {
                if (d.data(&quot;clicked&quot;) === 0) {
                    underBn[i].attr('opacity', 0.5);
                    underBn[i].show();
                }
            }).mouseout(function () {
                if (d.data(&quot;clicked&quot;) === 0) {
                    underBn[i].hide();
                }
            });
            d.click(function () {
                for (j = 0; j &lt; underBn.length; j++) {
                    if (j === i) {
                        underBn[j].show();
                    } else {
                        underBn[j].hide();
                    }
                }
                rectBn.forEach(function (eachBn) {
                    if (eachBn !== d) {
                        eachBn.data(&quot;clicked&quot;, 0);
                    }
                });
                if (d.data(&quot;clicked&quot;) === 0) {
                    underBn[i].attr('opacity', 1);
                    underBn[i].show();
                    that.chordGroups.forEach(function (d) {
                        if (d.data('source') !== i &amp;&amp; d.data('target') !== i) {
                            d.attr({
                                'fill-opacity': 0.1
                            });
                        } else {
                            d.attr({
                                'fill-opacity': 0.6
                            });
                        }
                    });

                    d.data(&quot;clicked&quot;, 1);
                } else if (d.data(&quot;clicked&quot;) === 1) {
                    underBn[i].hide();
                    d.data(&quot;clicked&quot;, 0);
                    that.chordGroups.forEach(function (d) {
                        d.attr({
                            'fill-opacity': 0.6
                        });
                    });
                }
            });
        });
    }</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setSource">
    setSource
  </h3>
  

  <p>对原始数据进行处理</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Chord.prototype.setSource()</td> 
      <td></td>
      <td>setSource</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>table(Array)</td>
      <td colspan="2">将要被绘制成饼图的二维表数据</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Chord.prototype.setSource = function (table) {
        if (table[0][0] !== null) {
            var t;
            for (t = 0; t &lt; table[0].length; t++) {
                this.groupNames[t] = table[0][t];
            }
            table = table.slice(1); // 从第一行开始，第0行舍去
        }

        var group = [];
        this.groupNum = table[0].length;
        var groupNum = this.groupNum;
        var that = this;
        table.forEach(function (d, i) {
            if (d.length !== groupNum || table.length !== groupNum) {
                throw new Error(&quot;The source data should be an n * n matrix!&quot;);
            }

            group[i] = [];
            var s;
            for (s = 0; s &lt; groupNum; s++) {
                group[i][s] = Number(d[s]);
            }
        });

        var r;
        for (r = 0; r &lt; groupNum; r++) {
            that.matrix[r] = group[r];
        }

    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_layout">
    layout
  </h3>
  

  <p>创建chord布局</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Chord.prototype.layout()</td> 
      <td></td>
      <td>layout</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Chord.prototype.layout = function () {
        var floatTag = this.floatTag;
        var that = this;

        that.canvas.clear();</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_chordLayout">
    chordLayout
  </h3>
  

  <p>ar see = [<br />            [11975, 5871, 8916, 2868],<br />            [1951, 10048, 2060, 6171],<br />            [8010, 16145, 8090, 8045],<br />            [1013, 990, 940, 6907] <br /><br />        ];</p>

  <table class="table">
  
    <tr>
      <td>声明</td>
      <td>chordLayout</td> 
      <td></td>
      <td>chordLayout</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>var chordLayout = d3.layout.chord().padding(0.05) //chord segments之间的padding间隔
        .sortSubgroups(d3.descending) //chord segments细分后的排序规则
        .matrix(that.matrix);</code></pre></td>
    </tr>
  
  </table>
  
  

  <p>ar fillColor = d3.scale.ordinal()<br />            .domain(d3.range(4))<br />            .range(["#000000", "#FFDD89", "#957244", "#F26223"]);</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>//groups数组：获取每个组的起始角度、数值、索引等属性
        var groups = chordLayout.groups();

        //由内外半径、起始角度计算路径字符串
        var pathCalc = d3.svg.arc().innerRadius(that.defaults.innerRadius).outerRadius(that.defaults.outerRadius).startAngle(function (d) {
            return d.startAngle;
        }).endAngle(function (d) {
            return d.endAngle;
        });

        var chords = chordLayout.chords();

        //计算弦的路径曲线
        var chordCalc = d3.svg.chord().radius(that.defaults.innerRadius);

        //Raphael: Paper.path()
        var donutEle;
        //获取每个环形的字符串表示
        var spline;
        //表示每条弦的element
        var chordEle;
        //每条弦的字符串表示
        var belt;

        var num; //每个group分割小格数
        var unitAngle; //每个group所占的角度
        var angle;
        var radian;
        var tickLine;
        var tickStr; //每个tick的路径
        var xTrans, yTrans;
        var aX, aY, bX, bY; //每个tick起始端点的坐标
        var anchor;
        var rotateStr;
        var wordStr;
        var word;
        var textEl;
        var wXTrans, wYTrans;
        var tips;
        var minValue = 1000;
        that.chordGroups = that.canvas.set();
        that.donutGroups = that.canvas.set();

        $(&quot;#&quot; + this.container).append(this.floatTag);

        //计算某条弦被赋值为target或source的颜色
        var colorCalc = function (index) {
            var i = chords[index].target.value &gt; chords[index].source.value ? chords[index].target.index : chords[index].source.index;
            return i;
        };

        //添加透明效果

        var mouseOverDonut = function () {
            floatTag.html('&lt;div style = &quot;text-align: center;margin:auto;color:'
            //+ jqNode.color
            +
            &quot;#ffffff&quot; + '&quot;&gt;' + this.data('text') + '&lt;/div&gt;');
            floatTag.css({
                &quot;visibility&quot;: &quot;visible&quot;
            });
            that.underBn.forEach(function (d) {
                d.hide();
            });
            index = this.data(&quot;donutIndex&quot;);
            that.chordGroups.forEach(function (d) {
                if (d.data('source') !== index &amp;&amp; d.data('target') !== index) {
                    d.attr({
                        'fill-opacity': 0.1
                    });
                } else {
                    d.attr({
                        'fill-opacity': 0.6
                    });
                }
            });
            //fade(this.data(&quot;donutIndex&quot;), 0.2);
            that.underBn[index].attr('opacity', 0.5).show();

        };

        var mouseOutDonut = function () {
            floatTag.css({
                &quot;visibility&quot;: &quot;hidden&quot;
            });
            index = this.data(&quot;donutIndex&quot;);
            that.chordGroups.forEach(function (d) {
                if (d.data('source') !== index &amp;&amp; d.data('target') !== index) {
                    d.attr({
                        'fill-opacity': 0.6
                    });
                }
            });
            //fade(this.data(&quot;donutIndex&quot;), 0.6);
            that.underBn[index].hide();
        };

        var mouseoverChord = function () {
            floatTag.html('&lt;div style = &quot;text-align: center;margin:auto;color:'
            //+ jqNode.color
            +
            &quot;#ffffff&quot; + '&quot;&gt;' + this.data('text') + '&lt;/div&gt;');
            floatTag.css({
                &quot;visibility&quot;: &quot;visible&quot;
            });
            that.underBn.forEach(function (d) {
                d.hide();
            });
            that.chordGroups.forEach(function (d) {
                d.attr(&quot;fill-opacity&quot;, 0.1);
            });
            if (navigator.appName !== &quot;Microsoft Internet Explorer&quot;) {
                this.toFront(); //把当前弦移到画布最上层
            }
            this.attr(&quot;fill-opacity&quot;, 0.7);
            that.underBn[this.data('source')].attr('opacity', 0.5).show();
        };

        var mouseoutChord = function () {
            floatTag.css({
                &quot;visibility&quot;: &quot;hidden&quot;
            });
            //alert(&quot;***&quot;);
            that.chordGroups.forEach(function (d) {
                d.attr(&quot;fill-opacity&quot;, 0.6);
            });
            //this.attr(&quot;fill-opacity&quot;, 0.6);
            that.underBn[this.data('source')].hide();
        };

        //画弦*********************************************************
        var t;
        for (t = 0; t &lt;= chords.length - 1; t++) {
            //alert(chords.length);
            belt = chordCalc(chords[t]);
            //hover到弦上时的效果
            tips = that.groupNames[chords[t].source.index] + &quot; to &quot; + that.groupNames[chords[t].target.index] + &quot;: &quot; + that.matrix[chords[t].source.index][chords[t].target.index] + &quot;,&quot; + that.groupNames[chords[t].target.index] + &quot; to &quot; + that.groupNames[chords[t].source.index] + &quot;: &quot; + that.matrix[chords[t].target.index][chords[t].source.index];

            chordEle = that.canvas.path(belt).
            translate((that.defaults.width - this.xOffset) / 2 + this.xOffset, that.defaults.height / 2).attr({
                &quot;path&quot;: belt,
                &quot;fill&quot;: that.getColor(colorCalc(t)),
                &quot;fill-opacity&quot;: 0.6,
                &quot;stroke&quot;: &quot;#d6d6d6&quot;,
                &quot;stroke-opacity&quot;: 0.1
            }).hover(mouseoverChord, mouseoutChord).data(&quot;source&quot;, chords[t].source.index).data(&quot;target&quot;, chords[t].target.index);
            //.attr(&quot;fill&quot;, fillColor(chords[t].target.index))
            chordEle.data('text', tips);
            that.chordGroups.push(chordEle);
        }



        //画圆弧*********************************************************
        var i, r;
        var donutName;
        var nameStr;
        var nameX, nameY;
        var ro, a;
        var sum = 0;
        for (r = 0; r &lt;= groups.length - 1; r++) {
            sum += groups[r].value;
        }

        for (i = 0; i &lt;= groups.length - 1; i++) {
            //画外圈的pie图**************************************
            //计算每个group的path
            spline = pathCalc(groups[i]);
            tips = that.groupNames[i] + &quot;: &quot; + Math.round(groups[i].value) + &quot; &quot; + (groups[i].value * 100 / sum).toFixed(2) + &quot;%&quot;;

            donutEle = that.canvas.path(spline).translate((that.defaults.width - this.xOffset) / 2 + this.xOffset, that.defaults.height / 2).data(&quot;donutIndex&quot;, i).attr({
                &quot;path&quot;: spline,
                &quot;fill&quot;: that.getColor(i),
                &quot;stroke&quot;: that.getColor(i)
            }).mouseover(mouseOverDonut).mouseout(mouseOutDonut);
            donutEle.data('text', tips);
            that.donutGroups.push(donutEle);

            //每个donut上显示名称
            ro = groups[i].startAngle * 180 / Math.PI - 86 + 90;
            a = (groups[i].startAngle * 180 / Math.PI - 86) * Math.PI / 180;
            nameX = ((that.defaults.outerRadius - that.defaults.innerRadius) / 2 + that.defaults.innerRadius) * Math.cos(a);
            nameY = ((that.defaults.outerRadius - that.defaults.innerRadius) / 2 + that.defaults.innerRadius) * Math.sin(a);
            nameStr = &quot;T&quot; + ((that.defaults.width - that.xOffset) / 2 + that.xOffset) + &quot;,&quot; + that.defaults.height / 2 + &quot;R&quot; + ro + &quot;T&quot; + nameX + &quot;,&quot; + nameY;

            if ((groups[i].endAngle - groups[i].startAngle) * 180 / Math.PI &gt; 10) {
                donutName = that.canvas.text().attr(&quot;font&quot;, &quot;12px Verdana&quot;).attr(&quot;text&quot;, that.groupNames[i]).transform(nameStr);
            }

            //画刻度和刻度值**************************************
            num = groups[i].value / 5000;
            //最细分的每个小格代表的数值大小
            unitAngle = (groups[i].endAngle - groups[i].startAngle) * 180 / Math.PI / num;

            var j;
            for (j = 0; j &lt;= num; j++) {
                //计算旋转角度和水平、竖直方向所需平移的距离
                radian = ((groups[i].startAngle * 180 / Math.PI - 90) + j * unitAngle);
                angle = radian * Math.PI / 180;
                xTrans = that.defaults.outerRadius * Math.cos(angle);
                yTrans = that.defaults.outerRadius * Math.sin(angle);

                tickStr = &quot;T&quot; + ((that.defaults.width - that.xOffset) / 2 + that.xOffset) + &quot;,&quot; + that.defaults.height / 2 + &quot;T&quot; + xTrans + &quot;,&quot; + yTrans;

                //刻度线的起点终点坐标
                aX = ((that.defaults.width - that.xOffset) / 2 + that.xOffset) + xTrans;
                aY = that.defaults.height / 2 + yTrans;
                bX = ((that.defaults.width - that.xOffset) / 2 + that.xOffset) + (that.defaults.outerRadius + 6) * Math.cos(angle);
                bY = that.defaults.height / 2 + (that.defaults.outerRadius + 6) * Math.sin(angle);

                tickLine = &quot;M&quot; + aX + &quot;,&quot; + aY + &quot;L&quot; + bX + &quot;,&quot; + bY;
                that.canvas.path(tickLine).attr({
                    'stroke': &quot;#929292&quot;,
                    &quot;stroke-width&quot;: '1px'
                }); //绘制刻度

                //每隔五个刻度，绘制一次文字
                if (j % 2 === 0) {
                    //计算text-anchor
                    if (radian + 90 &lt; 180) {
                        anchor = &quot;start&quot;;
                    } else {
                        anchor = &quot;end&quot;;
                    }

                    //计算文字方向是否需要旋转180度
                    if (radian + 90 &lt; 180) {
                        rotateStr = null;
                    } else {
                        rotateStr = &quot;R180&quot;;
                    }

                    wXTrans = (that.defaults.outerRadius + 10) * Math.cos(angle);
                    wYTrans = (that.defaults.outerRadius + 10) * Math.sin(angle);

                    word = j % 2 ? &quot;&quot; : Math.round(((groups[i].value / num) * j) / 1000);

                    wordStr = &quot;T&quot; + ((that.defaults.width - that.xOffset) / 2 + that.xOffset) + &quot;,&quot; + that.defaults.height / 2 + &quot;R&quot; + radian</code></pre></td>
    </tr>
  
  </table>
  
  

  <p>groups[i].startAngle * 180 / Math.PI - 90)</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>+ rotateStr + &quot;T&quot; + wXTrans + &quot;,&quot; + wYTrans;

                    //绘制文字
                    textEl = that.canvas.text(0, 0, word).attr(&quot;font&quot;, &quot;12px Verdana&quot;).transform(wordStr).attr(&quot;text-anchor&quot;, anchor).attr('fill', &quot;#929292&quot;);
                }
            }
        }</code></pre></td>
    </tr>
  
  </table>
  
  

  <p>his.canvas.text().attr("font", "12px arial").translate((that.defaults.width - this.xOffset) / 2 + this.xOffset, this.defaults.height).attr("text", "The unit of the scale on the periphery is 1000. \n 刻度值的单位为1000。");</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>};

    return Chord;
});</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/flow" class="api">
  <h2>charts/flow: API索引</h2>
  <ul class="indexs">
  
  </ul>
  <hr />

  

  <p>lobal EventProxy, d3, Raphael, $</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>define(function (require, exports, module) {
    var DataV = require('datav');
    var theme = DataV.Themes;

    var Flow = DataV.extend(DataV.Chart, {
        initialize: function (container, options) {
            this.type = &quot;Flow&quot;;
            this.container = container;
            this.defaults = {};

            // Properties
            this.font = {};

            // Canvas
            this.defaults.width = 500;
            this.defaults.height = 400;
            this.defaults.deep = 150;
            this.defaults.radius = 50;
            this.defaults.xStep = 300;
            this.defaults.xStart = 200;
            this.defaults.yStart = 50;

            this.setOptions(options);
            this.emitter = new EventProxy();
            this.createCanvas();
        }
    });

    Flow.prototype.on = function (eventName, callback) {
        this.emitter.on(eventName, callback);
    };

    Flow.prototype.setOptions = function (options) {
        var prop;
        if (options) {
            for (prop in options) {
                if (options.hasOwnProperty(prop)) {
                    this.defaults[prop] = options[prop];
                }
            }
        }
    };

    Flow.prototype.setSource = function (source) {
        var conf = this.defaults;

        this.rawData = source;
        this.source = this.remapSource(source);
    };

    Flow.prototype.remapSource = function (data) {
        console.log(data);
        var dataLength = data.length;
        var remapData = [];

        var total;
        var i;
        for (i = 0; i &lt; dataLength; i++){
            if (!data[i][3]) {
                total = data[i][2];
                remapData.push({id: data[i][0], name: data[i][1], value: data[i][2], pid: data[i][3], child: [], deep: 0});
            } else {
                remapData.push({id: data[i][0], name: data[i][1], value: data[i][2], pid: data[i][3], child: [], deep: 0});
            }
        } 

        var conf = this.defaults;
        var width = conf.width;
        var height = conf.height;
        var radius = conf.radius;
        var xStep = conf.xStep;
        var xStart = conf.xStart;
        var yStart = conf.yStart;
        var depth = 0;

        for (i = 0; i &lt; dataLength; i++){
            if (remapData[i].pid) {
                remapData[i].deep = remapData[remapData[i].pid - 1].deep + 1;
                remapData[remapData[i].pid - 1].child.push(remapData[i].id - 1);
                if (remapData[i].deep &gt; depth) {
                    depth = remapData[i].deep;
                }
            } 
            // remapData[remapData[i].pid].child.push(remapData[i].id);
        }

        this.depth = depth;
        radius = Math.min(Math.min((width - xStep * (depth - 1) - xStart * 2) / depth, height*0.55), radius);
        console.log(&quot;r:&quot; + radius);
        for (i = 0; i &lt; dataLength; i++){
            remapData[i].percent = remapData[i].value / total;
            remapData[i].radius = radius * remapData[i].percent;
            console.log(&quot;r:&quot; + remapData[i].radius + &quot; p:&quot; + remapData[i].percent);
        }

        console.log(remapData);
        return remapData;
        // return data;
    };

    Flow.prototype.layout = function () {
        var conf = this.defaults;
        var width = conf.width;
        var height = conf.height;
        var xStart = conf.xStart;
        var yStart = conf.yStart;
        var xStep = conf.xStep;
        var remapData = this.source;

        //console.log(this.source);
        var circleData = [];

        circleData.push({x: width * 0.24, y: height * 0.42, radius: Math.max(10, remapData[0].radius), deep: remapData[0].deep, name: remapData[0].name, value: remapData[0].value});
        circleData.push({x: width * 0.5, y: height * 0.245, radius: Math.max(10, remapData[1].radius), deep: remapData[1].deep, name: remapData[1].name, value: remapData[1].value});
        circleData.push({x: width * 0.5, y: height * 0.6, radius: Math.max(10, remapData[2].radius), deep: remapData[2].deep, name: remapData[2].name, value: remapData[2].value});
        circleData.push({x: width * 0.72, y: height * 0.5, radius: Math.max(10, remapData[3].radius), deep: remapData[3].deep, name: remapData[3].name, value: remapData[3].value});
        circleData.push({x: width * 0.72, y: height * 0.817, radius: Math.max(10, remapData[4].radius), deep: remapData[4].deep, name: remapData[4].name, value: remapData[4].value});

        for (i = 0;i &lt; circleData.length; i++) {
            console.log(circleData[i].x);
        }

        this.circleData = circleData;
    };

    Flow.prototype.getColor = function () {

        var colorMatrix = DataV.getColor();
        
        return color;
    };

    // Tree.prototype.getFont = function () {
    //     //var conf = this.defaults;

    //     return DataV.getFont();
    // };

    Flow.prototype.createCanvas = function () {
        var conf = this.defaults;
        this.canvas = new Raphael(this.container, conf.width, conf.height);

        this.DOMNode = $(this.canvas.canvas);
        var that = this;
        this.DOMNode.click(function (event) {
            that.emitter.trigger(&quot;click&quot;, event);
        });
        this.DOMNode.dblclick(function (event) {
            that.emitter.trigger(&quot;dblclick&quot;, event);
        });

        var mousewheel = document.all ? &quot;mousewheel&quot; : &quot;DOMMouseScroll&quot;;  
        this.DOMNode.bind(mousewheel, function (event) {
            that.emitter.trigger(&quot;mousewheel&quot;, event);
        });

        this.DOMNode.bind(&quot;contextmenu&quot;, function (event) {
            that.emitter.trigger(&quot;contextmenu&quot;, event);
        });

        this.DOMNode.delegate(&quot;circle&quot;, &quot;click&quot;, function (event) {
            that.emitter.trigger(&quot;circle_click&quot;, event);
        });

        this.DOMNode.delegate(&quot;circle&quot;, &quot;mouseover&quot;, function (event) {
            that.emitter.trigger(&quot;circle_mouseover&quot;, event);
        });

        this.DOMNode.delegate(&quot;circle&quot;, &quot;mouseout&quot;, function (event) {
            that.emitter.trigger(&quot;circle_mouseout&quot;, event);
        });

        //console.log(this.canvas);
    };


    Flow.prototype.getLinkPath = function (fx, fy, tx, ty) {
        var conf = this.defaults;

        var c1x = fx + (tx - fx) / 1.5;
        var c1y = fy;
        var c2x = tx - (tx - fx) / 4;
        var c2y = ty - (ty - fy) / 2;

        var link_path = [[&quot;M&quot;, fx, fy], 
            [&quot;S&quot;, c1x, c1y, tx, ty]];

        return link_path;  
    };

    Flow.prototype.generatePaths = function () {
        var canvas = this.canvas;
        var source = this.source;
        var conf = this.defaults;
        var radius = conf.radius;
        //canvas.clear();
        // var font = this.getFont();
        var font_family = '微软雅黑';
        var font_size = 8;
        var depth = this.depth;
        var crilceData = this.circleData;
        var l = crilceData.length;
        var getLinkPath = this.getLinkPath;

        canvas.path().attr({stroke:  &quot;#cdcdcd&quot;, &quot;stroke-width&quot;: 2}).attr({path: getLinkPath(crilceData[0].x, crilceData[0].y, crilceData[1].x, crilceData[1].y)});
        canvas.path().attr({stroke:  &quot;#cdcdcd&quot;, &quot;stroke-width&quot;: 2}).attr({path: getLinkPath(crilceData[0].x, crilceData[0].y, crilceData[2].x, crilceData[2].y)});
        canvas.path().attr({stroke:  &quot;#cdcdcd&quot;, &quot;stroke-width&quot;: 2}).attr({path: getLinkPath(crilceData[2].x, crilceData[2].y, crilceData[3].x, crilceData[3].y)});
        canvas.path().attr({stroke:  &quot;#cdcdcd&quot;, &quot;stroke-width&quot;: 2}).attr({path: getLinkPath(crilceData[2].x, crilceData[2].y, crilceData[4].x, crilceData[4].y)});

        var i, d
        var thisRadius;
        var thisColor;
        var titelPath = [];
        var valuePath = [];
        for (i = 0 ; i &lt; l ; i++) {
            d = crilceData[i];
            thisRadius = Math.max(27, d.radius);
            if (i === 1) {
                thisColor = &quot;#b4e481&quot;;
            } else if (i === 4) {
                thisColor = &quot;#cd3a19&quot;;
            } else {
                thisColor = &quot;#ffe79d&quot;;
            }
            canvas.circle(d.x, d.y, thisRadius)
            .attr({&quot;stroke&quot;: &quot;none&quot;, fill: thisColor});
            titelPath.push(canvas.text(0, 0, d.name).attr({'font-size': 12}));
            if (i &lt; l - 2) { 
                titelPath[i].transform(&quot;t&quot; + d.x + &quot;,&quot; + (d.y - thisRadius - titelPath[i].getBBox().height/2 - 5));
            } else {
                titelPath[i].transform(&quot;t&quot; + d.x + &quot;,&quot; + (d.y - thisRadius - titelPath[i].getBBox().height/2 - 5)).attr({&quot;text-anchor&quot;: &quot;start&quot;});
            }

            if (i &lt; l - 1) {
                valuePath.push(canvas.text(d.x, d.y, d.value + &quot;人&quot;).attr({'font-size': 12}));
            } else {
                valuePath.push(canvas.text(d.x, d.y, d.value + &quot;人&quot;).attr({fill: &quot;#ffffff&quot;, 'font-size': 12}));
            }
        }

        var n = 0;

        var node;
        var num = 0;

        var nodes = canvas.set();
        var path = [];
        var textpath = [];
        
        var tree = this;

    };
    

    Flow.prototype.render = function (options) {
        var st = new Date().getTime();
        if (!this.container) {
            throw new Error(&quot;Please specify which node to render.&quot;);
        }
        this.canvas.clear();
        this.setOptions(options);
        this.layout();
        var st2 = new Date().getTime();
        console.log(st2 - st);

        this.generatePaths();
        var et = new Date().getTime();
        console.log(et - st2);
        //this.canvas.renderfix();
    };

    module.exports = Flow;
});</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/force" class="api">
  <h2>charts/force: API索引</h2>
  <ul class="indexs">
  
    <li>
      <a href="#_Force">Force</a>
    </li>

    <li>
      <a href="#_setSource">setSource</a>
    </li>

    <li>
      <a href="#_createCanvas">createCanvas</a>
    </li>

    <li>
      <a href="#_getColor">getColor</a>
    </li>

    <li>
      <a href="#_getRadius">getRadius</a>
    </li>

    <li>
      <a href="#_getOpacity">getOpacity</a>
    </li>

    <li>
      <a href="#_update">update</a>
    </li>

    <li>
      <a href="#_tag">tag</a>
    </li>

    <li>
      <a href="#_layout">layout</a>
    </li>

    <li>
      <a href="#_animate">animate</a>
    </li>

    <li>
      <a href="#_setOptions">setOptions</a>
    </li>

    <li>
      <a href="#_render">render</a>
    </li>

  </ul>
  <hr />

  

  <p>lobal Raphael, d3</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>;(function (name, definition) {
    if (typeof define === 'function') { // Module
        define(definition);
    } else { // Assign to common namespaces or simply the global object (window)
        this[name] = definition(function (id) {
            return this[id];
        });
    }
})('Force', function (require) {
    var DataV = require('DataV');</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_Force">
    Force
  </h3>
  

  <p>构造函数</p>

  <table class="table">
  
    <tr>
      <td>声明</td>
      <td>Force</td> 
      <td></td>
      <td>Force</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>container(Object)</td>
      <td colspan="2">表示在html的哪个容器中绘制该组件</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>options(Object)</td>
      <td colspan="2">为用户自定义的组件的属性，比如画布大小</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>var Force = DataV.extend(DataV.Chart, {
        initialize: function (container, options) {
            this.type = &quot;Force&quot;;
            this.container = container;
            this.defaults = {};
            this.net = {};
            this.linkValeMin = 0;
            this.linkValeMax = 1;
            this.nodeValueMin = 0;
            this.nodeValueMax = 1;
            this.clicked = false;
            this.clickedNum = -1;
            this.tagClicked = false;

            // Properties
            this.font = {};

            // Canvas
            this.defaults.tag = true;
            this.defaults.width = 500;
            this.defaults.height = 500;
            this.defaults.linkLength = 50;
            this.defaults.linkWidth = 2;
            this.defaults.classNum = 6;
            this.defaults.forceValue = 10;
            this.defaults.iterate = 100;
            this.defaults.browserName = navigator.appName;

            this.setOptions(options);
            this.defaults.charge = -(this.defaults.width + this.defaults.height) / this.defaults.forceValue;
            this.tagArea = [20, (this.defaults.height - 20 - this.defaults.classNum * 20), 200, 220];
            if (this.defaults.tag) {
                this.xOffset = this.tagArea[2];
            } else {
                this.xOffset = 0;
            }

            this.createCanvas();
        }
    });</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setSource">
    setSource
  </h3>
  

  <p>Set CSV content to force-directed net</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Force.prototype.setSource()</td> 
      <td></td>
      <td>setSource</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>table(Array)</td>
      <td colspan="2">the csv table to be rendered</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Force.prototype.setSource = function (table) {
        //this.net = json;
        if (table[0][0] === &quot;Id&quot;) {
            table = table.slice(1);
        }
        var nData = [];
        var lData = [];
        var isNode = true;
        var nodeNum;
        var that = this;
        table.forEach(function (d, i) {
            var value;
            if (isNode) {
                if (d[0] === &quot;Source&quot;) {
                    isNode = false;
                    nodeNum = i + 1;
                } else {
                    if (d[0] === &quot;&quot;) {
                        throw new Error(&quot;ID can not be empty(line:&quot; + (i + 1) + &quot;).&quot;);
                    }
                    value = that._toNum(d[2]);
                    nData[i] = {
                        name: d[1],
                        nodeValue: value
                    };
                    if (i === 0) {
                        that.nodeValueMin = value;
                        that.nodeValueMax = value;
                    }
                    that.nodeValueMin = (value &lt; that.nodeValueMin) ? value : that.nodeValueMin;
                    that.nodeValueMax = (value &gt; that.nodeValueMax) ? value : that.nodeValueMax;
                }
            } else {
                if (d[0] === &quot;&quot;) {
                    throw new Error(&quot;Source can not be empty(line:&quot; + (i + 1) + &quot;).&quot;);
                }
                if (d[1] === &quot;&quot;) {
                    throw new Error(&quot;Target can not be empty(line:&quot; + (i + 1) + &quot;).&quot;);
                }
                value = that._toNum(d[2]);
                lData[i - nodeNum] = {
                    source: that._toNum(d[0]),
                    target: that._toNum(d[1]),
                    value: that._toNum(d[2])
                };
                if (i === nodeNum) {
                    that.linkValueMin = value;
                    that.linkValueMax = value;
                }
                that.linkValueMin = (value &lt; that.linkValueMin) ? value : that.linkValueMin;
                that.linkValueMax = (value &gt; that.linkValueMax) ? value : that.linkValueMax;
            }
        });
        this.net.nodes = nData;
        this.net.links = lData;
        this.nodeValueMax++;
        this.linkValueMax++;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_createCanvas">
    createCanvas
  </h3>
  

  <p>创建画布</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Force.prototype.createCanvas()</td> 
      <td></td>
      <td>createCanvas</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Force.prototype.createCanvas = function () {
        var conf = this.defaults;
        this.canvas = new Raphael(this.container, conf.width, conf.height);
        //var c = this.canvas.circle(50, 50, 40);
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_getColor">
    getColor
  </h3>
  

  <p>获取节点颜色</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Force.prototype.getColor()</td> 
      <td></td>
      <td>getColor</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>i(Number)</td>
      <td colspan="2">元素类别编号</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>String</td>
      <td colspan="2">返回颜色值</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Force.prototype.getColor = function (i) {
        var color = DataV.getColor(this.classNum);
        //var k = color.length * (i - this.nodeValueMin-0.1) / (this.nodeValueMax - this.nodeValueMin);
        //if (k &lt; 0) k = 0;
        return color[i % color.length][0];
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_getRadius">
    getRadius
  </h3>
  

  <p>获取节点的半径</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Force.prototype.getRadius()</td> 
      <td></td>
      <td>getRadius</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>value(Number)</td>
      <td colspan="2">元素对应的数据值</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>Number</td>
      <td colspan="2">返回半径值</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Force.prototype.getRadius = function (value) {
        var conf = this.defaults;
        return 16.0 * (value - this.nodeValueMin) / (this.nodeValueMax - this.nodeValueMin) + 8;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_getOpacity">
    getOpacity
  </h3>
  

  <p>获取节点透明度</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Force.prototype.getOpacity()</td> 
      <td></td>
      <td>getOpacity</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>value(Number)</td>
      <td colspan="2">元素类别编号</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>Number</td>
      <td colspan="2">返回透明度值</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Force.prototype.getOpacity = function (value) {
        return 0.083 * (value - this.linkValueMin) / (this.linkValueMax - this.linkValueMin) + 0.078;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_update">
    update
  </h3>
  

  <p>update the layout by modify the attributes of nodes and links</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Force.prototype.update()</td> 
      <td></td>
      <td>update</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Force.prototype.update = function () {
        var that = this;
        var conf = this.defaults;
        var canvas = this.canvas;

        this.nodes = this.canvas.set();
        this.links = this.canvas.set();
        var nodes = this.nodes;
        var links = this.links;
        var i, j, temp;
        this.force.charge(conf.charge).nodes(this.net.nodes).links(this.net.links).start();

        var nodesData = this.net.nodes;
        var linksData = this.net.links;
        var nodesNum = nodesData.length;
        var linksNum = linksData.length;
        var connectMatrix = [];
        var linkMatrix = [];
        conf.iterate = (nodesNum + linksNum) * 2;

        var onMouseClick = function () {
            that.tagClicked = false;
            that.underBn.forEach(function (d) {
                d.hide();
                d.data('clicked', false);
            });
            that.clicked = true;
            if (!this.data('clicked')) {
                if (conf.browserName !== &quot;Microsoft Internet Explorer&quot;) {
                    that.force.linkDistance(conf.linkLength * 2).charge(conf.charge * 2).start();
                }
                that.nodes.forEach(function (d) {
                    d.data('rect').hide();
                    d.data('text').hide();
                    d.attr({
                        &quot;opacity&quot;: 0.2
                    });
                    d.data('clicked', false);
                    d.data('showText', false);
                });
                that.links.forEach(function (d) {
                    d.attr({
                        'stroke-opacity': 0.0
                    });
                });
                that.clickedNum = this.data('index');
                this.data('clicked', true);
                this.data(&quot;link&quot;).forEach(function (d) {
                    d.attr({
                        &quot;stroke-opacity&quot;: d.data('opacity')
                    });
                });
                this.data(&quot;node&quot;).forEach(function (d) {
                    d.attr({
                        &quot;opacity&quot;: 0.9
                    });
                    d.data('showText', true);
                });
                that.underBn[this.data('colorType')].data('clicked', true).attr('opacity', 1).show();
            } else {
                that.clicked = false;
                if (conf.browserName !== &quot;Microsoft Internet Explorer&quot;) {
                    that.force.linkDistance(conf.linkLength).charge(conf.charge).start();
                }
                nodes.forEach(function (d) {
                    d.attr({
                        &quot;opacity&quot;: 0.9
                    });
                    if (d.data('big')) {
                        d.data('showText', true);
                    } else {
                        d.data('rect').hide();
                        d.data('text').hide();
                        d.data('showText', false);
                    }
                });
                links.forEach(function (d) {
                    d.attr({
                        'stroke-opacity': d.data('opacity')
                    });
                });
                this.data('clicked', false);
                that.underBn[this.data('colorType')].hide();
            }
        }

        var onCanvasClick = function () {
            that.tagClicked = false;
            that.underBn.forEach(function (d) {
                d.hide();
                d.data('clicked', false);
            });
            that.clicked = false;
            if (conf.browserName !== &quot;Microsoft Internet Explorer&quot;) {
                that.force.linkDistance(conf.linkLength).charge(conf.charge).start();
            } else {
                that.force.resume();
            }
            nodes.forEach(function (d) {
                d.attr({
                    &quot;opacity&quot;: 0.9
                });
                if (d.data('big')) {
                    d.data('showText', true);
                } else {
                    d.data('rect').hide();
                    d.data('text').hide();
                    d.data('showText', false);
                }
            });
            links.forEach(function (d) {
                d.attr({
                    'stroke-opacity': d.data('opacity')
                });
            });
        };

        var topValue = [];
        var topId = [];
        var topNum = 10;
        if (nodesNum &lt; 10) {
            topNum = nodesNum;
        }
        for (i = 0; i &lt; topNum; i++) {
            topValue[i] = nodesData[i].nodeValue;
            topId[i] = i;
        }
        for (i = 0; i &lt; topNum; i++) {
            for (j = 1; j &lt; topNum - i; j++) {
                if (topValue[j] &lt; topValue[j - 1]) {
                    temp = topValue[j];
                    topValue[j] = topValue[j - 1];
                    topValue[j - 1] = temp;
                    temp = topId[j];
                    topId[j] = topId[j - 1];
                    topId[j - 1] = temp;
                }
            }
        }
        //rapheal绘制部分
        for (i = 0; i &lt; nodesNum; i++) {
            nodesData[i].x = (conf.width + this.xOffset) / 2;
            nodesData[i].y = conf.height / 2;
            var n = nodesData[i];
            var k = Math.floor(conf.classNum * (n.nodeValue - this.nodeValueMin) / (this.nodeValueMax - this.nodeValueMin));
            if (k &gt;= conf.classNum) k = conf.classNum - 1;
            var radius = this.getRadius(n.nodeValue);
            var cnode = canvas.circle(n.x, n.y, radius).attr({
                fill: this.getColor(k),
                'stroke': &quot;#ffffff&quot;,
                'opacity': 0.9
                //title: n.name
            });
            var nodeText = canvas.text(n.x, n.y - radius, n.name).attr({
                'opacity': 1,
                //'font-family': &quot;微软雅黑&quot;,
                'font': '12px Verdana'
            }).hide();
            var nodeRect = canvas.rect(n.x, n.y, nodeText.getBBox().width, nodeText.getBBox().height, 2).attr({
                'fill': &quot;#000000&quot;,
                'stroke-opacity': 0,
                'fill-opacity': 0.1
            }).hide();
            cnode.data('r', radius);
            cnode.data(&quot;name&quot;, n.name);
            cnode.data('text', nodeText);
            cnode.data('rect', nodeRect);
            cnode.data('colorType', k);
            cnode.data('clicked', false);
            cnode.data('index', i);
            cnode.data('big', false);

            if (i &gt;= topNum &amp;&amp; topValue[0] &lt; nodesData[i].nodeValue) {
                topValue[0] = nodesData[i].nodeValue;
                topId[0] = i;
                for (j = 1; j &lt; topNum; j++) {
                    if (topValue[j] &lt; topValue[j - 1]) {
                        temp = topValue[j];
                        topValue[j] = topValue[j - 1];
                        topValue[j - 1] = temp;
                        temp = topId[j];
                        topId[j] = topId[j - 1];
                        topId[j - 1] = temp;
                    } else {
                        break;
                    }
                }
            }

            nodes.push(cnode);
            connectMatrix[i] = [];
            linkMatrix[i] = [];
            connectMatrix[i].push(nodes[i]);
        }

        for (i = 0; i &lt; topNum; i++) {
            nodes[topId[i]].data(&quot;big&quot;, true);
        }


        for (i = 0; i &lt; linksNum; i++) {
            var l = linksData[i];
            var clink = canvas.path(&quot;M&quot; + l.source.x + &quot;,&quot; + l.source.y + &quot;L&quot; + l.target.x + &quot;,&quot; + l.target.y).attr({
                'stroke-width': conf.linkWidth,
                'stroke-opacity': this.getOpacity(l.value)
            }).toBack();
            clink.data('opacity', this.getOpacity(l.value));
            links.push(clink);
            connectMatrix[l.source.index].push(nodes[l.target.index]);
            connectMatrix[l.target.index].push(nodes[l.source.index]);
            linkMatrix[l.source.index].push(links[i]);
            linkMatrix[l.target.index].push(links[i]);
        }

        var background = canvas.rect(0, 0, conf.width, conf.height).attr({
            'fill': '#ffffff',
            'stroke-opacity': 0
        }).toBack();
        background.click(onCanvasClick);

        nodes.forEach(function (d, i) {
            d.data(&quot;node&quot;, connectMatrix[i]);
            d.data(&quot;link&quot;, linkMatrix[i]);
            if (d.data('big')) {
                d.data('showText', true);
            } else {
                d.data('showText', false);
            }
            d.drag(function (dx, dy) {
                d.data('x', this.ox + dx);
                d.data('y', this.oy + dy);
            }, function () {
                that.force.resume();
                this.ox = this.attr(&quot;cx&quot;);
                this.oy = this.attr(&quot;cy&quot;);
                d.data('x', this.ox);
                d.data('y', this.oy);
                d.data('drag', true);
            }, function () {
                that.force.resume();
                d.data('drag', false);
            });
            d.click(onMouseClick); //.mouseup(onmouseup);
            d.mouseover(function () {
                if (conf.browserName !== &quot;Microsoft Internet Explorer&quot;) {
                    that.force.resume();
                }
                this.attr({
                    'r': d.data('r') + 5
                });
                if (!this.data('showText')) {
                    //this.attr('title', &quot;&quot;);
                    this.data('showText', true);
                    this.data('hover', true);
                }
                if (!that.underBn[this.data('colorType')].data('clicked')) {
                    that.underBn[this.data('colorType')].attr('opacity', 0.5).show();
                }
            }).mouseout(function () {
                this.attr({
                    'r': d.data('r')
                });
                //this.attr('title', this.data('name'));
                if (this.data('hover') &amp;&amp; !this.data('clicked')) {
                    d.data('rect').hide();
                    d.data('text').hide();
                    this.data('showText', false);
                    this.data('hover', false);
                }
                if (!that.underBn[this.data('colorType')].data('clicked')) {
                    that.underBn[this.data('colorType')].hide();
                }
            });
        });

    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_tag">
    tag
  </h3>
  

  <p>绘制图例</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Force.prototype.tag()</td> 
      <td></td>
      <td>tag</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Force.prototype.tag = function () {
        var that = this;
        var conf = this.defaults;
        var paper = this.canvas;
        var tagArea = this.tagArea;
        var rectBn = paper.set();
        this.underBn = [];
        var underBn = this.underBn;
        for (i = 0; i &lt;= conf.classNum - 1; i++) {
            //底框
            underBn.push(paper.rect(tagArea[0] + 10, tagArea[1] + 10 + (20 + 3) * i, 180, 20).attr({
                &quot;fill&quot;: &quot;#ebebeb&quot;,
                &quot;stroke&quot;: &quot;none&quot;,
                'opacity': 1
            }).data('clicked', false).hide());
            //色框
            paper.rect(tagArea[0] + 10 + 3, tagArea[1] + 10 + (20 + 3) * i + 6, 16, 8).attr({
                &quot;fill&quot;: that.getColor(i),
                &quot;stroke&quot;: &quot;none&quot;
            });
            //文字
            var min = Math.floor(this.nodeValueMin + i * (this.nodeValueMax - this.nodeValueMin) / conf.classNum);
            var max = Math.floor(min + (this.nodeValueMax - this.nodeValueMin) / conf.classNum);
            paper.text(tagArea[0] + 10 + 3 + 16 + 8, tagArea[1] + 10 + (20 + 3) * i + 10, min + &quot; ~ &quot; + max).attr({
                &quot;fill&quot;: &quot;black&quot;,
                &quot;fill-opacity&quot;: 1,
                &quot;font-family&quot;: &quot;Verdana&quot;,
                &quot;font-size&quot;: 12
            }).attr({
                &quot;text-anchor&quot;: &quot;start&quot;
            });
            //选框
            rectBn.push(paper.rect(tagArea[0] + 10, tagArea[1] + 10 + (20 + 3) * i, 180, 20).attr({
                &quot;fill&quot;: &quot;white&quot;,
                &quot;fill-opacity&quot;: 0,
                &quot;stroke&quot;: &quot;none&quot;
                //&quot;r&quot;: 3
            })).data(&quot;clicked&quot;, 0);
        }
        rectBn.forEach(function (d, i) {
            d.mouseover(function () {
                if (!underBn[i].data('clicked')) {
                    underBn[i].attr('opacity', 0.5);
                    underBn[i].show();
                }
            }).mouseout(function () {
                if (!underBn[i].data('clicked')) {
                    underBn[i].hide();
                }
            });
            d.click(function () {
                that.clicked = false;
                if (conf.browserName !== &quot;Microsoft Internet Explorer&quot;) {
                    that.force.linkDistance(conf.linkLength).charge(conf.charge).start();
                }
                for (j = 0; j &lt; underBn.length; j++) {
                    if (j === i) {
                        underBn[j].show();
                    } else {
                        underBn[j].hide();
                    }
                }
                rectBn.forEach(function (eachBn) {
                    if (eachBn !== d) {
                        eachBn.data(&quot;clicked&quot;, 0);
                    }
                });
                if (d.data(&quot;clicked&quot;) === 0) {
                    that.tagClicked = true;
                    underBn[i].attr('opacity', 1);
                    underBn[i].data('clicked', true);
                    underBn[i].show();
                    that.nodes.forEach(function (d) {
                        if (d.data('colorType') === i) {
                            d.attr({
                                &quot;opacity&quot;: 0.9
                            });
                            d.data('showText', true);
                        } else {
                            d.attr({
                                &quot;opacity&quot;: 0.2
                            });
                            d.data('rect').hide();
                            d.data('text').hide();
                            d.data('showText', false);
                        }
                    });
                    that.links.forEach(function (d) {
                        d.attr({
                            &quot;stroke-opacity&quot;: 0
                        });
                    });
                    d.data(&quot;clicked&quot;, 1);
                } else if (d.data(&quot;clicked&quot;) === 1) {
                    that.tagClicked = false;
                    underBn[i].data('clicked', false);
                    underBn[i].hide();
                    d.data(&quot;clicked&quot;, 0);
                    that.nodes.forEach(function (d) {
                        d.attr({
                            &quot;opacity&quot;: 0.9
                        });
                        if (d.data('big')) {
                            d.data('showText', true);
                        } else {
                            d.data('rect').hide();
                            d.data('text').hide();
                            d.data('showText', false);
                        }
                    });
                    that.links.forEach(function (d) {
                        d.attr({
                            &quot;stroke-opacity&quot;: d.data('opacity')
                        });
                    });
                }
            });
        });
    }</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_layout">
    layout
  </h3>
  

  <p>create the force-direct layout</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Force.prototype.layout()</td> 
      <td></td>
      <td>layout</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Force.prototype.layout = function () {
        var conf = this.defaults;
        this.force = d3.layout.force().linkDistance(conf.linkLength).size([conf.width + this.xOffset, conf.height]).theta(1.5);
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_animate">
    animate
  </h3>
  

  <p>update the force-direct layout animation</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Force.prototype.animate()</td> 
      <td></td>
      <td>animate</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Force.prototype.animate = function () {
        var conf = this.defaults;
        var nodes = this.nodes;
        var links = this.links;
        var tick = 0;
        var that = this;

        var nodesData = this.net.nodes;
        var linksData = this.net.links;

        this.force.on(&quot;tick&quot;, function () {
            if (conf.browserName !== &quot;Microsoft Internet Explorer&quot; || tick &gt; conf.iterate) {
                if (tick % 2 === 0) {
                    nodes.forEach(function (d, i) {
                        var margin = d.data('r');
                        var nd = nodesData[i];
                        if (d.data('drag')) {
                            nd.x = d.data('x');
                            nd.y = d.data('y');
                        }
                        nd.x = (nd.x &lt; margin + that.xOffset) ? (margin + that.xOffset) : nd.x;
                        nd.x = (nd.x &gt; conf.width - margin) ? conf.width - margin : nd.x;
                        nd.y = (nd.y &lt; margin) ? margin : nd.y;
                        nd.y = (nd.y &gt; conf.height - margin) ? conf.height - margin : nd.y;
                        var bx = d.data('text').getBBox().width / 2;
                        var by = d.data('text').getBBox().height / 2;

                        if (that.clicked) {
                            var mx = nodesData[that.clickedNum].x;
                            var my = nodesData[that.clickedNum].y;
                            var tx, ty;
                            if (d.data('clicked')) {

                                if (conf.browserName !== &quot;Microsoft Internet Explorer&quot;) {
                                    nd.x = (conf.width + that.xOffset) / 2;
                                    nd.y = conf.height / 2;
                                }
                                d.data('rect').attr({
                                    'x': nd.x - bx,
                                    'y': nd.y + d.data('r')
                                });
                                d.data('text').attr({
                                    'x': nd.x,
                                    'y': nd.y + by + d.data('r')
                                });
                                d.data('rect').show();
                                d.data('text').show();
                            } else if (d.data('showText')) {
                                var lx = (nd.x - mx);
                                var ly = (nd.y - my);
                                var length = Math.sqrt(lx * lx + ly * ly);
                                tx = nd.x + bx * lx / length;
                                ty = nd.y + by * ly / length;
                                tx = (nd.x &lt; mx) ? tx - d.data('r') : tx + d.data('r');
                                ty = (nd.y &lt; my) ? ty - d.data('r') : ty + d.data('r');
                                tx = (tx &lt; margin + that.xOffset) ? (margin + that.xOffset) : tx;
                                tx = (tx &gt; conf.width - margin) ? conf.width - margin : tx;
                                ty = (ty &lt; margin) ? margin : ty;
                                ty = (ty &gt; conf.height - margin) ? conf.height - margin : ty;
                                d.data('rect').attr({
                                    'x': tx - bx,
                                    'y': ty - by
                                });
                                d.data('text').attr({
                                    'x': tx,
                                    'y': ty
                                });
                                d.data('rect').show();
                                d.data('text').show();
                            }
                        } else if (d.data('showText')) {
                            d.data('rect').attr({
                                'x': nd.x - bx,
                                'y': nd.y - by + 4 + d.data('r')
                            });
                            d.data('text').attr({
                                'x': nd.x,
                                'y': nd.y + 4 + d.data('r')
                            });
                            try {
                                d.data('rect').show();
                                d.data('text').show();
                            } catch (e) {}

                        }
                        d.attr({
                            'cx': nd.x,
                            'cy': nd.y
                        });
                    });
                    links.forEach(function (d, i) {
                        d.attr('path', &quot;M&quot; + linksData[i].source.x + &quot;,&quot; + linksData[i].source.y + &quot;L&quot; + linksData[i].target.x + &quot;,&quot; + linksData[i].target.y);
                    });
                }
            }++tick;
        });
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setOptions">
    setOptions
  </h3>
  

  <p>设定用户自定义的属性</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Force.prototype.setOptions()</td> 
      <td></td>
      <td>setOptions</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>options(Object)</td>
      <td colspan="2">用户属性</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Force.prototype.setOptions = function (options) {
        var prop;
        if (options) {
            for (prop in options) {
                if (options.hasOwnProperty(prop)) {
                    this.defaults[prop] = options[prop];
                }
            }
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_render">
    render
  </h3>
  

  <p>render the force-directed net on the canvas and keep updating</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Force.prototype.render()</td> 
      <td></td>
      <td>render</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>options(Object)</td>
      <td colspan="2">user options</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Force.prototype.render = function (options) {
        if (!this.container) {
            throw new Error(&quot;Please specify which node to render.&quot;);
        }
        this.setOptions(options);
        this.canvas.clear();
        this.layout();
        if (this.defaults.tag) {
            this.tag();
        }
        this.update();
        var i;
        this.animate();
    };

    return Force;
});</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/matrix" class="api">
  <h2>charts/matrix: API索引</h2>
  <ul class="indexs">
  
  </ul>
  <hr />

  

  <p>lobal EventProxy, d3, Raphael, $</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>define(function (require, exports, module) {
    var DataV = require('datav');
    var theme = DataV.Themes;

    var Matrix = DataV.extend(DataV.Chart, {
        initialize: function (container, options) {
            this.type = &quot;Matrix&quot;;
            this.container = container;
            this.defaults = {};

            // Properties
            this.font = {};

            // Canvas
            this.defaults.width = 1200;
            this.defaults.height = 1200;
            this.defaults.axisWidth = 40;

            this.setOptions(options);
            this.emitter = new EventProxy();
            this.createCanvas();
            this.move = false;
        }
    });

    Matrix.prototype.on = function (eventName, callback) {
        this.emitter.on(eventName, callback);
    };

    Matrix.prototype.setOptions = function (options) {
        var prop;
        if (options) {
            for (prop in options) {
                if (options.hasOwnProperty(prop)) {
                    this.defaults[prop] = options[prop];
                }
            }
        }
    };

    Matrix.prototype.getDataTable = function (table) {
        var title = table[0];
        table = table.slice(1);

        var titleLength = title.length;
        var tableWidth = table[0].length;
        var tableHeight = table.length;

        this.tableWidth = tableWidth;
        this.tableHeight = tableHeight;

        //for symmetric matrix
        if (tableWidth !== title.length || tableHeight !== title.length) {
            throw new Error(&quot;This matrix is not symmetric matrix!!!&quot;);
        } else {
            this.tableWidth = tableWidth;
            this.tableHeight = tableHeight;
        }

        this.title = title;
        return table;
    };

    Matrix.prototype.setSource = function (source) {
        var conf = this.defaults;

        this.source = this.getDataTable(source);
        this.hasSort = false;
        // this.source = this.remapSource(source);
    };

    // Matrix.prototype.remapSource = function (data) {
    //     return this.getDataTable(data);
    //     // return data;
    // };

    Matrix.prototype.layout = function () {
        var conf = this.defaults;
        var width = conf.width;
        var height = conf.height;
        var tableWidth = this.tableWidth;
        var tableHeight = this.tableHeight;
        var axisWidth = conf.axisWidth;

        this.cellWidth = Math.min((width - axisWidth) / tableWidth, (height - axisWidth) / tableHeight);

        var startX;
        var startY;
        var bRectWidth;
        var matrixWidth;

        if (width &gt; height) {
            startX = (width - height)/2 + axisWidth;
            startY = axisWidth;
            bRectWidth = height - axisWidth;
            matrixWidth = bRectWidth - axisWidth;
        } else if (height &gt; width) {
            startX = axisWidth;
            startY = (height - width) + axisWidth;
            bRectWidth = width - axisWidth;
        } else {
            startX = axisWidth;
            startY = axisWidth;
            bRectWidth = width - axisWidth;
            matrixWidth = bRectWidth - axisWidth;
        }

        this.startX = startX;
        this.startY = startY;
        this.bRectWidth = bRectWidth;
        this.matrixWidth = matrixWidth;
    };

    Matrix.prototype.getColor = function (i) {
        var colorMatrix = DataV.getColor();
        var length = colorMatrix.length;
        var num = i % length;
        //var color = '#939598';
        var color = '#FFFFFF'
        
        if (num !== 0) {
            color = colorMatrix[num][0];
        }

        return color;
    };

    Matrix.prototype.createCanvas = function () {
        var conf = this.defaults;
        this.canvas = new Raphael(this.container, conf.width, conf.height);

        this.DOMNode = $(this.canvas.canvas);
        var that = this;
        this.DOMNode.click(function (event) {
            that.emitter.trigger(&quot;click&quot;, event);
            that.update();
        });
        this.DOMNode.dblclick(function (event) {
            that.emitter.trigger(&quot;dblclick&quot;, event);
        });

        var mousewheel = document.all ? &quot;mousewheel&quot; : &quot;DOMMouseScroll&quot;;  
        this.DOMNode.bind(mousewheel, function (event) {
            that.emitter.trigger(&quot;mousewheel&quot;, event);
        });

        this.DOMNode.bind(&quot;contextmenu&quot;, function (event) {
            that.emitter.trigger(&quot;contextmenu&quot;, event);
        });

        this.DOMNode.delegate(&quot;circle&quot;, &quot;click&quot;, function (event) {
            that.emitter.trigger(&quot;circle_click&quot;, event);
        });

        this.DOMNode.delegate(&quot;circle&quot;, &quot;mouseover&quot;, function (event) {
            that.emitter.trigger(&quot;circle_mouseover&quot;, event);
        });

        this.DOMNode.delegate(&quot;circle&quot;, &quot;mouseout&quot;, function (event) {
            that.emitter.trigger(&quot;circle_mouseout&quot;, event);
        });
    };

    Matrix.prototype.generatePaths = function () {
        var canvas = this.canvas;
        var source = this.source;
        var conf = this.defaults;
        var width = conf.width;
        var height = conf.height;
        var startX = this.startX;
        var startY = this.startY;
        var cellWidth = this.cellWidth;
        var tableWidth = this.tableWidth;
        var tableHeight = this.tableHeight;
        var bRectWidth = this.bRectWidth;
        var matrixWidth = this.matrixWidth;

        //canvas.clear();
        // var color = this.getColor();
        // var font = this.getFont();
        var font_family = '微软雅黑';
        var font_size = 8;

        var title = this.title;

        var row = [];
        var columnLine = [];
        var columnText = [];

        var backgroundRect = canvas.rect(startX, startY, bRectWidth, bRectWidth);
        //backgroundRect.attr({fill: &quot;#939598&quot;, stroke: &quot;none&quot;, &quot;fill-opacity&quot;: 0.8});
        backgroundRect.attr({fill: &quot;#ffffff&quot;, stroke: &quot;none&quot;, &quot;fill-opacity&quot;: 0.8});
        backgroundRect.toBack();

        var sort;
        if (this.hasSort) {
            sort = this.sort;
        }
        var i, j, a, b, color, rect;
        var rects = [];  //for column change move rect
        for (i = 0; i &lt; tableHeight; i++) {
            if (!this.hasSort){
                a = i;
            } else {
                for (j = 0; j &lt; sort.length; j++) {
                    if (sort[j] === i) {
                        a = j;
                    } 
                }
            }
            var rowRect = canvas.set();
            //rowRect.push(canvas.path(&quot;M0 0L&quot; + width + &quot; 0&quot;).attr({stroke: &quot;#ffffff&quot;}));
            canvas.path(&quot;M&quot; + startX + &quot; &quot; + (startY + cellWidth * i) + &quot;L&quot; + (startX + matrixWidth + 10 + cellWidth) + &quot; &quot;
             + (startY + cellWidth * i)).attr({stroke: &quot;#D1D1D1&quot;, &quot;stroke-width&quot;: 1});
            rowRect.push(canvas.text(-20, cellWidth / 2, title[i])
                .attr({&quot;fill&quot;: &quot;#000000&quot;,
                    &quot;fill-opacity&quot;: 0.7,
                    &quot;font-family&quot;: &quot;Verdana&quot;,
                    //&quot;font-weight&quot;: &quot;bold&quot;,
                    &quot;font-size&quot;: 12}));

            for (j = 0; j &lt; tableWidth; j++) {
                if (!this.hasSort){ 
                    color = this.getColor(source[i][j]);
                } else {
                    color = this.getColor(source[i][sort[j]]);
                }
                rect = canvas.rect(cellWidth * j, 0, cellWidth, cellWidth)
                    .attr({stroke: &quot;none&quot;, fill: color, &quot;fill-opacity&quot;: 0.8});
                rowRect.push(rect);
                rects.push(rect);
            }

            rowRect.transform(&quot;t&quot; + startX + &quot;, &quot; + (startY + cellWidth * a));
            row.push(rowRect);
        }

        canvas.path(&quot;M&quot; + startX + &quot; &quot; + (startY + cellWidth * tableHeight) + &quot;L&quot; + (startX + matrixWidth + 10 + cellWidth) + &quot; &quot;
             + (startY + cellWidth * tableHeight)).attr({stroke: &quot;#D1D1D1&quot;, &quot;stroke-width&quot;: 1});

        for (i = 0; i &lt; tableWidth; i++) {
            // var columnLine = canvas.set();
            // var columnText = canvas.set();
            if (!this.hasSort){
                a = i;
            } else {
                for (j = 0; j &lt; sort.length; j++) {
                    if (sort[j] === i) {
                        a = j;
                    } 
                }
            }
            columnLine.push(canvas.path(&quot;M0 0L0 &quot; + matrixWidth + 10 + cellWidth)
                .attr({stroke: &quot;#D1D1D1&quot;, &quot;stroke-width&quot;: 1})
                .transform(&quot;t&quot; + (startX + cellWidth * a) + &quot;, &quot; + startY));
            columnText.push(canvas.text(cellWidth / 2, -20, title[i])
                .attr({&quot;fill&quot;: &quot;#000000&quot;,
                    &quot;fill-opacity&quot;: 0.7,
                    &quot;font-family&quot;: &quot;Verdana&quot;,
                    //&quot;font-weight&quot;: &quot;bold&quot;,
                    &quot;font-size&quot;: 12})
                .transform(&quot;t&quot; + (startX + cellWidth * a) + &quot;, &quot; + startY + &quot;r90&quot;));

            // for (j = i * (tableWidth - 1); j &lt; (i + 1) * (tableWidth - 1); j++){
            //     columnRect.push(rects[j]);
            // }

            //columnRect.transform(&quot;t&quot; + (startX + cellWidth * i) + &quot;, &quot; + startY);
            // column.push(columnRect);
        }

        columnLine.push(canvas.path(&quot;M0 0L0 &quot; + matrixWidth + 10 + cellWidth)
                .attr({stroke: &quot;#D1D1D1&quot;, &quot;stroke-width&quot;: 1})
                .transform(&quot;t&quot; + (startX + cellWidth * tableWidth) + &quot;, &quot; + startY));

        this.row = row;
        this.columnText = columnText;
        this.columnLine = columnLine;
        this.rects = rects;
    };

    Matrix.prototype.getSort = function (source) {
        var sumQueue = [];
        var sort = [];
        var rowData;
        var rowLength;
        var sum;
        var means;
        var matrixD = [];
        var quareSum;
        var rowquareSum = [];

        var i, j, k;
        for (i = 0 ; i &lt; source.length ; i++) {
            rowData = source[i];
            rowLength = rowData.length;
            sum = 0;
            quareSum = 0;

            for (j = 0 ; j &lt; rowLength ; j++) {
                sum = sum + rowData[j];
            }

            means = sum / rowLength;
            for (j = 0 ; j &lt; rowLength ; j++) {
                rowData[j] = rowData[j] - means;
                quareSum = quareSum + Math.pow(rowData[j], 2);
            }

            quareSum = Math.sqrt(quareSum);

            rowquareSum.push(quareSum);
            matrixD.push(rowData);
        }

        var rowI;
        var rowJ;
        var matrixR = [];

        for (i = 0 ; i &lt; source.length ; i++) {
            matrixR[i] = [];
            for (j = 0 ; j &lt; source.length ; j++) {
                matrixR[i][j] = 0;
            }
        }

        for (i = 0 ; i &lt; source.length ; i++) {
            rowI = matrixD[i];
            matrixR[i][i] = source[i][i];
            for (j = i + 1 ; j &lt; source.length ; j++) {
                sum = 0;
                rowJ = matrixD[j];
                for (k = 0; k &lt; rowLength; k++) {
                    sum = sum + rowI[k] * rowJ[k];
                }

                sum = sum / (rowquareSum[i] * rowquareSum[j]);
                matrixR[i][j] = sum;
                matrixR[j][i] = sum;
            }
        }



        return matrixR;
    }
    
    Matrix.prototype.update = function () {
        var i, j;
        var source = [];
        for(i = 0; i &lt; this.source.length ; i++){
            source[i] = this.source[i].concat();
        }

        var sort = [];
        for (i = 0; i &lt; source[0].length; i++) {
            sort.push(i);
        }

        if (this.hasSort) {
            this.sort = sort;
            this.hasSort = false;
        } else {
            var getSort = this.getSort;
            var i, j;
            var pt;
            var nowSort = [];
            var iterations = 12;

            for (i = 0; i &lt; iterations; i++) {
                source = getSort(source);
            }

            nowSort = source[0];

            var a, b;
            for (i = 1; i &lt; sort.length; i++) {
                a = sort[i];
                for (j = i + 1; j &lt; sort.length; j++) {
                    b = sort[j];
                    if (nowSort[a] &lt; nowSort[b]) {
                        pt = sort[i];
                        sort[i] = sort[j];
                        sort[j] = pt;
                    }
                }
            }
            sort = [0,7,5,2,8,3,1,9,6,14,15,4,13,10,16,11,12];
            this.sort = sort;
            this.hasSort = true;
        }

        if (!this.move) { 
            this.move = true;
            var rects = this.rects;
            var num;
            var startX = this.startX;
            var startY = this.startY;
            var cellWidth = this.cellWidth;

            var rowAnim;
            var columnLineAnim;
            var columnTextAnim;
            var anim;

            for (i = 0; i &lt; sort.length; i++) {
                num = sort[i];
                // if (num != i) {
                rowAnim = Raphael.animation({transform: [&quot;t&quot;, startX, (startY + cellWidth * i)]}, 200, &quot;&lt;&gt;&quot;);
                this.row[num].animate(rowAnim.delay(100 * i));
                // }
            }

            var that = this;
            var moveEnd = function () {
                that.move = false;
            };

            for (i = 0; i &lt; sort.length; i++) {
                num = sort[i];
                // if (num != i) {
                //columnLineAnim = Raphael.animation({transform: [&quot;t&quot;, (startX + cellWidth * i), startY]}, 1000, &quot;&lt;&gt;&quot;);
                columnTextAnim = Raphael.animation({transform: [&quot;t&quot;, (startX + cellWidth * i), startY, &quot;r&quot;, 90]}, 
                    200, &quot;&lt;&gt;&quot;);
                //this.columnLine[num].animate(columnLineAnim.delay(500 * (i + sort.length + 1)));
                this.columnText[num].animate(columnTextAnim.delay(100 * (i + sort.length + 1)));

                for (j = 0; j &lt; sort.length; j++) {
                    if (i === sort.length - 1 &amp;&amp; j === sort.length - 1) {
                        anim = Raphael.animation({'x': cellWidth * i}, 200, &quot;&lt;&gt;&quot;, moveEnd);
                    } else {
                        anim = Raphael.animation({'x': cellWidth * i}, 200, &quot;&lt;&gt;&quot;);
                    }
                    rects[j * sort.length + num].animate(anim.delay(100 * (i + sort.length + 1)));
                }
                // }
            }
        }
    };


    Matrix.prototype.render = function (options) {
        if (!this.container) {
            throw new Error(&quot;Please specify which node to render.&quot;);
        }

        if (!this.move) {
            this.canvas.clear();
            this.setOptions(options);
            this.layout();
            this.generatePaths();
        }

        //this.canvas.renderfix();
    };
    
    module.exports = Matrix;
});</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/parallel" class="api">
  <h2>charts/parallel: API索引</h2>
  <ul class="indexs">
  
  </ul>
  <hr />

  

  <table class="table">
  

  
  </table>
  
  

  <p>lobal d3</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>;(function (name, definition) {
    if (typeof define === 'function') { // Module
        define(definition);
    } else { // Assign to common namespaces or simply the global object (window)
        this[name] = definition(function (id) { return this[id];});
    }
})('Parallel', function (require) {
    var DataV = require('DataV');
    var Axis = require('Axis');
    var Brush = require('Brush');

    var Parallel = DataV.extend(DataV.Chart, {
        initialize: function (node, options) {
            this.type = &quot;Parallel&quot;;
            this.node = this.checkNode(node);
            this.defaults = {};

            // Properties
            this.allDimensions = [];
            this.dimensions = [];
            this.dimensionType = {};
            this.dimensionDomain = {};
            this.dimensionExtent = {};

            // Canvas
            this.defaults.width = 750;
            this.defaults.height = 500;
            this.defaults.marginWidth = [20,20,20,20];
            this.defaults.backgroundAttr = {&quot;fill&quot;: &quot;none&quot;, &quot;stroke&quot;: &quot;#ccc&quot;, &quot;stroke-opacity&quot;: 0.4};
            this.defaults.foregroundAttr = {&quot;fill&quot;: &quot;none&quot;, &quot;stroke&quot;: &quot;steelblue&quot;, &quot;stroke-opacity&quot;: 0.7};
            this.defaults.domainAttr = {&quot;stroke&quot;: &quot;#000&quot;};
            this.defaults.tickAttr = {&quot;stroke&quot;: &quot;#000&quot;};
            this.defaults.tickTextAttr = {};
            this.defaults.titleAttr ={};

            this.customEvent = {
                &quot;brushstart&quot;: function(){},
                &quot;brushend&quot;: function(){},
                &quot;brush&quot;: function(){}
            };

            this.setOptions(options);
            this.createCanvas();
        }
    });

    Parallel.prototype.checkNode = function (node) {
        if (!node) {
            throw new Error(&quot;Please specify which node to render.&quot;);
        }
        if(typeof(node) === &quot;string&quot;) {
            return document.getElementById(node);
        } else if (node.nodeName) {//DOM-element
            return node;
        }
        throw new Error(&quot;Please specify which node to render.&quot;);
    };

    Parallel.prototype.chooseDimensions = function (dimen) {
        var conf = this.defaults;
        this.dimensions = [];
        for (var i=0, l=dimen.length; i&lt;l; i++) {
            if ($.inArray(dimen[i], this.allDimensions) !== -1) {
                this.dimensions.push(dimen[i]);
            }
        }
    };

    Parallel.prototype.setDimensionType = function (dimenType) {
        var conf = this.defaults,
            prop,
            type;
        if (dimenType) {
            for (prop in dimenType) {
                if (dimenType.hasOwnProperty(prop) &amp;&amp; this.dimensionType[prop]) {
                    var type = dimenType[prop];
                    if (type !== &quot;quantitative&quot; &amp;&amp; type !== &quot;ordinal&quot;) {
                        throw new Error('Dimension type should be &quot;quantitative&quot; or &quot;ordinal&quot;.');
                    }
                    if (this.dimensionType[prop] !== type) {
                        this.dimensionType[prop] = type;
                        this._setDefaultDimensionDomain(prop);
                    }
                }
            }
        }
    };

    Parallel.prototype.getDimensionExtents = function () {
        return $.extend({}, this.dimensionExtent);
    };

    Parallel.prototype.setDimensionExtent = function (dimenExtent) {
        var conf = this.defaults;
        var dimen, i, l, extent;
        var rebrushNeeded = false;
        var ordinalExtent = [];

        if (arguments.length === 0) {
            // clean all extent
            this.dimensionExtent = {};
        } else {
            for (prop in dimenExtent) {
                if (dimenExtent.hasOwnProperty(prop) &amp;&amp; this.dimensionType[prop]) {
                    extent = dimenExtent[prop];
                    if (!(extent instanceof Array)) {
                        throw new Error(&quot;extent should be an array&quot;);
                    } else {
                        if (extent.length !== 2) {
                            throw new Error(&quot;extent should be an array with two items, for example: [num1, num2]&quot;);
                        } else if (this.dimensionType[prop] === &quot;quantitative&quot;) {
                            this.dimensionExtent[prop] = extent;
                            rebrushNeeded = true;
                            if (this.brush) {
                                this.y[prop].brush.extent(extent);
                                this.y[prop].brush.refresh();
                            }
                        } else if (this.dimensionType[prop] === &quot;ordinal&quot;) {
                            if (typeof this.dimensionDomain[prop].itemIndex[extent[0]] === 'undefined'
                                    || typeof this.dimensionDomain[prop].itemIndex[extent[1]] === 'undefined') {
                                throw new Error(prop + &quot; does not have value: &quot; + extent[0] + &quot; or &quot; + extent[1]); 
                            } else {
                                rebrushNeeded = true;
                                ordinalExtent = this._getOrdinalExtent(prop, extent);
                                this.dimensionExtent[prop] = extent;
                                if (this.brush) {
                                    this.y[prop].brush.extent(ordinalExtent);
                                    this.y[prop].brush.refresh();
                                }
                            }
                        }
                    }
                }
            }
            if (rebrushNeeded &amp;&amp; this.brush) {
                this.brush();
            }
        }
    };

    Parallel.prototype.getDimensionTypes = function () {
        return $.extend({}, this.dimensionType);
    };

    Parallel.prototype.getDimensionDomains = function () {
        return $.extend({}, this.dimensionDomain);
    };

    Parallel.prototype._setOrdinalDomain = function (a) {
        var uniq = [];
        var index = {};
        var i = -1, n = a.length, ai;
        while (++i &lt; n) {
            if (typeof index[ai = a[i]] === 'undefined') {
                index[ai] = uniq.push(ai) - 1;
            }
        }
        uniq.itemIndex = index;
        return uniq;
    };

    Parallel.prototype._setDefaultDimensionDomain = function (dimen) {
        var conf = this.defaults;
        if(this.dimensionType[dimen] === &quot;quantitative&quot;){
            this.dimensionDomain[dimen] = d3.extent(this.source, function(p){return +p[dimen]});
        } else {
            this.dimensionDomain[dimen] = this._setOrdinalDomain(this.source.map(function(p){return p[dimen]}));
        }
    };

    //quant or ordinal different
    Parallel.prototype.setDimensionDomain = function (dimenDomain) {
        //set default dimensionDomain, extent for quantitative type, item array for ordinal type
        var conf = this.defaults;
        var dimen, i, l, domain;

        if (arguments.length === 0) {
            for (i = 0, l = this.allDimensions.length; i &lt; l; i++) {
                dimen = this.allDimensions[i];
                this._setDefaultDimensionDomain(dimen);
            }
        } else {
            for (prop in dimenDomain) {
                if (dimenDomain.hasOwnProperty(prop) &amp;&amp; this.dimensionType[prop]) {
                    domain = dimenDomain[prop];
                    if (!(domain instanceof Array)) {
                        throw new Error(&quot;domain should be an array&quot;);
                    } else {
                        if (this.dimensionType[prop] === &quot;quantitative&quot; &amp;&amp; domain.length !== 2) {
                            throw new Error(&quot;quantitative's domain should be an array with two items, for example: [num1, num2]&quot;);
                        }
                        if (this.dimensionType[prop] === &quot;quantitative&quot;) {
                            this.dimensionDomain[prop] = domain;
                        } else if (this.dimensionType[prop] === &quot;ordinal&quot;) {
                            this.dimensionDomain[prop] = this._setOrdinalDomain(domain);
                        }
                    }
                }
            }
        }
    };

    Parallel.prototype.on = function (eventName, callback) {
        if (eventName === &quot;brushstart&quot;) {
            this.customEvent[&quot;brushstart&quot;] = callback;
        } else if (eventName === &quot;brushend&quot;) {
            this.customEvent[&quot;brushend&quot;] = callback;
        } else if (eventName === &quot;brush&quot;) {
            this.customEvent[&quot;brush&quot;] = callback;
        }
    };

    Parallel.prototype.setOptions = function (options) {
        var prop;
        if (options) {
            for (prop in options) {
                if (options.hasOwnProperty(prop)) {
                    this.defaults[prop] = options[prop];
                }
            }
        }
    };

    Parallel.prototype.setSource = function (source) {
        //source is 2-dimension array

        var conf = this.defaults;
        this.allDimensions = source[0];

        //by default all dimensions show
        this.dimensions = source[0];

        //this.source is array of line; key is dimension, value is line's value in that dimension 
        this.source = [];
        for(var i=1, l=source.length; i&lt;l; i++){
            var line = {},
                dimen = this.allDimensions;
            for(var j=0, ll=dimen.length; j&lt;ll; j++){
                line[dimen[j]] = source[i][j];
            }
            this.source.push(line);
        }

        //judge dimesions type auto
        //if all number, quantitative else ordinal    
        this.dimensionType = {};
        function isNumber(n) {
            // http://stackoverflow.com/questions/18082/validate-numbers-in-javascript-isnumeric
            return !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);
        }
        for(var i=0, l=this.allDimensions.length; i&lt;l; i++){
            var type = &quot;quantitative&quot;;
            for(var j=1, ll=source.length; j&lt;ll; j++){
                var d = source[j][i];
                if(d &amp;&amp; (! isNumber(d))){
                    type = &quot;ordinal&quot;;
                    break;
                }
            }
            this.dimensionType[this.allDimensions[i]] = type;
        }

        this.setDimensionDomain();

    };

    Parallel.prototype.layout = function () {
        //create x and y dimensions
        var conf = this.defaults,
            domain,
            i,
            j,
            l,
            ll,
            domain;
        
        var m = conf.marginWidth,
            w = conf.width - m[1] - m[3],
            h = conf.height - m[0] - m[2];

        this.x = d3.scale.ordinal().rangePoints([0, w], 1),
        this.y = {};
        this.y2 = {};

        this.x.domain(d3.range(this.dimensions.length));//allow same dimension
        for(i=0, l=this.dimensions.length; i&lt;l; i++){
            var dimen = this.dimensions[i];
            if(this.dimensionType[dimen] === &quot;quantitative&quot;){
                this.y[dimen] = d3.scale.linear()
                .domain(this.dimensionDomain[dimen])
                .range([h + m[0], m[0]]);
                this.y2[dimen] = d3.scale.linear()
                .domain(this.dimensionDomain[dimen])
                .range([h + m[0], m[0]]);
            }else{
                this.y[dimen] = d3.scale.ordinal()
                .domain(this.dimensionDomain[dimen])
                .rangeBands([h + m[0], m[0]]);
                this.y2[dimen] = d3.scale.linear()
                .domain([0, this.dimensionDomain[dimen].length])
                .range([h + m[0], m[0]]);
            }
        }
    };

    Parallel.prototype.generatePaths = function () {
        var conf = this.defaults;
        var axis = Axis().orient(&quot;left&quot;);

        var m = conf.marginWidth;

        var paper = this.canvas;

        this.bg = paper.set();
        var i, l;
        for (i = 0, l = this.source.length; i&lt;l; i++) {
            var line = this.source[i];
            this.bg.push(paper.path(this.path(line)));
        }
        this.bg.attr(conf.backgroundAttr).attr({transform: &quot;t&quot; + m[3] + ',0'});
        
        this.fg = paper.set();
        for (i = 0, l = this.source.length; i&lt;l; i++) {
            var line = this.source[i];
            this.fg.push(paper.path(this.path(line)));
        }
        this.fg.attr(conf.foregroundAttr).attr({transform: &quot;t&quot; + m[3] + ',0'});

        var dimensions = this.dimensions;
        
        for(i = 0, l = dimensions.length; i&lt;l; i++){
            var ax=axis.scale(this.y[dimensions[i]])(paper);
            ax.push(paper.text(0, m[0] - 12, dimensions[i]).attr({&quot;text-anchor&quot;: &quot;middle&quot;}));
            ax.attr({transform: &quot;t&quot; + (m[3] + this.x.range()[i] ) + ',0'});
        }

        var xInterval = Math.min(this.x.range()[1] - this.x.range()[0] - 20, 16);
        var brushs = [];

        this.statistic = {};
        this.statistic[&quot;selected&quot;] = 0;
        this.statistic[&quot;all&quot;] = this.source.length;
        this.statistic[&quot;items&quot;] = {};
        var that = this;
        this.brush = function() {
                var statistic = that.statistic;
                var dimensionExtents = that.dimensionExtent;
                var actives = that.dimensions.filter(function(p) {
                        var empty = that.y[p].brush.empty();
                        if (empty) {
                            statistic.items[p] = -1;
                            dimensionExtents[p] = undefined;
                        } else {
                            statistic.items[p] = 0;
                        }
                        return !empty;
                    }),
                    extents = actives.map(function(p) {
                            var extent = that.y[p].brush.extent();
                            if (that.dimensionType[p] === &quot;quantitative&quot;) {
                                that.dimensionExtent[p] = extent;
                            } else {
                                that.dimensionExtent[p] = [
                                    that.dimensionDomain[p][Math.ceil(extent[0] - 0.5)],
                                    that.dimensionDomain[p][Math.floor(extent[1] - 0.5)]
                                ];
                            }
                            return extent;
                        });
                var i, j, l, ll, p;
                var d, value, inExtent, selected;
                //var brush, dimen;

                statistic[&quot;selected&quot;] = 0;
                
                for (j=0, l=that.fg.length; j&lt;l; j++) {
                    d = that.source[j];
                    selected = true;
                    for (i = 0, ll = actives.length; i &lt; ll; i++) {
                        p = actives[i];
                        value = that.dimensionType[p] === &quot;quantitative&quot; ?
                                d[p] : that.dimensionDomain[p].itemIndex[d[p]] + 0.5;
                        inExtent = extents[i][0] &lt;= value &amp;&amp; value &lt;= extents[i][1];
                        if (inExtent) { statistic.items[p] += 1;}
                        if (!inExtent) {selected = false;}
                    }
                    if (selected) {
                        statistic[&quot;selected&quot;] += 1;
                        that.fg[j].attr({&quot;stroke&quot;: &quot;steelblue&quot;});
                    } else {
                        that.fg[j].attr({&quot;stroke&quot;: &quot;none&quot;});
                    }
                }</code></pre></td>
    </tr>
  
  </table>
  
  

  <p>//set extent;<br />                brush = d3.event.target;<br />                dimen = brush.dimension;</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>that.customEvent[&quot;brush&quot;].call(that);
            },
            brushstart = function () {
                that.customEvent[&quot;brushstart&quot;].call(that);
            },
            brushend = function () {
                that.customEvent[&quot;brushend&quot;].call(that);
            };

        var b, start, end, temp;

        for (var i = 0, l = dimensions.length; i&lt;l; i++) {
            dimen = dimensions[i];
            b = Brush().y(this.y2[dimen])
                .left(m[3] + this.x.range()[i] - xInterval/2)
                .width(xInterval)
                .backgroundAttr({&quot;opacity&quot;: 0, &quot;fill&quot;: &quot;white&quot;})
                .foregroundAttr({&quot;opacity&quot;: 0.5, &quot;fill&quot;: &quot;gray&quot;})
                .on(&quot;brushstart&quot;, brushstart)
                .on(&quot;brush&quot;, this.brush)
                .on(&quot;brushend&quot;, brushend);
            if (typeof this.dimensionExtent[dimen] !== 'undefined') {
                if (this.dimensionType[dimen] === &quot;quantitative&quot;) {
                    b.extent(this.dimensionExtent[dimen]);
                } else {</code></pre></td>
    </tr>
  
  </table>
  
  

  <p>start = this.dimensionDomain[dimen].itemIndex[this.dimensionExtent[dimen][0]];<br />                    end = this.dimensionDomain[dimen].itemIndex[this.dimensionExtent[dimen][1]];<br />                    if (start > end) {<br />                        temp = start;<br />                        start = end;<br />                        end = temp;<br />                    }<br />                    start = Math.max(0, start + 0.5 - 0.5);<br />                    end = Math.min(this.dimensionDomain[dimen].length, end + 0.5 + 0.5);<br />                    b.extent([start, end]);</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>b.extent(this._getOrdinalExtent(dimen, this.dimensionExtent[dimen]));
                }
            }

            this.y[dimen].brush = b(paper);
            //this.y[dimensions[i]].brush.dimension = dimensions[i];
        }
        if (!$.isEmptyObject(this.dimensionExtent)) {
            this.brush();
        }
    };

    Parallel.prototype._getOrdinalExtent = function (dimen, stringArray) {
        start = this.dimensionDomain[dimen].itemIndex[stringArray[0]];
        end = this.dimensionDomain[dimen].itemIndex[stringArray[1]];
        if (start &gt; end) {
            temp = start;
            start = end;
            end = temp;
        }
        start = Math.max(0, start + 0.5 - 0.5);
        end = Math.min(this.dimensionDomain[dimen].length, end + 0.5 + 0.5);
        return [start, end];
    };

    Parallel.prototype.createCanvas = function () {
        var conf = this.defaults;
        this.node.style.position = &quot;relative&quot;;
        this.canvas = Raphael(this.node, conf.width, conf.height);

        //console.log(this.canvas);
    };

    Parallel.prototype.getColor = function (colorJson) {
        var colorM = DataV.getColor();
        var color;
        var colorStyle = colorJson ? colorJson : {};
        var colorMode = colorStyle.mode ? colorStyle.mode : 'default';
        switch (colorMode){
            case &quot;gradient&quot;:
                var index = colorJson.index ? colorJson.index : 0;
                index = index &lt;0 ? 0 : (index&gt;colorM.length-1 ? colorM.length-1 : index);
                color = d3.interpolateRgb.apply(null, [colorM[index][0],colorM[index][1]]);
                break;
            case &quot;random&quot;:
            case &quot;default&quot;:
                var ratio = colorStyle.ratio ? colorStyle.ratio : 0;
                if(ratio &lt;0 ){ratio=0;}
                if(ratio &gt; 1) { ratio =1;}
                var colorArray =[];
                for (var i=0, l=colorM.length; i&lt;l; i++) {
                    var colorFunc = d3.interpolateRgb.apply(null, [colorM[i][0],colorM[i][1]]);
                    colorArray[colorArray.length]=colorFunc(ratio);
                }
                color = d3.scale.ordinal().range(colorArray);
                break;
        }
        return color;
    };

    Parallel.prototype.render = function (options) {
        this.setOptions(options);
        this.layout();
        this.generatePaths();
    };

    Parallel.prototype.path = function (d) {
        var line = d3.svg.line();
        var conf = this.defaults;
        var y = this.y;
        var x = this.x;
        var dimensions = this.dimensions;
        var dimensionType = this.dimensionType;
        return line(dimensions.map(function(p, i) {
            var yLoc = y[p](d[p]);
            if(dimensionType[p] === &quot;ordinal&quot;){
                yLoc +=  y[p].rangeBand()/2;
            }
            return [x(i), yLoc];
        }));
    };

    return Parallel;
});</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/pie" class="api">
  <h2>charts/pie: API索引</h2>
  <ul class="indexs">
  
    <li>
      <a href="#_Pie">Pie</a>
    </li>

    <li>
      <a href="#_createCanvas">createCanvas</a>
    </li>

    <li>
      <a href="#_getColor">getColor</a>
    </li>

    <li>
      <a href="#_render">render</a>
    </li>

    <li>
      <a href="#_tag">tag</a>
    </li>

    <li>
      <a href="#_setSource">setSource</a>
    </li>

    <li>
      <a href="#_layout">layout</a>
    </li>

  </ul>
  <hr />

  

  <table class="table">
  

  
  </table>
  
  
  <h3 id="_Pie">
    Pie
  </h3>
  

  <p>构造函数</p>

  <table class="table">
  
    <tr>
      <td>声明</td>
      <td>Pie</td> 
      <td></td>
      <td>Pie</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>container(Object)</td>
      <td colspan="2">表示在html的哪个容器中绘制该组件</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>options(Object)</td>
      <td colspan="2">为用户自定义的组件的属性，比如画布大小</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>var Pie = DataV.extend(DataV.Chart, {
        initialize: function (container, options) {
            this.type = &quot;Pie&quot;;
            this.node = this.checkContainer(container);
            this.defaults = {};
            this.sum = 0;
            this.groupNames = []; //数组：记录每个group的名字
            this.groupValue = [];
            this.groups = [];
            this.click = 0;

            //图的大小设置
            this.defaults.tag = true;
            this.defaults.width = 800;
            this.defaults.height = 800;

            //设置用户指定的属性
            this.setOptions(options);

            this.tagArea = [20, (this.defaults.height - 20 - 220), 200, 220];
            if (this.defaults.tag) {
                this.xOffset = this.tagArea[2];
            } else {
                this.xOffset = 0;
            }

            this.defaults.radius = Math.min((this.defaults.width - this.xOffset), this.defaults.height) * 0.3;
            this.defaults.protrude = this.defaults.radius * 0.1;
            //创建画布
            this.createCanvas();
        }
    });</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_createCanvas">
    createCanvas
  </h3>
  

  <p>创建画布</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Pie.prototype.createCanvas()</td> 
      <td></td>
      <td>createCanvas</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Pie.prototype.createCanvas = function () {
        this.canvas = new Raphael(this.node, this.defaults.width, this.defaults.height);
        var canvasStyle = this.node.style;
        canvasStyle.position = &quot;relative&quot;;
        this.floatTag = DataV.FloatTag()(this.node);
        this.floatTag.css({
            &quot;visibility&quot;: &quot;hidden&quot;
        });
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_getColor">
    getColor
  </h3>
  

  <p>获取颜色</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Pie.prototype.getColor()</td> 
      <td></td>
      <td>getColor</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>i(Number)</td>
      <td colspan="2">元素类别编号</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>String</td>
      <td colspan="2">返回颜色值</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Pie.prototype.getColor = function (i) {
        var color = DataV.getColor();
        return color[i % color.length][0];
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_render">
    render
  </h3>
  

  <p>绘制饼图</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Pie.prototype.render()</td> 
      <td></td>
      <td>render</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Pie.prototype.render = function () {
        var conf = this.defaults;
        var floatTag = this.floatTag;
        var that = this;
        this.layout();
        var groups = this.groups;

        //由内外半径、起始角度计算路径字符串
        var pathCalc = d3.svg.arc().innerRadius(conf.radius).outerRadius(0).startAngle(function (d) {
            return d.startAngle;
        }).endAngle(function (d) {
            return d.endAngle;
        });

        var donutEle;
        //获取每个环形的字符串表示
        var spline;
        var tips;
        that.donutGroups = that.canvas.set();

        $(this.node).append(this.floatTag);

        //添加透明效果

        var mouseOver = function () {
            floatTag.html('&lt;div style = &quot;text-align: center;margin:auto;color:' + &quot;#ffffff&quot; + '&quot;&gt;' + this.data('text') + '&lt;/div&gt;');
            floatTag.css({
                &quot;visibility&quot;: &quot;visible&quot;
            });
            var index = this.data(&quot;donutIndex&quot;);
            if (!this.data('click')) {
                that.underBn[index].attr('opacity', 0.5).show();
            }
            if (that.click === 0) {
                that.donutGroups.forEach(function (d) {
                    if (index !== d.data(&quot;donutIndex&quot;)) {
                        d.attr('fill-opacity', 0.5);
                    }
                });
            }
            this.attr('fill-opacity', 1);
        };

        var mouseOut = function () {
            floatTag.css({
                &quot;visibility&quot;: &quot;hidden&quot;
            });
            var index = this.data(&quot;donutIndex&quot;);
            //fade(this.data(&quot;donutIndex&quot;), 0.6);
            if (!this.data('click')) {
                that.underBn[index].hide();
            }
            if (that.click === 0) {
                that.donutGroups.forEach(function (d) {
                    d.attr('fill-opacity', 1);
                });
            } else if (!this.data('click')) {

                this.attr('fill-opacity', 0.5);
            }
        };

        var mouseClick = function () {
            var index = this.data(&quot;donutIndex&quot;);
            var flag = !this.data('click');
            this.data('click', flag);
            var a = 0.5 * ((that.groups[index].startAngle + that.groups[index].endAngle) - Math.PI);
            var nameX = conf.protrude * Math.cos(a);
            var nameY = conf.protrude * Math.sin(a);
            if (flag) {
                if (that.click === 0) {
                    that.donutGroups.forEach(function (d) {
                        if (!d.data('click')) {
                            d.attr('fill-opacity', 0.5);
                        }
                    });
                }
                that.underBn[index].attr('opacity', 1).show();
                this.attr('fill-opacity', 1);
                this.data('nameTag').translate(0, - conf.protrude);
                this.data('line').translate(0, - conf.protrude);
                this.translate(nameX, nameY);
                that.click += 1;
            } else {
                this.data('nameTag').translate(0, conf.protrude);
                this.data('line').translate(0, conf.protrude);
                this.translate(-nameX, - nameY);
                that.click -= 1;
                if (that.click &gt; 0) {
                    this.attr('fill-opacity', 0.5);
                }
            }
        };


        //画圆弧
        var i;
        var nameStr;
        var nameX, nameY;
        var ro, a;
        for (i = 0; i &lt;= groups.length - 1; i++) {
            //画外圈的pie图
            //计算每个group的path
            spline = pathCalc(groups[i]);
            tips = that.groupNames[i] + &quot;: &quot; + Math.round(groups[i].value) + &quot; &quot; + (groups[i].value * 100 / this.sum).toFixed(2) + &quot;%&quot;;

            donutEle = that.canvas.path(spline).translate((conf.width - this.xOffset) / 2 + this.xOffset, conf.height / 2).data(&quot;donutIndex&quot;, i).attr({
                &quot;path&quot;: spline,
                &quot;fill&quot;: that.getColor(i),
                &quot;stroke&quot;: '#ffffff'
            }).mouseover(mouseOver).mouseout(mouseOut).click(mouseClick);

            //每个donut上显示名称
            ro = (groups[i].startAngle + groups[i].endAngle) * 90 / Math.PI;
            a = 0.5 * ((groups[i].startAngle + groups[i].endAngle) - Math.PI);
            nameX = (conf.radius + 2 * conf.protrude) * Math.cos(a);
            nameY = (conf.radius + 2 * conf.protrude) * Math.sin(a);
            nameStr = &quot;T&quot; + ((conf.width - that.xOffset) / 2 + that.xOffset) + &quot;,&quot; + conf.height / 2 + &quot;R&quot; + ro + &quot;T&quot; + nameX + &quot;,&quot; + nameY;

            var line = that.canvas.path(&quot;M,0,-&quot; + conf.protrude + &quot;L0,&quot; + conf.protrude).transform(nameStr).translate(0, conf.protrude + 9);
            var nameTag = that.canvas.text().attr(&quot;font&quot;, &quot;18px Verdana&quot;).attr(&quot;text&quot;, that.groupNames[i]).transform(nameStr);

            donutEle.data('text', tips).data('click', false).data('nameTag', nameTag).data('line', line);
            that.donutGroups.push(donutEle);

        }


        if (conf.tag) {
            this.tag();
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_tag">
    tag
  </h3>
  

  <p>绘制图例</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Pie.prototype.tag()</td> 
      <td></td>
      <td>tag</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Pie.prototype.tag = function () {
        var that = this;
        var conf = this.defaults;
        var paper = this.canvas;
        var tagArea = this.tagArea;
        this.rectBn = paper.set();
        var rectBn = this.rectBn;
        this.underBn = [];
        var underBn = this.underBn;
        for (var i = 0, l = this.groups.length; i &lt; l; i++) {
            //底框
            underBn.push(paper.rect(tagArea[0] + 10, tagArea[1] + 10 + (20 + 3) * i, 180, 20).attr({
                &quot;fill&quot;: &quot;#ebebeb&quot;,
                &quot;stroke&quot;: &quot;none&quot;
                //&quot;r&quot;: 3
            }).hide());
            //色框
            paper.rect(tagArea[0] + 10 + 3, tagArea[1] + 10 + (20 + 3) * i + 6, 16, 8).attr({
                &quot;fill&quot;: this.getColor(i),
                &quot;stroke&quot;: &quot;none&quot;
            });
            //文字
            paper.text(tagArea[0] + 10 + 3 + 16 + 8, tagArea[1] + 10 + (20 + 3) * i + 10, this.groupNames[i]).attr({
                &quot;fill&quot;: &quot;black&quot;,
                &quot;fill-opacity&quot;: 1,
                &quot;font-family&quot;: &quot;Verdana&quot;,
                &quot;font-size&quot;: 12
            }).attr({
                &quot;text-anchor&quot;: &quot;start&quot;
            });
            //选框
            rectBn.push(paper.rect(tagArea[0] + 10, tagArea[1] + 10 + (20 + 3) * i, 180, 20).attr({
                &quot;fill&quot;: &quot;white&quot;,
                &quot;fill-opacity&quot;: 0,
                &quot;stroke&quot;: &quot;none&quot;
                //&quot;r&quot;: 3
            }));
        }
        rectBn.forEach(function (d, i) {
            // TODO 这里的事件建议采用事件委托
            d.mouseover(function () {
                if (!that.donutGroups[i].data(&quot;click&quot;)) {
                    underBn[i].attr('opacity', 0.5);
                    underBn[i].show();
                }
            }).mouseout(function () {
                if (!that.donutGroups[i].data(&quot;click&quot;)) {
                    underBn[i].hide();
                }
            });
            d.click(function () {
                var a = 0.5 * ((that.groups[i].startAngle + that.groups[i].endAngle) - Math.PI);
                var nameX = conf.protrude * Math.cos(a);
                var nameY = conf.protrude * Math.sin(a);
                if (!that.donutGroups[i].data(&quot;click&quot;)) {
                    if (that.click === 0) {
                        that.donutGroups.forEach(function (d) {
                            if (!d.data('click')) {
                                d.attr('fill-opacity', 0.5);
                            }
                        });
                    }
                    underBn[i].attr('opacity', 1).show();
                    that.donutGroups[i].data(&quot;click&quot;, true).attr('fill-opacity', 1);
                    that.donutGroups[i].data('nameTag').translate(0, - conf.protrude);
                    that.donutGroups[i].data('line').translate(0, - conf.protrude);
                    that.donutGroups[i].translate(nameX, nameY);
                    that.click += 1;

                } else if (that.donutGroups[i].data(&quot;click&quot;)) {
                    that.donutGroups[i].data('nameTag').translate(0, conf.protrude);
                    that.donutGroups[i].data('line').translate(0, conf.protrude);
                    that.donutGroups[i].translate(-nameX, - nameY);
                    that.click -= 1;
                    if (that.click &gt; 0) {
                        that.donutGroups[i].attr('fill-opacity', 0.5);
                    } else {
                        that.donutGroups.forEach(function (d) {
                            d.attr('fill-opacity', 1);
                        });
                    }
                    underBn[i].hide();
                    that.donutGroups[i].data(&quot;click&quot;, false);

                }
            });
        });
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setSource">
    setSource
  </h3>
  

  <p>对原始数据进行处理</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Pie.prototype.setSource()</td> 
      <td></td>
      <td>setSource</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>table(Array)</td>
      <td colspan="2">将要被绘制成饼图的二维表数据</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Pie.prototype.setSource = function (table) {
        if (table[0][0] !== null) {
            var t;
            for (t = 0; t &lt; table[0].length; t++) {
                this.groupNames[t] = table[0][t];
                this.groupValue[t] = Number(table[1][t]);
            }
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_layout">
    layout
  </h3>
  

  <p>创建pie布局</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Pie.prototype.layout()</td> 
      <td></td>
      <td>layout</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Pie.prototype.layout = function () {
        var that = this;

        that.canvas.clear();

        var v = [50265, 60555, 38544, 27276, 20506, 26916, 17636, 977, 10406, 6695];
        var acc = 0;
        var i;
        for (i = 0; i &lt; this.groupValue.length; i++) {
            this.sum += this.groupValue[i];
        }
        for (i = 0; i &lt; this.groupValue.length; i++) {
            this.groups[i] = {};
            this.groups[i].index = i;
            this.groups[i].value = this.groupValue[i];
            this.groups[i].startAngle = 2 * acc * Math.PI / this.sum;
            acc += this.groupValue[i];
            this.groups[i].endAngle = 2 * acc * Math.PI / this.sum;
        }
    };

    return Pie;
});</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/scatterplotMatrix" class="api">
  <h2>charts/scatterplotMatrix: API索引</h2>
  <ul class="indexs">
  
  </ul>
  <hr />

  

  <p>lobal Raphael, d3, $, define</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>;(function (name, definition) {
    if (typeof define === 'function') { // Module
        define(definition);
    } else { // Assign to common namespaces or simply the global object (window)
        this[name] = definition(function (id) { return this[id];});
    }
})('ScatterplotMatrix', function (require) {
    var DataV = require('DataV');

    var ScatterplotMatrix = DataV.extend(DataV.Chart, {
        initialize: function (node, options) {
            this.type = &quot;ScatterplotMatrix&quot;;
            this.container = node;
            this.node = this.checkNode(node);
            this.defaults = {};

            // Properties
            this.defaults.allDimensions = [];
            this.defaults.dimensionsX = []; //dimension of X axis(horizonal).  array type
            this.defaults.demensionsY = []; //dimension of Y axis(vertical).  array type
            this.defaults.dimensionDomain = {};
            this.defaults.typeNames = [];

            // canvas parameters
            this.defaults.width = 522;
            this.defaults.height = 522;
            this.defaults.margin = 50;
            this.defaults.gap = 15;
            this.defaults.squareWidth = 150;
            this.defaults.circleR = 3;

            //图例区域的左上顶点坐标x，y，宽，高
            this.defaults.tagArea = [20, (this.defaults.height - 20 - 220), 200, 220];
            //简介区域的左上角顶点坐标x，y，宽，高
            this.defaults.introArea = [20, 20, 200, 200];
            //散点矩阵区域的左上顶点坐标x，y，宽，高
            this.defaults.diagramArea = [240, 20, (this.defaults.width - 260), (this.defaults.height - 40)];

            this.defaults.typeName = &quot;NoTypeDefinition&quot;; //默认情况是没有分类
            this.defaults.tagDimen = &quot;NoTagDimen&quot;;


            this.setOptions(options);
            this.createCanvas();
        }
    });

    //check the DOM node to draw
    ScatterplotMatrix.prototype.checkNode = function (node) {
        if (!node) {
            throw new Error(&quot;Please specify which node to render.&quot;);
        }
        if (typeof (node) === &quot;string&quot;) {
            return document.getElementById(node);
        } else if (node.nodeName) { //DOM-element
            return node;
        }
        throw new Error(&quot;Please specify which node to render.&quot;);
    };

    //check if a string is in an array
    var _strInArray = function (str, array) {
        var i = 0,
            l = 0;
        for (i = 0, l = array.length; i &lt; l; i++) {
            if (array[i] === str) {
                return true;
            }
        }
        return false;
    };

    //设置X轴的维度
    ScatterplotMatrix.prototype.setDimensionsX = function (dimen) {
        if (!dimen) {
            throw new Error(&quot;Please specify the dimensions.&quot;);
        }
        var conf = this.defaults;
        conf.dimensionsX = [];
        var i = 0,
            l = 0;
        for (i = 0, l = dimen.length; i &lt; l; i++) {
            if (_strInArray(dimen[i], conf.allDimensions)) {
                conf.dimensionsX.push(dimen[i]);
            }
        }
    };

    //设置Y轴的维度
    ScatterplotMatrix.prototype.setDimensionsY = function (dimen) {
        if (!dimen) {
            throw new Error(&quot;Please specify the dimensions.&quot;);
        }
        var conf = this.defaults;
        conf.dimensionsY = [];
        var i = 0,
            l = 0;
        for (i = 0, l = dimen.length; i &lt; l; i++) {
            if (_strInArray(dimen[i], conf.allDimensions)) {
                conf.dimensionsY.push(dimen[i]);
            }
        }
    };

    //设置类型的名字
    ScatterplotMatrix.prototype.setTypeName = function (types) {
        this.defaults.typeNames = types;
    };

    //额外选项
    ScatterplotMatrix.prototype.setOptions = function (options) {
        var prop;
        if (options) {
            for (prop in options) {
                if (options.hasOwnProperty(prop)) {
                    this.defaults[prop] = options[prop];
                }
            }
        }
    };
    //设置源数据
    ScatterplotMatrix.prototype.setSource = function (source) {
        var i, j, l, ll;
        var conf = this.defaults;

        var xTemp = [],
            yTemp = [];
        for (i = 1; i &lt; source[0].length; i++) {
            xTemp[i - 1] = source[0][i];
            yTemp[i - 1] = source[0][i];
        }
        conf.allDimensions = source[0];
        //默认情况下，所有维度都显示
        conf.dimensionsX = xTemp;
        conf.dimensionsY = yTemp;

        //this.source is array of line; key is dimension, value is line's value in that dimension 
        this.source = [];

        for (i = 1, l = source.length; i &lt; l; i++) {
            var line = {}, dimenT = conf.allDimensions;
            for (j = 0, ll = dimenT.length; j &lt; ll; j++) {
                line[dimenT[j]] = source[i][j]; //each line is an array, contains value for each dimension
            }
            this.source.push(line);
        }

        //设置默认的定义域
        var getExtent = function (s, dimen) {
            return d3.extent(s, function (p) {
                return +p[dimen];
            });
        };
        var dimen;
        for (i = 0, l = conf.allDimensions.length; i &lt; l; i++) {
            dimen = conf.allDimensions[i];
            conf.dimensionDomain[dimen] = getExtent(this.source, dimen);
        }
    };

    //设置X轴和Y轴
    ScatterplotMatrix.prototype.setAxis = function () {
        var conf = this.defaults;

        conf.tagArea = [20, (conf.height - 20 - 220), 200, 220];
        conf.introArea = [20, 20, 200, 200];
        conf.diagramArea = [240, 20,</code></pre></td>
    </tr>
  
  </table>
  
  

  <p>00, 500</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>(conf.width - 260), (conf.height - 40)];

        var w = conf.diagramArea[2] - 2 * conf.margin,
            h = conf.diagramArea[3] - conf.margin,
            g = conf.gap,
            nX = conf.dimensionsX.length,
            nY = conf.dimensionsY.length,
            wX = d3.round((w - (nX - 1) * g) / nX),
            wY = d3.round((h - (nY - 1) * g) / nY),
            sw = d3.min([wX, wY]);

        this.defaults.squareWidth = sw;
        this.defaults.dX = conf.dimensionsX[0];
        this.defaults.dY = conf.dimensionsY[0];

        this.x = {};
        this.y = {};
        var x = this.x,
            y = this.y;
        var tickAr = [5];

        //设置X轴
        var i, l, dimen, begin, end;
        for (i = 0, l = conf.dimensionsX.length; i &lt; l; i++) {
            dimen = conf.dimensionsX[i];
            begin = i * (sw + g) + conf.diagramArea[0] + 30;
            end = begin + sw;
            x[dimen] = d3.scale.linear().domain(conf.dimensionDomain[dimen]).range([begin, end]);
            x[dimen].ticks = x[dimen].ticks.apply(x[dimen], tickAr);
        }
        //设置Y轴
        for (i = 0, l = conf.dimensionsY.length; i &lt; l; i++) {
            dimen = conf.dimensionsY[i];
            end = i * (sw + g) + conf.diagramArea[1] + 30;
            begin = end + sw;
            y[dimen] = d3.scale.linear().domain(conf.dimensionDomain[dimen]).range([begin, end]);
            y[dimen].ticks = y[dimen].ticks.apply(y[dimen], tickAr);
        }
    };

    //画散点矩阵
    ScatterplotMatrix.prototype.drawDiagram = function () {
        var i, j, k, z, ticks;
        var conf = this.defaults,
            x = this.x,
            y = this.y,
            sw = conf.squareWidth,
            g = conf.gap,
            cR = conf.circleR;

        var paper = this.canvas;
        var sourceData = this.source;

        var dimensionsX = conf.dimensionsX,
            dimensionsY = conf.dimensionsY,
            lx = dimensionsX.length,
            ly = dimensionsY.length;

        var browserName = navigator.appName;
        var that = this;

        $(&quot;#&quot; + this.containers).append(this.floatTag);

        //画背景点------------------------------------------------------------------------//
        var circlesBg = paper.set(); //背景点
        var centerPos;

        if (browserName !== &quot;Microsoft Internet Explorer&quot;) {
            for (k = 0; k &lt; sourceData.length; k++) {
                for (i = 0; i &lt; lx; i++) {
                    for (j = 0; j &lt; ly; j++) {
                        centerPos = this.circleCenter(k, dimensionsX[i], dimensionsY[j]);
                        circlesBg.push(paper.circle(centerPos[0], centerPos[1], cR).attr({
                            &quot;fill&quot;: &quot;gray&quot;,
                            &quot;stroke&quot;: &quot;none&quot;,
                            &quot;opacity&quot;: 0.2
                        }));
                    }
                }
            } 
        }
        

        //画矩形框 ------------------------------------------------------------------------// 
        var squares = paper.set();
        var x1, y1;
        for (i = 0; i &lt; lx; i++) {
            for (j = 0; j &lt; ly; j++) {
                x1 = x[dimensionsX[i]].range()[0];
                y1 = y[dimensionsY[j]].range()[1];
                squares.push(paper.rect(x1 - 1, y1 - 1, sw + 2, sw + 2));
            }
        }
        squares.attr({
            &quot;fill&quot;: &quot;white&quot;,
            &quot;fill-opacity&quot;: 0.5, //背景点的蒙版
            &quot;stroke&quot;: &quot;#d6d6d6&quot;,
            &quot;stroke-width&quot;: '1px'
        });

        //画虚线 --------------------------------------------------------------------//
        var reLines = paper.set(),
            tickText = paper.set();
        var tickAr = [10], //set the number of ticks
            leftPos = x[dimensionsX[0]].range()[0],
            rightPos = x[dimensionsX[lx - 1]].range()[1],
            upPos = y[dimensionsY[0]].range()[1],
            downPos = y[dimensionsY[ly - 1]].range()[0];

        var reLineGap = sw / 7; //每个矩形框中画6条虚线
        var reLinePos;

        //画纵向的虚线 ---------------------------------------------------------------------//
        for (i = 0; i &lt; lx; i++) {
            ticks = x[dimensionsX[i]].ticks;
            for (j = 0; j &lt; ticks.length; j++) {
                tickText.push(paper.text((x[dimensionsX[i]](ticks[j])), downPos + 6, ticks[j]).attr({
                    &quot;fill&quot;: &quot;#aaaaaa&quot;,
                    &quot;fill-opacity&quot;: 0.7,
                    &quot;font-family&quot;: &quot;雅黑&quot;,
                    &quot;font-size&quot;: 12
                }).attr({
                    &quot;text-anchor&quot;: &quot;end&quot;
                }).rotate(-45, x[dimensionsX[i]](ticks[j]), downPos + 6));
            }
            for (z = 1; z &lt; 7; z++) {
                reLinePos = x[dimensionsX[i]].range()[0] + z * reLineGap;
                reLines.push(paper.path(&quot;M&quot; + (reLinePos) + &quot;,&quot; + (upPos) + &quot;L&quot; + (reLinePos) + &quot;,&quot; + (downPos)).attr({
                    &quot;stroke&quot;: &quot;#ebebeb&quot;,
                    &quot;stroke-dasharray&quot;: &quot;-&quot;
                }));
            }
        }
        //画横向的虚线 ---------------------------------------------------------------------//
        for (i = 0; i &lt; ly; i++) {
            //draw reference lines
            ticks = y[dimensionsY[i]].ticks;
            for (j = 0; j &lt; ticks.length; j++) {
                tickText.push(paper.text(rightPos + 6, y[dimensionsY[i]](ticks[j]), ticks[j]).attr({
                    &quot;fill&quot;: &quot;#aaaaaa&quot;,
                    &quot;fill-opacity&quot;: 0.7,
                    &quot;font-family&quot;: &quot;雅黑&quot;,
                    &quot;font-size&quot;: 12
                }).attr({
                    &quot;text-anchor&quot;: &quot;start&quot;
                }).rotate(315, rightPos + 6, y[dimensionsY[i]](ticks[j])));
            }
            for (z = 1; z &lt; 7; z++) {
                reLinePos = y[dimensionsY[i]].range()[1] + z * reLineGap;
                reLines.push(paper.path(&quot;M&quot; + (leftPos) + &quot;,&quot; + (reLinePos) + &quot;L&quot; + (rightPos) + &quot;,&quot; + (reLinePos)).attr({
                    &quot;stroke&quot;: &quot;#ebebeb&quot;,
                    &quot;stroke-dasharray&quot;: &quot;-&quot;
                }));
            }
        }

        //坐标轴名称 --------------------------------------------------------------------------// 
        var axText = paper.set();
        var xPos, yPos;
        var pos = y[dimensionsY[0]].range()[1] - 10;
        for (i = 0; i &lt; lx; i++) {
            xPos = x[dimensionsX[i]].range()[0] + sw / 2;
            axText.push(paper.text(xPos, pos, dimensionsX[i]).attr({
                &quot;fill&quot;: &quot;#000000&quot;,
                &quot;fill-opacity&quot;: 0.7,
                &quot;font-family&quot;: &quot;Verdana&quot;,
                //&quot;font-weight&quot;: &quot;bold&quot;,
                &quot;font-size&quot;: 12
            }).attr({
                &quot;text-anchor&quot;: &quot;middle&quot;
            }));
        }

        pos = x[dimensionsX[0]].range()[0] - 10;
        for (i = 0; i &lt; ly; i++) {
            yPos = y[dimensionsY[i]].range()[1] + sw / 2;
            axText.push(paper.text(pos, yPos, dimensionsY[i]).attr({
                &quot;fill&quot;: &quot;#000000&quot;,
                &quot;fill-opacity&quot;: 0.7,
                &quot;font-family&quot;: &quot;Verdana&quot;,
                //&quot;font-weight&quot;: &quot;bold&quot;,
                &quot;font-size&quot;: 12
            }).attr({
                &quot;text-anchor&quot;: &quot;middle&quot;
            }).rotate(-90, pos, yPos));
        }

        //画前景点 ---------------------------------------------------------------------------// 
        var circlesFg = []; //circles in foreground   
        var circleType = -1;
        var typeMax = -1;

        this.preIndex = &quot;start&quot;;
        this.linePosition = [0,0];
        //水平虚线
        that.lineH = paper.path(&quot;M&quot; + (leftPos) + &quot;,&quot; + (0) + &quot;L&quot; + (rightPos) + &quot;,&quot; + (0)).attr({
            &quot;stroke-dasharray&quot;: &quot;- &quot;,
            'stroke': '#000000'
        }).hide();
        //垂直虚线
        that.lineV = paper.path(&quot;M&quot; + (0) + &quot;,&quot; + (upPos) + &quot;L&quot; + (0) + &quot;,&quot; + (downPos)).attr({
            &quot;stroke-dasharray&quot;: &quot;- &quot;,
            'stroke': '#000000'
        }).hide();
        var hoverTag;
        var circle;
        for (k = 0; k &lt; sourceData.length; k++) {
            if (conf.typeName !== &quot;NoTypeDefinition&quot;) { //classify the circles according to their types
                circleType = sourceData[k][conf.typeName] - 1;
                typeMax = Math.max(typeMax, circleType);
            } else {
                circleType = 0;
            }
            for (i = 0; i &lt; lx; i++) {
                for (j = 0; j &lt; ly; j++) {
                    centerPos = this.circleCenter(k, dimensionsX[i], dimensionsY[j]);
                    //前景点
                    circle = paper.circle(centerPos[0], centerPos[1], cR)
                    .data(&quot;type&quot;, circleType)
                    .data(&quot;canHover&quot;, 0)
                    .data(&quot;position&quot;, centerPos)
                    .data('colorType', circleType)
                    .attr({
                        &quot;fill&quot;: &quot;#800&quot;,
                        &quot;stroke&quot;: &quot;none&quot;,
                        &quot;opacity&quot;: 0.5
                    }).attr({
                        &quot;fill&quot;: this.getColor(circleType)
                    });
                    //如果制定了hover要显示的文字，则hover显示的文字
                    if (conf.tagDimen !== &quot;NoTagDimen&quot;) {
                        hoverTag = conf.tagDimen + &quot;: &quot; + sourceData[k][conf.tagDimen];
                        circle.data(&quot;tag&quot;, hoverTag);
                    }
                    circlesFg.push(circle);
                }
            }
        }

        //图例--- ------------------------------------------------------------------//
        
            var tagArea = this.defaults.tagArea;
            var rectBn = paper.set();
            var underBn = [];
            for (i = 0; i &lt;= typeMax; i++) {
                //底框
                underBn.push(paper.rect(tagArea[0] + 10, tagArea[1] + 10 + (20 + 3) * i, 180, 20).attr({
                    &quot;fill&quot;: &quot;#ebebeb&quot;,
                    &quot;stroke&quot;: &quot;none&quot;
                }).hide());
                //色框
                paper.rect(tagArea[0] + 10 + 3, tagArea[1] + 10 + (20 + 3) * i + 6, 16, 8).attr({
                    &quot;fill&quot;: this.getColor(i),
                    &quot;stroke&quot;: &quot;none&quot;
                });
                //文字
                paper.text(tagArea[0] + 10 + 3 + 16 + 8, tagArea[1] + 10 + (20 + 3) * i + 10, conf.typeNames[i]).attr({
                    &quot;fill&quot;: &quot;black&quot;,
                    &quot;fill-opacity&quot;: 1,
                    &quot;font-family&quot;: &quot;Verdana&quot;,
                    &quot;font-size&quot;: 12
                }).attr({
                    &quot;text-anchor&quot;: &quot;start&quot;
                });
                //选框
                rectBn.push(paper.rect(tagArea[0] + 10, tagArea[1] + 10 + (20 + 3) * i, 180, 20).attr({
                    &quot;fill&quot;: &quot;white&quot;,
                    &quot;fill-opacity&quot;: 0,
                    &quot;stroke&quot;: &quot;none&quot;
                    //&quot;r&quot;: 3
                }).data(&quot;type&quot;, i)).data(&quot;clicked&quot;, 0);
            }

        if (browserName !== &quot;Microsoft Internet Explorer&quot;) {
            rectBn.forEach(function (d, i) {
                underBn[i].data('tagclicked', false);
                d.mouseover(function () {
                    if (underBn[i].data('tagclicked') === false) {
                        underBn[i].attr('opacity', 0.5).show();
                    }
                }).mouseout(function () {
                    if (underBn[i].data('tagclicked') === false) {
                        underBn[i].hide();
                    }
                });
                d.click(function () {
                    for (j = 0; j &lt; underBn.length; j++) {
                        if (j === i) {
                            underBn[j].show();
                        } else {
                            underBn[j].hide();
                        }
                    }
                    rectBn.forEach(function (eachBn) {
                        if (eachBn !== d) {
                            eachBn.data(&quot;clicked&quot;, 0);
                        }

                    });
                    if (d.data(&quot;clicked&quot;) === 0) {
                        underBn[i].attr('opacity', 1).show();
                        underBn[i].data('tagclicked', true);
                        circlesFg.forEach(function (ec) {
                            if (ec.data(&quot;type&quot;) !== d.data(&quot;type&quot;)) {
                                ec.hide();
                                ec.data(&quot;canHover&quot;, 0);
                            } else {
                                ec.show();
                                ec.data(&quot;canHover&quot;, 1);
                            }
                        });
                        d.data(&quot;clicked&quot;, 1);
                    } else if (d.data(&quot;clicked&quot;) === 1) {
                        underBn[i].hide();
                        underBn[i].data('tagclicked', false);
                        d.data(&quot;clicked&quot;, 0);
                        circlesFg.forEach(function (ec) {
                            ec.show();
                            ec.data(&quot;canHover&quot;, 0);
                        });
                    }
                });
            });

            //Bursh函数定义 --------------------------------------------------------------//
            var curBrush;

            function brushstart() {
                if (curBrush !== undefined &amp;&amp; curBrush !== d3.event.target) {
                    curBrush.clear();
                }
                var i;
                for (i = 0; i &lt; circlesFg.length; i++) {
                    circlesFg[i].hide();
                    circlesFg[i].data(&quot;canHover&quot;, 0);
                }
                underBn.forEach(function (ub) {
                    ub.hide();
                });
                rectBn.forEach(function (rb) {
                    rb.data(&quot;clicked&quot;, 0);
                });
            }

            function brush() {
                curBrush = d3.event.target;

                var e = curBrush.extent(),
                    dimX = d3.event.target.dimX,
                    dimY = d3.event.target.dimY,
                    tempX,
                    tempY,
                    count = lx * ly,
                    i,
                    z;

                for (i = 0; i &lt; sourceData.length; i++) {
                    tempX = sourceData[i][dimX];
                    tempY = sourceData[i][dimY];
                    if (e[0][0] - 1 &lt;= tempX &amp;&amp; tempX &lt;= e[1][0] + 1 &amp;&amp; e[0][1] - 1 &lt;= tempY &amp;&amp; tempY &lt;= e[1][1] + 1) {
                        for (z = 0; z &lt; count; z++) {
                            circlesFg[i * count + z].show();
                        }
                    } else {
                        for (z = 0; z &lt; count; z++) {
                            circlesFg[i * count + z].hide();
                        }
                    }
                }
            }

            function brushend() {
                if (d3.event.target.empty()) {
                    circlesFg.forEach(function (d) {
                        d.show();
                    });
                }
            }

            //Brush交互 -----------------------------------------------------------------------//
            var brushes = [];
            var b;
            for (i = 0; i &lt; lx; i++) {
                for (j = 0; j &lt; ly; j++) {
                    b = DataV.Brush().x(x[dimensionsX[i]]).y(y[dimensionsY[j]]).backgroundAttr({
                        &quot;opacity&quot;: 0, //背景颜色：白色、全透明
                        &quot;fill&quot;: &quot;white&quot;
                    }).foregroundAttr({ //选框颜色
                        &quot;opacity&quot;: 0.2,
                        &quot;fill&quot;: &quot;#fff700&quot;
                    }).on(&quot;brushstart&quot;, brushstart).on(&quot;brush&quot;, brush).on(&quot;brushend&quot;, brushend);
                    b(paper);
                    b.dimX = dimensionsX[i];
                    b.dimY = dimensionsY[j];
                    brushes.push(b);
                }
            }
            //hover交互 -------------------------------------------------------------------------//
            //var preIndex = &quot;start&quot;;
            var floatTag = this.floatTag;
            $(paper.canvas).bind(&quot;mousemove&quot;, function (e) {
                var bgOffset = $(this).parent().offset();
                var mouse = [e.pageX - bgOffset.left, e.pageY - bgOffset.top];
                var location = [Math.floor((mouse[0] - leftPos) / (sw + g)), Math.floor((mouse[1] - upPos) / (sw + g))];
                if (that.preIndex !== &quot;start&quot;) {
                    that.lineV.hide();
                    that.lineH.hide();
                    if (conf.tagDimen !== &quot;NoTagDimen&quot;) {
                        floatTag.css({&quot;visibility&quot; : &quot;hidden&quot;});
                    }
                }
                if (location[0] &gt;= 0 &amp;&amp; location[0] &lt;= lx &amp;&amp; location[1] &gt;= 0 &amp;&amp; location[1] &lt;= ly) {
                    for (i = location[0] * ly + location[1]; i &lt; circlesFg.length; i = i + lx * ly) {
                        var center = circlesFg[i].data(&quot;position&quot;);
                        var canHover = circlesFg[i].data(&quot;canHover&quot;);
                        if ((canHover === 1) &amp;&amp; (Math.abs(mouse[0] - center[0]) &lt;= cR) &amp;&amp; (Math.abs(mouse[1] - center[1]) &lt;= cR)) {
                            that.lineV.translate(center[0] - that.linePosition[0], 0).attr('stroke', that.getColor(circlesFg[i].data('colorType'))).show();
                            that.lineH.translate(0, center[1] - that.linePosition[1]).attr('stroke', that.getColor(circlesFg[i].data('colorType'))).show();
                            that.linePosition = center;
                            if (conf.tagDimen !== &quot;NoTagDimen&quot;) {
                                floatTag.html ( '&lt;div style = &quot;text-align: center;margin:auto;color:'
                                //+ jqNode.color
                                + &quot;#ffffff&quot;
                                + '&quot;&gt;' + circlesFg[i].data(&quot;tag&quot;) + '&lt;/div&gt;'
                                );
                                floatTag.css({&quot;visibility&quot; : &quot;visible&quot;});
                            }
                            that.preIndex = i;
                            break;
                        }
                    }
                }
            });
        }
    };

    //创建canvas
    ScatterplotMatrix.prototype.createCanvas = function () {
        if (!this.node) {
            throw new Error(&quot;Please specify which node to render.&quot;);
        }
        var conf = this.defaults;
        this.node.style.position = &quot;relative&quot;;
        this.canvas = new Raphael(this.node, conf.width, conf.height);

        this.canvasF = document.getElementById(this.container);
        this.floatTag = DataV.FloatTag()(this.canvasF);
        this.floatTag.css({&quot;visibility&quot;: &quot;hidden&quot;});
    };

    //根据不同类别得到颜色值
    ScatterplotMatrix.prototype.getColor = function (circleType) {
        var color = DataV.getColor();
        return color[circleType % color.length][0];
    };

    //绘制函数
    ScatterplotMatrix.prototype.render = function (options) {
        //var dBegin = new Date();   //for time-testing
        if (!this.node) {
            throw new Error(&quot;Please specify which node to render.&quot;);
        }
        this.setOptions(options);
        this.canvas.clear();
        this.setAxis();
        this.drawDiagram();
        //var dEnd = new Date();
        //alert(dEnd.getTime() - dBegin.getTime());
    };

    //计算每个circle的圆心位置
    ScatterplotMatrix.prototype.circleCenter = function (index, xDimen, yDimen) {
        var conf = this.defaults,
            source = this.source,
            y = this.y,
            x = this.x,
            dimensionsX = conf.dimensionsX,
            dimensionsY = conf.dimensionsY,
            dimensionType = conf.dimensionType;

        var xPos = x[xDimen](source[index][xDimen]),
            yPos = y[yDimen](source[index][yDimen]);

        return [xPos, yPos];
    };

    return ScatterplotMatrix;
});</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/stream" class="api">
  <h2>charts/stream: API索引</h2>
  <ul class="indexs">
  
    <li>
      <a href="#_Stream">Stream</a>
    </li>

    <li>
      <a href="#_createCanvas">createCanvas</a>
    </li>

    <li>
      <a href="#_setOptions">setOptions</a>
    </li>

    <li>
      <a href="#_hasRowName">hasRowName</a>
    </li>

    <li>
      <a href="#_hasColumnName">hasColumnName</a>
    </li>

    <li>
      <a href="#_sort">sort</a>
    </li>

    <li>
      <a href="#_getDigitData">getDigitData</a>
    </li>

    <li>
      <a href="#_getInfo">getInfo</a>
    </li>

    <li>
      <a href="#_setSource">setSource</a>
    </li>

    <li>
      <a href="#_setTimeRange">setTimeRange</a>
    </li>

    <li>
      <a href="#_layout">layout</a>
    </li>

    <li>
      <a href="#_getColor">getColor</a>
    </li>

    <li>
      <a href="#_generatePaths">generatePaths</a>
    </li>

    <li>
      <a href="#_createLegend">createLegend</a>
    </li>

    <li>
      <a href="#_createNavi">createNavi</a>
    </li>

    <li>
      <a href="#_getMaxPercentage">getMaxPercentage</a>
    </li>

    <li>
      <a href="#_createPercentage">createPercentage</a>
    </li>

    <li>
      <a href="#_createStreamPaths">createStreamPaths</a>
    </li>

    <li>
      <a href="#_createAxis">createAxis</a>
    </li>

    <li>
      <a href="#_getMaxY">getMaxY</a>
    </li>

    <li>
      <a href="#_mapPathSource">mapPathSource</a>
    </li>

    <li>
      <a href="#_generateArea">generateArea</a>
    </li>

    <li>
      <a href="#_clearCanvas">clearCanvas</a>
    </li>

    <li>
      <a href="#_reRender">reRender</a>
    </li>

    <li>
      <a href="#_render">render</a>
    </li>

    <li>
      <a href="#_resize">resize</a>
    </li>

    <li>
      <a href="#_on">on</a>
    </li>

    <li>
      <a href="#_animate">animate</a>
    </li>

  </ul>
  <hr />

  

  <table class="table">
  

  
  </table>
  
  
  <h3 id="_Stream">
    Stream
  </h3>
  

  <p>Stream构造函数<br />Create stream in a dom node with id "chart", width is 500; height is 600px;</p>

<h2>Options</h2>

<ul>
<li><code>width</code> 宽度，默认为节点宽度</li>
</ul>

<h2>Examples</h2>

<div class="highlight"><pre lang="">var stream = new Stream("chart", {"width": 500, "height": 600});
</pre></div>

  <table class="table">
  
    <tr>
      <td>声明</td>
      <td>Stream</td> 
      <td></td>
      <td>Stream</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>node(Mix)</td>
      <td colspan="2">The dom node or dom node Id</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>options(Object)</td>
      <td colspan="2">options json object for determin stream style.</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>var Stream = DataV.extend(DataV.Chart, {
        initialize: function (node, options) {
            this.type = &quot;Stream&quot;;
            this.node = this.checkContainer(node);

            this.level = 0;

            this.defaults = {};
            // Properties
            this.defaults.offset = &quot;zero&quot;;//&quot;expand&quot;;
            this.defaults.order = &quot;default&quot;;
            this.defaults.columnNameUsed = &quot;auto&quot;;
            this.defaults.rowNameUsed = &quot;auto&quot;;
            this.defaults.topInterval = 0;
            this.defaults.bottomInterval = 0;
            this.defaults.legend = true;
            this.defaults.axis = true;
            this.defaults.pathLabel = true;
            this.defaults.fontSize = 12;
            this.defaults.heightWidthRatio = 0.618;
            //this.defaults.axisTickNumber = 8; // axis ticks number
    
            this.defaults.indexMargin = 3; // if dates.length &lt; indexMargin * 2 + 1, do not show label
    
            this.userConfig = {&quot;more&quot;: true, &quot;max&quot;: 20, &quot;other&quot;: 0.1};

            this.timeRange = [];
            // Canvas
            this.defaults.width = 750;
            this.defaults.height = 360;
            this.defaults.totalWidth = 820;
            this.defaults.naviBackWidth = 80;
            this.defaults.legendHeight = 50;
            this.defaults.legendWidth = 150;
            this.defaults.legendIndent = 21;
            this.defaults.axisHeight = 30;
            this.defaults.margin = [0, 40, 0, 40];

            this.defaults.customEventHandle = {&quot;mousemove&quot;: null};

            //test related
            this.defaults.testMakeup = false;
            this.defaults.testDays = 30;
            this.defaults.testDataType = 0; //0: random; 1: false random; 2: same; &gt;2: small change;
    
            this.setOptions(options);
            this.createCanvas();
        }
    });</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_createCanvas">
    createCanvas
  </h3>
  

  <p>创建画布</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.createCanvas()</td> 
      <td></td>
      <td>createCanvas</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.createCanvas = function () {
        var conf = this.defaults,
            canvasFatherContainer = document.createElement(&quot;div&quot;),
            coverStyle,
            naviStyle,
            naviTraceStyle,
            naviBackStyle,
            percentageStyle,
            axisStyle,
            brushStyle,
            getBack;

        this.node.style.position = &quot;relative&quot;;
        this.node.style.width = conf.totalWidth + &quot;px&quot;;

        this.legend = document.createElement(&quot;div&quot;);
        //this.legendPaper = new Raphael(this.legend, conf.legendWidth - conf.legendIndent, 500);
        $(this.legend).css({&quot;overflow&quot;: &quot;hidden&quot;,
                            &quot;width&quot;: conf.legendWidth - conf.legendIndent + &quot;px&quot;,
                            &quot;padding&quot;: &quot;10px 0 10px 0&quot;
                            });

        this.navi = document.createElement(&quot;div&quot;);
        $(this.navi).css({
            //&quot;width&quot;: conf.totalWidth + &quot;px&quot;,
            &quot;border-top&quot;: &quot;1px solid #ddd&quot;,
            &quot;border-bottom&quot;: &quot;1px solid #ddd&quot;,
            //&quot;height&quot;: &quot;22px&quot;,
            &quot;padding-top&quot;: &quot;5px&quot;,
            &quot;padding-bottom&quot;: &quot;10px&quot;,
            &quot;padding-left&quot;: &quot;10px&quot;,
            &quot;padding-right&quot;: &quot;10px&quot;,
            &quot;font&quot;: (conf.fontSize + 1) + &quot;px 宋体&quot;
        });
        this.naviTrace = document.createElement(&quot;div&quot;);
        $(this.naviTrace).css({
            &quot;width&quot;: conf.totalWidth - conf.naviBackWidth - 50 + &quot;px&quot;,
            &quot;margin-top&quot;: &quot;5px&quot;
        });

        this.naviBack = document.createElement(&quot;div&quot;);
        this.naviBack.innerHTML = &quot;返回上层&quot;;
        $(this.naviBack).css({
            &quot;width&quot;: conf.naviBackWidth + &quot;px&quot;,
            &quot;float&quot;: &quot;right&quot;,
            &quot;background-color&quot;: &quot;#f4f4f4&quot;,
            &quot;padding-top&quot;: &quot;4px&quot;,
            &quot;padding-bottom&quot;: &quot;4px&quot;,
            &quot;border&quot;: &quot;1px solid #ddd&quot;,
            &quot;border-radius&quot;: &quot;2px&quot;,
            &quot;cursor&quot;: &quot;pointer&quot;,
            &quot;text-align&quot;: &quot;center&quot;,
            &quot;visibility&quot;: &quot;hidden&quot;
        });
        //naviBackStyle.float = &quot;right&quot;;
        //naviBackStyle.visibility = &quot;hidden&quot;;
        this.navi.appendChild(this.naviBack);
        this.navi.appendChild(this.naviTrace);

        this.percentage = document.createElement(&quot;div&quot;);
        if (this.userConfig.more) {
            this.percentagePaper = new Raphael(this.percentage, conf.margin[3], conf.height);
        }
        percentageStyle = this.percentage.style;
        percentageStyle.width = conf.margin[3] + &quot;px&quot;;
        percentageStyle.height = conf.height + &quot;px&quot;;
        $(this.percentage).css({
            &quot;float&quot;: &quot;left&quot;,
            &quot;margin-bottom&quot;: &quot;0px&quot;,
            &quot;border-bottom&quot;: &quot;0px&quot;,
            &quot;padding-bottom&quot;: &quot;0px&quot;
        });

        this.canvasContainer = document.createElement(&quot;div&quot;);
        $(this.canvasContainer).css({
            &quot;float&quot;: &quot;left&quot;,
            &quot;width&quot;: conf.width + &quot;px&quot;,
            &quot;margin-bottom&quot;: &quot;0px&quot;,
            &quot;border-bottom&quot;: &quot;0px&quot;,
            &quot;padding-bottom&quot;: &quot;0px&quot;
        })
            .append($(canvasFatherContainer).css({&quot;position&quot;: &quot;relative&quot;}));
        this.canvas = new Raphael(canvasFatherContainer, conf.width, conf.height);
        $(this.canvasContainer).height(conf.height);

        this.floatTag = DataV.FloatTag()(canvasFatherContainer);
        this.floatTag.css({&quot;visibility&quot;: &quot;hidden&quot;});

        // cover can block stream canvas when animating to prevent some default mouse event
        this.cover = document.createElement(&quot;div&quot;);
        coverStyle = this.cover.style;
        coverStyle.position = &quot;absolute&quot;;
        coverStyle.width = conf.width + &quot;px&quot;;
        coverStyle.height = conf.height + &quot;px&quot;;
        coverStyle.zIndex = 100;
        coverStyle.visibility = &quot;hidden&quot;;
        $(this.cover).bind(&quot;mousemove&quot;, {stream: this}, function (e) {
            var stream = e.data.stream;
            stream.coverMouse = {x: e.pageX, y: e.pageY};
        });
        $(this.cover).bind(&quot;mouseleave&quot;, {stream: this}, function (e) {
            var stream = e.data.stream;
            stream.coverMouse = undefined;
        });

        this.axis = document.createElement(&quot;div&quot;);
        this.axisPaper = new Raphael(this.axis, conf.totalWidth - conf.legendWidth, conf.axisHeight);
        //axisStyle = this.axis.style;
        $(this.axis).css({
            &quot;margin-top&quot;: &quot;0px&quot;,
            &quot;border-top&quot;: &quot;1px solid #ddd&quot;,
            &quot;height&quot;: conf.axisHeight + &quot;px&quot;
        });

        this.leftContainer = document.createElement(&quot;div&quot;);
        this.rightContainer = document.createElement(&quot;div&quot;);

        this.leftContainer.appendChild(this.legend);

        this.rightContainer.appendChild(this.navi);
        this.middleContainer = document.createElement(&quot;div&quot;);
        $(this.middleContainer).css(&quot;height&quot;, conf.height);
        this.middleContainer.appendChild(this.percentage);
        this.middleContainer.appendChild(this.canvasContainer);
        this.middleContainer.appendChild(this.cover);
        $(this.canvasFatherContainer).append(this.floatTag);
        this.rightContainer.appendChild(this.middleContainer);
        this.rightContainer.appendChild(this.axis);

        this.node.appendChild(this.rightContainer);
        this.node.appendChild(this.leftContainer);
        $(this.rightContainer).css({&quot;float&quot;: &quot;right&quot;,
                                    //&quot;border&quot;: &quot;solid 1px&quot;,
                                    &quot;width&quot;: conf.totalWidth - conf.legendWidth
                                    });
        $(this.leftContainer).css({ &quot;width&quot;: conf.legendWidth - 4 + &quot;px&quot;,
                                    //&quot;float&quot;: &quot;left&quot;,
                                    //&quot;border&quot;: &quot;solid 1px&quot;,
                                    //&quot;margin-left&quot;: &quot;-5px&quot;,
                                    //&quot;height&quot;: 300,
                                    //&quot;max-height&quot;: 300,
                                    //&quot;overflow-y&quot;: &quot;scroll&quot;,
                                    &quot;overflow-x&quot;: &quot;hidden&quot;
                                    });

        getBack = function (stream) {
            stream.cover.style.visibility = &quot;visible&quot;;
            stream.coverMouse = undefined;
            stream.getLevelSource();
            stream.reRender();

            //hidden
            stream.indicatorLine.attr({&quot;stroke&quot;: &quot;none&quot;});
            stream.highlightLine.attr({&quot;stroke&quot;: &quot;none&quot;});
            stream.floatTag.css({&quot;visibility&quot; : &quot;hidden&quot;});

            stream.paths.forEach(function (d, i, array) {
                d.attr({transform: &quot;s1,0.001,0,0&quot;});
                d.label.hide();
                d.animate({transform: &quot;t0,0&quot;}, 750, &quot;linear&quot;, function () {
                    stream.cover.style.visibility = &quot;hidden&quot;;
                    if (typeof stream.coverMouse !== 'undefined') {
                        stream.indicatorLine.attr({&quot;stroke&quot;: &quot;#000&quot;});
                        stream.highlightLine.attr({&quot;stroke&quot;: &quot;white&quot;});
                        stream.floatTag.css({&quot;visibility&quot; : &quot;visible&quot;});
                        $(stream.canvas.canvas).trigger(&quot;mousemove&quot;,
                            [stream.coverMouse.x, stream.coverMouse.y]);
                        stream.coverMouse = undefined;
                    }
                    if (d.labelLoc.showLabel) {
                        d.label.show();
                    }
                });
            });
        };
        $(this.naviTrace).on(&quot;click&quot;, &quot;.navi&quot;, {stream: this}, function (e) {
            var stream = e.data.stream;
            stream.level = e.target.data.level;
            getBack(stream);
        });

        $(this.naviBack).on(&quot;click&quot;, {stream: this}, function (e) {
            var stream = e.data.stream;
            stream.level -= 1;
            getBack(stream);
        });
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setOptions">
    setOptions
  </h3>
  

  <p>设置自定义选项</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.setOptions()</td> 
      <td></td>
      <td>setOptions</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.setOptions = function (options) {
        _.extend(this.defaults, options);

        if (options &amp;&amp; options.width) {
            this.defaults.totalWidth = this.defaults.width;
            this.defaults.width = this.defaults.totalWidth - this.defaults.margin[1]
                - this.defaults.margin[3] - this.defaults.legendWidth;
            if (!options.height) {
                this.defaults.autoHeight = true;
                this.defaults.height = this.defaults.width * this.defaults.heightWidthRatio;
            } else {
                this.defaults.autoHeight = false;
            }
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_hasRowName">
    hasRowName
  </h3>
  

  <p>检测行名</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.hasRowName()</td> 
      <td></td>
      <td>hasRowName</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.hasRowName = function () {
        var i,
            l,
            firstColumn = [],
            source = this.rawData;

        if ((typeof this.defaults.rowNameUsed) === &quot;boolean&quot;) {
            return this.defaults.rowNameUsed;
        }
        //first column from 2nd row
        for (i = 1, l = source.length; i &lt; l; i++) {
            firstColumn[i] = source[i][0];
        }
        return !firstColumn.every(DataV.isNumeric);
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_hasColumnName">
    hasColumnName
  </h3>
  

  <p>检测列名</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.hasColumnName()</td> 
      <td></td>
      <td>hasColumnName</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.hasColumnName = function () {
        var firstRow;
        if ((typeof this.defaults.columnNameUsed) === &quot;boolean&quot;) {
            return this.defaults.columnNameUsed;
        }
        //first row from 2nd column
        firstRow = this.rawData[0].slice(1);
        return !firstRow.every(DataV.isNumeric);
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_sort">
    sort
  </h3>
  

  <p>排序</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.sort()</td> 
      <td></td>
      <td>sort</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>source(Array)</td>
      <td colspan="2">待排序的二维数组</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.sort = function (source) {
        var i, j, l, ll;
        var rowSum = [];
        var columnSum = [];
        var newSource = [];
        var rowName = [];
        var that = this;

        for (j = 0, ll = source[0].length; j &lt; ll; j++) {
            columnSum[j] = 0;
        }

        for (i = 0, l = source.length; i &lt; l; i++) {
            rowSum[i] = 0;
            for (j = 0, ll = source[0].length; j &lt; ll; j++) {
                rowSum[i] += source[i][j];
                columnSum[j] += source[i][j];
            }
            rowSum[i] = [rowSum[i]];
            rowSum[i].index = i;
        }

        rowSum.sort(function (a, b) {
            return b[0] - a[0];
        });

        rowSum.forEach(function (d, i) {
            newSource[i] = source[d.index];
			if (that.rowName) {
                rowName[i] = that.rowName[d.index];
			}
        });

        for (i = 0, l = rowSum.length; i &lt; l; i++) {
            rowSum[i] = rowSum[i][0];
        }

        //this.mergeOthe

		this.rowName = rowName;
        this.rowSum = rowSum;
        this.columnSum = columnSum;
        this.total = d3.sum(this.rowSum);

        return newSource;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_getDigitData">
    getDigitData
  </h3>
  

  <p>获取数据</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.getDigitData()</td> 
      <td></td>
      <td>getDigitData</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>source(Array)</td>
      <td colspan="2">从二维数组中，获取纯数据的部分（排除掉列名后）</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.getDigitData = function (source) {
		//get first column name, row name and digitData;
        var conf = this.defaults,
            firstRow = source[0],
            firstColumn,
            digitData;

        var i, j, l, ll;

        firstColumn = source.map(function (d) {
            return d[0];
        });

        if (this.hasRowName()) {
            if (this.hasColumnName()) {
                //row names, column names
                this.rowName = firstColumn.slice(1);
                this.columnName = firstRow.slice(1);
                digitData = source.map(function (d) {
                    return d.slice(1);
                }).slice(1);
            } else {
                //row names, no column names
                this.rowName = firstColumn;
                this.columnName = undefined;
                digitData = source.map(function (d) {
                    return d.slice(1);
                });
            }
        } else {
            if (this.hasColumnName()) {
                //no row names, column names
                this.rowName = undefined;
                this.columnName = firstRow;
                digitData = source.slice(1);
            } else {
                //no row names, no column names
                if (conf.columnNameUsed === &quot;auto&quot; &amp;&amp; conf.rowNameUsed === &quot;auto&quot; &amp;&amp; !DataV.isNumeric(source[0][0])) {
                    throw new Error(&quot;Please specify whether there are column names or row names&quot;);
                }
                this.rowName = undefined;
                this.columnName = undefined;
                digitData = source;
            }
        }
        for (i = 0, l = digitData.length; i &lt; l; i++) {
            for (j = 0, ll = digitData[0].length; j &lt; ll; j++) {
                digitData[i][j] = parseFloat(digitData[i][j]);
            }
        }
		return digitData;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_getInfo">
    getInfo
  </h3>
  

  <p>获取信息数据</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.getInfo()</td> 
      <td></td>
      <td>getInfo</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.getInfo = function () {
		var allInfos = [];
		var i, j, l, ll;
		var infos, info;
        var column;
        var digitData = this.digitData;
        var descending = function (a, b) {
                return b.value - a.value;
            };
		for (i = 0, l = this.digitData.length; i &lt; l; i++) {
			infos = allInfos[i] = [];
			infos.ratio = this.rowSum[i] / this.total;
			infos.value = this.rowSum[i];
			infos.name = this.rowName[i];
			infos.id = i;
		}
        for (i = 0, l = digitData.length; i &lt; l; i++) {
            column = [];
            for (j = 0, ll = digitData[0].length; j &lt; ll; j++) {
                allInfos[i][j] = column[j] = {
                    &quot;date&quot;: this.columnName[j],
                    &quot;id&quot;: i,
                    &quot;name&quot;: allInfos[i].name,
                    &quot;tip&quot;: &quot;&lt;b&gt;&quot; + allInfos[i].name + &quot;&lt;/b&gt;&lt;br/&gt;占比:&quot;
                        + (Math.round(digitData[i][j] / this.columnSum[j] * 10000) / 100) + &quot;%&lt;br/&gt;&quot;,
                    &quot;total&quot;: allInfos[i].ratio,
                    //&quot;value&quot;: columnTotal[i]
                    &quot;value&quot; : digitData[i][j],
                    &quot;index&quot; : j,
                    &quot;rowInfo&quot; : allInfos[i],
                    &quot;ratio&quot; : digitData[i][j] / this.columnSum[j]
                };
            }

            column.sort(descending);

            for (j = 0, ll = column.length; j &lt; ll; j++) {
                column[j].rank = j;
            }
        }
        return allInfos;
	};</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setSource">
    setSource
  </h3>
  

  <p>设置数据源</p>

<h2>Examples</h2>

<p>例如下面的数组表示2个人在一年4个季度的消费。第一个人在4个季度里消费了1、2、3、9元。第二个人消费了3、4、6、3元。</p>

<div class="highlight"><pre lang="">[
 [1,2,3,9],
 [3,4,6,3]
]
</pre></div>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.setSource()</td> 
      <td></td>
      <td>setSource</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>source(Array)</td>
      <td colspan="2">二维数组的数据源</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.setSource = function (source) {
        this.rawData = source;
		this.digitData = this.getDigitData(this.rawData);

        //get date, sort and allInfos;
        //date
        this.date = source[0].slice(1, source[0].length);
        this.timeRange = [0, this.date.length - 1];
        //sort
        this.digitData = this.sort(this.digitData);
		this.allInfos = this.getInfo(this.digitData);

        this.level = 0;
        this.getLevelSource();
        //this.source = this.remapSource(digitData);
        this.canAnimate = false;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setTimeRange">
    setTimeRange
  </h3>
  

  <p>If useString is true, start and end are date string, else start and end are index number</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.setTimeRange()</td> 
      <td></td>
      <td>setTimeRange</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>start(Number,String)</td>
      <td colspan="2">起始范围</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>end(Number,String)</td>
      <td colspan="2">结束范围</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>useString(Boolean)</td>
      <td colspan="2">是否是字符串</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.setTimeRange = function (start, end, useString) {
        var idx1, idx2;
        if (useString) {
            idx1 = _.indexOf(this.date, start);
            idx2 = _.indexOf(this.date, end);
        } else {
            idx1 = start;
            idx2 = end;
        }

        var min = Math.min(idx1, idx2);
        var max = Math.max(idx1, idx2);
        if (min === max) {
            throw new Error(&quot;start index and end index can not be same.&quot;);
        }
        if (min &lt; 0 || max &gt; this.date.length - 1) {
            throw new Error(&quot;start index or end index is beyond the time range.&quot;);
        }

        this.timeRange = [min, max];
        this.getLevelSource();
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_layout">
    layout
  </h3>
  

  <p>生成布局</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.layout()</td> 
      <td></td>
      <td>layout</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.layout = function () {
        var conf = this.defaults;
        d3.layout.stack().offset(conf.offset).order(conf.order)(this.source);
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_getColor">
    getColor
  </h3>
  

  <p>根据选择方案获取颜色数据</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.getColor()</td> 
      <td></td>
      <td>getColor</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>colorJson(Object)</td>
      <td colspan="2">颜色方案</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>Array</td>
      <td colspan="2">返回颜色数据</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.getColor = function (colorJson) {
        var colorMatrix = DataV.getColor();
        var color;
        var colorStyle = colorJson || {};
        var colorMode = colorStyle.mode || 'default';
        var i, l;

        switch (colorMode) {
        case &quot;gradient&quot;:
            l = this.source.length;
            var colorL = Math.round(l / 5);
            if (colorL &gt; colorMatrix.length - 1) {
                colorL = colorMatrix.length - 1;
            }
            var testColor = [colorMatrix[0][0], colorMatrix[colorL][0]];
            var test1 = DataV.gradientColor(testColor, &quot;special&quot;);
            var testColorMatrix = [];
            var testColorMatrix1 = [];
            for (i = 0; i &lt; l; i++) {
                testColorMatrix.push([test1(i / (l - 1)), test1(i / (l - 1))]);
            }

            for (i = (l - 1); i &gt;= 0; i--) {
                testColorMatrix1.push(testColorMatrix[i]);
            }

            colorMatrix = testColorMatrix;
            
            break;
        case &quot;random&quot;:
        case &quot;default&quot;:
            break;
        }

        var ratio = colorStyle.ratio || 0;
        if (ratio &lt; 0) { ratio = 0; }
        if (ratio &gt; 1) { ratio = 1; }
        var colorArray = [];
        for (i = 0, l = colorMatrix.length; i &lt; l; i++) {
            var colorFunc = d3.interpolateRgb.apply(null, [colorMatrix[i][0], colorMatrix[i][1]]);
            colorArray.push(colorFunc(ratio));
        }
        color = d3.scale.ordinal().range(colorArray);

        return color;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_generatePaths">
    generatePaths
  </h3>
  

  <p>生成路径</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.generatePaths()</td> 
      <td></td>
      <td>generatePaths</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.generatePaths = function () {
        this.createNavi();
        this.createPercentage();
        this.createAxis();
        this.createStreamPaths();
        this.createLegend();
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_createLegend">
    createLegend
  </h3>
  

  <p>创建图例</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.createLegend()</td> 
      <td></td>
      <td>createLegend</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.createLegend = function () {
        var conf = this.defaults,
            //paper = this.legendPaper,
            legends = [],
            m = [10, 20, 10, 20],
            left = m[3],
            top = m[0],
            lineHeight = 25,
            legendInterval = 10,
            width = conf.legendWidth - conf.legendIndent,
            r0 = 5,
            r1 = 7,
            circleW = 18,
            x,
            y,
            circle,
            text,
            box,
            ul,
            li,
            color = this.getColor({mode: conf.colorMode}),
            i,
            l,
            leftHeight,
            legendHeight,
            legendTopMargin,
            hoverIn = function (e) {
                var index = e.data.index;
                var stream = e.data.stream;
                var path = stream.paths[index];
                //stream.legends[stream.preIndex]
                stream.preIndex = index;
                stream.legends[index].css({&quot;background&quot;: &quot;#dddddd&quot;});
                path.attr({&quot;opacity&quot;: 0.5});
            },
            hoverOut = function (e) {
                var index = e.data.index;
                var stream = e.data.stream;
                var path = stream.paths[index];
                stream.preIndex = index;
                stream.legends[index].css({&quot;background&quot;: &quot;white&quot;});
                path.attr({&quot;opacity&quot;: 1.0});
            };

        ul = $(&quot;&lt;ul/&gt;&quot;);
        ul.css({
            &quot;margin&quot;: &quot;0px 0px 0px 10px&quot;,
            &quot;padding-left&quot;: &quot;0px&quot;
        });
        $(this.legend).append(ul);

        for (i = 0, l = this.infos.length; i &lt; l; i++) {
            li = $(&quot;&lt;li&gt;&quot; + &quot;&lt;span style=\&quot;color: black\&quot;&gt;&quot; + this.infos[i][0].name + &quot;&lt;/span&gt;&quot; + &quot;&lt;/li&gt;&quot;);
            li.css({&quot;list-style-type&quot;: &quot;square&quot;,
                    &quot;list-style-position&quot;: &quot;inside&quot;,
                    //&quot;background&quot;: &quot;gray&quot;,
                    &quot;color&quot;: color(i),
                    //&quot;display&quot;: &quot;inline&quot;,
                    &quot;white-space&quot;: &quot;nowrap&quot;,
                    &quot;padding-left&quot;: 5
                    });
            ul.append(li);
            li.mouseenter({&quot;index&quot;: i, &quot;stream&quot;: this}, hoverIn);
            li.mouseleave({&quot;index&quot;: i, &quot;stream&quot;: this}, hoverOut);
            legends.push(li);
        }
        this.legends = legends;
        //paper.setSize(width, top + lineHeight + m[2]);

        //height and margin
        leftHeight = $(this.rightContainer).height();
        legendHeight = $(this.legend).height();
        $(this.leftContainer).css({
            &quot;height&quot;: leftHeight
        });
        if (leftHeight &gt; legendHeight) {
            $(this.legend).css({&quot;margin-top&quot;: leftHeight - legendHeight - 30});
        } else {
            $(this.legend).css({&quot;margin-top&quot;: 0});
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_createNavi">
    createNavi
  </h3>
  

  <p>创建导航</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.createNavi()</td> 
      <td></td>
      <td>createNavi</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.createNavi = function () {
        if (!this.userConfig.more) {
            $(this.navi).css({
                &quot;visibility&quot;: &quot;hidden&quot;,
                &quot;position&quot;: &quot;absolute&quot;
            });
        } else {
            $(this.navi).css({&quot;visibility&quot;: &quot;visible&quot;,
                &quot;position&quot;: &quot;relative&quot;
            });
        }
        var i,
            span;
        $(this.naviTrace).empty();
        for (i = 0; i &lt;= this.level; i++) {
            $(this.naviTrace).append($(&quot;&lt;span&gt; &gt; &lt;/span&gt;&quot;));
            span = document.createElement(&quot;span&quot;);
            span.data = {level: i};
            span = $(span)
                .html(i === 0 ? &quot;第1层&quot; : &quot;第&quot; + (i + 1) + &quot;层&quot;)
                .appendTo($(this.naviTrace));
            if (i !== this.level) {
                span.css({&quot;cursor&quot;: &quot;pointer&quot;, &quot;color&quot;: &quot;#1E90FF&quot;})
                    .addClass(&quot;navi&quot;);
                    //.data(&quot;level&quot;, i);
            }
        }
        if (this.level &gt; 0) {
            this.naviBack.style.visibility = &quot;visible&quot;;
        } else {
            this.naviBack.style.visibility = &quot;hidden&quot;;
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_getMaxPercentage">
    getMaxPercentage
  </h3>
  

  <p>获取最大百分比</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.getMaxPercentage()</td> 
      <td></td>
      <td>getMaxPercentage</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.getMaxPercentage = function () {
        this.maxPercentage = this.allInfos.reduce(function (a, b, i, array) {
            return [{total: a[0].total + b[0].total}];
        })[0].total;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_createPercentage">
    createPercentage
  </h3>
  

  <p>生成百分比数据</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.createPercentage()</td> 
      <td></td>
      <td>createPercentage</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.createPercentage = function () {
        if (!this.userConfig.more) {
            return;
        }
        var conf = this.defaults;
        var maxY = this.getMaxY(),
            y;
        if (this.firstRender) {
            this.getMaxPercentage();
        }

        maxY /= this.maxPercentage;
        y = maxY &gt; 0.1
            ? (1 - maxY) * conf.height + conf.fontSize * 2 / 3
            : (1 - maxY) * conf.height - conf.fontSize * 2 / 3;

        if (this.firstRender) {
            this.percentageRect = this.percentagePaper.rect(0, (1 - maxY) * conf.height,
                    conf.margin[3], maxY * conf.height)
                .attr({&quot;fill&quot;: &quot;#f4f4f4&quot;, &quot;stroke&quot;: &quot;#aaa&quot;, &quot;stroke-width&quot;: 0.5});
            this.percentageText = this.percentagePaper.text(conf.margin[3] / 2, y,
                    Math.round(maxY * 100) + &quot;%&quot;)
                .attr({&quot;text-anchor&quot;: &quot;middle&quot;});
        } else {
            this.percentageRect.animate({&quot;y&quot;: (1 - maxY) * conf.height, &quot;height&quot;: maxY * conf.height}, 750);
            this.percentageText.attr({&quot;text&quot;: Math.round(maxY * 100) + &quot;%&quot;})
                .animate({&quot;y&quot;: y}, 750);
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_createStreamPaths">
    createStreamPaths
  </h3>
  

  <p>生成Stream路径</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.createStreamPaths()</td> 
      <td></td>
      <td>createStreamPaths</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.createStreamPaths = function () {
        var canvas = this.canvas,
            paths = [],
            labels = [],
            area = this.generateArea(),
            color = this.getColor({mode: this.defaults.colorMode}),
            conf = this.defaults,
            i,
            l,
            _area,
            pathLegend,
            path,
            pathLegendMouseOver = function () {
                var path = this.path,
                    anchorIndex = path.index;
                path.paths.forEach(function (d, i, array) {
                    if (i !== anchorIndex) {
                        array[i].attr({&quot;fill&quot;: d3.interpolateRgb.apply(null, [array[i].color, &quot;#fff&quot;])(0.5)});
                    }
                });
				this.style.backgroundColor = d3.interpolateRgb.apply(null, [path.color, &quot;#fff&quot;])(0.8);
            },
            
            pathLegendMouseOut = function () {
                var path = this.path,
                    anchorIndex = path.index;
                path.paths.forEach(function (d, i, array) {
                    if (i !== anchorIndex) {
                        array[i].attr({&quot;fill&quot;: array[i].color});
                    }
                });
				path.legend.style.backgroundColor = path.color;
            },

            getLabelLocation = function (locArray, el) {
                var x = 0,
                    y = 0,
                    i;
                var ratioMargin = 0.15;
                var index = 0;
                var max = 0;
                var box = el.getBBox();
                var xInterval;
                var minTop, maxBottom;
                var showLabel = true;
                var loc;
                var height;

                xInterval = Math.ceil(box.width / (locArray[1].x - locArray[0].x) / 2);
                if (xInterval === 0) {
                    xInterval = 1;
                }

                locArray.forEach(function (d, i, array) {
                    var m = Math.max(ratioMargin * array.length, xInterval);
                    if (i &gt;= m &amp;&amp; i &lt;= array.length - m) {
                        if (d.y &gt; max) {
                            minTop = d.y0 - d.y;
                            maxBottom = d.y0;
                            max = d.y;
                            index = i;
                        }
                    }
                });
                for (i = index - xInterval; i &lt;= index + xInterval; i++) {
                    if (i &lt; 0 || i &gt;= locArray.length) {
                        height = 0;
                        showLabel = false;
                        break;
                        //return;
                    }
                    loc = locArray[i];
                    //top's y is small
                    if (loc.y0 - loc.y &gt; minTop) {
                        minTop = loc.y0 - loc.y;
                    }
                    if (loc.y0 &lt; maxBottom) {
                        maxBottom = loc.y0;
                    }
                }

                if (showLabel &amp;&amp; maxBottom - minTop &gt;= box.height * 0.8) {
                    x = locArray[index].x;
                    y = (minTop + maxBottom) / 2;
                    //y = locArray[index].y0 - locArray[index].y / 2;
                } else {
                    showLabel = false;
                }

                return {x: x,
                        y: y,
                        showLabel: showLabel};
            },

            getLabelLocation_old2 = function (locArray, conf) {
                var x, y, height = 0, i;
                var indexMargin = Math.min(conf.indexMargin, Math.floor((locArray.length - 1) / 2));
                var ratioMargin = 0.15;
                var index = indexMargin;
                var max = 0;
                if (locArray.length &gt;= conf.indexMargin * 2 + 1) {
                    locArray.forEach(function (d, i, array) {
                        var m = Math.max(indexMargin, ratioMargin * array.length);
                        if (i &gt;= m &amp;&amp; i &lt;= array.length - m) {
                            if (d.y &gt; max) {
                                max = d.y;
                                index = i;
                            }
                        }
                    });
                    x = locArray[index].x;
                    y = locArray[index].y0 - locArray[index].y / 2;
                    for (i = index - indexMargin; i &lt;= index + indexMargin; i++) {
                        height += locArray[i].y;
                    }
                    height = height / (2 * indexMargin + 1);
                } else {
                    x = -100;
                    y = -100;
                    height = 0;
                }

                return {
                    x: x,
                    y: y,
                    height: height
                };
            };

        canvas.rect(0, 0, conf.width, conf.height)
            .attr({&quot;stroke&quot;: &quot;none&quot;,
                    &quot;fill&quot;: &quot;#e0e0e0&quot;});
        for (i = 0, l = this.source.length; i &lt; l; i++) {
            _area = area(this.pathSource[i]);
            path = canvas.path(_area).attr({fill: color(i),
                    stroke: color(i),
                    &quot;stroke-width&quot;: 1,
                    &quot;stroke-linejoin&quot;: &quot;round&quot;,
                    &quot;transform&quot;:  &quot;t0,&quot; + conf.topInterval
                    });
            path.color = color(i);
            path.index = i;
            path.info = this.infos[i];

            path.paths = paths;
            path.topTrans = conf.topInterval;
            path.bottomTrans = conf.bottomInterval;
            path.stream = this;

            path.node.streamPath = path;
            path.node.setAttribute(&quot;class&quot;, &quot;streamPath rvml&quot;);

            //path.click(pathClick);
            //path.mouseover(pathMouseOver);
            //path.mouseout(pathMouseOut);
            //path.mousemove(pathMouseMove);

            paths[path.index] = path;
            //brush canvas background
        }

        //label
        for (i = 0, l = paths.length; i &lt; l; i++) {
            path = paths[i];
            path.label = this.canvas.text(0, 0,
                    conf.pathLabel ?
                    path.info[0].name + &quot; &quot; + (Math.round(path.info[0].total * 10000) / 100) + &quot;%&quot; : &quot;&quot;)
                .attr({&quot;text-anchor&quot;: &quot;middle&quot;,
                        &quot;fill&quot;: &quot;white&quot;,
                        &quot;font-size&quot;: conf.fontSize,
                        &quot;font-family&quot;: &quot;微软雅黑&quot;});
            path.labelLoc = getLabelLocation(this.pathSource[i], path.label);

            if (path.labelLoc.showLabel) {
                path.label.attr({&quot;x&quot;: path.labelLoc.x,
                                &quot;y&quot;: path.labelLoc.y});
            } else {
                path.label.attr({&quot;opacity&quot;: 0});
                //path.labelOpacity = 1;
            }
            if (i === 0 &amp;&amp; path.info[0].id === -1) {
                path.attr({&quot;cursor&quot;: &quot;pointer&quot;});
                path.label.attr({&quot;cursor&quot;: &quot;pointer&quot;});
            }
            labels.push(path.label);
            path.label.node.setAttribute(&quot;class&quot;, &quot;streamPath rvml&quot;);
        }

        $(this.canvas.canvas).unbind();

        var mouseenter = function (e) {
                var stream = e.data.stream;
                stream.indicatorLine.attr({&quot;stroke&quot;: &quot;#000&quot;});
                stream.highlightLine.attr({&quot;stroke&quot;: &quot;white&quot;});
                stream.floatTag.css({&quot;visibility&quot; : &quot;visible&quot;});
                stream.axisPopText.show();
                stream.axisPopBubble.show();
            };

        var mouseleave = function (e) {
                var stream = e.data.stream,
                    circle;
                stream.indicatorLine.attr({&quot;stroke&quot;: &quot;none&quot;});
                stream.highlightLine.attr({&quot;stroke&quot;: &quot;none&quot;});
                stream.floatTag.css({&quot;visibility&quot; : &quot;hidden&quot;});
                stream.axisPopText.hide();
                stream.axisPopBubble.hide();
                //recover prepath;
                if (typeof stream.prePath !== 'undefined') {
                    stream.prePath.attr({&quot;opacity&quot;: 1, &quot;stroke-width&quot;: 1});
                    // set legend
                    //circle = stream.legends[stream.prePath.index].circle;
                    //circle.attr({&quot;r&quot;: circle.data(&quot;r0&quot;), &quot;opacity&quot;: 1});
                    stream.legends[stream.prePath.index].css({&quot;background&quot;: &quot;white&quot;});
                    stream.prePath = undefined;
                }
            };

        var click = function (e) {
                var stream = e.data.stream,
                    position;
                if (typeof stream.prePath !== 'undefined'
                        &amp;&amp; stream.prePath.info[0].id === -1) {
    
                    //hidden
                    stream.indicatorLine.attr({&quot;stroke&quot;: &quot;none&quot;});
                    stream.highlightLine.attr({&quot;stroke&quot;: &quot;none&quot;});
                    stream.floatTag.css({&quot;visibility&quot; : &quot;hidden&quot;});

                    stream.level += 1;

                    //set cover
                    position = $(this).parent().position();
                    $(stream.cover).css({left: position.left + &quot;px&quot;,
                                        top: position.top + &quot;px&quot;});
                    stream.cover.style.visibility = &quot;visible&quot;;
                    stream.coverMouse = {x: e.pageX, y: e.pageY};

                    //redraw
                    stream.getLevelSource();
                    stream.reRender();

                    //hidden
                    stream.indicatorLine.attr({&quot;stroke&quot;: &quot;none&quot;});
                    stream.highlightLine.attr({&quot;stroke&quot;: &quot;none&quot;});
                    stream.floatTag.css({&quot;visibility&quot; : &quot;hidden&quot;});

                    stream.paths.forEach(function (d, i, array) {
                        d.attr({transform: &quot;s1,0.001,0,&quot; + stream.defaults.height});
                        d.label.hide();
                        d.animate({transform: &quot;t0,0&quot;}, 750, &quot;linear&quot;, function () {
                            stream.cover.style.visibility = &quot;hidden&quot;;
                            if (typeof stream.coverMouse !== 'undefined') {
                                stream.indicatorLine.attr({&quot;stroke&quot;: &quot;#000&quot;});
                                stream.highlightLine.attr({&quot;stroke&quot;: &quot;white&quot;});
                                stream.floatTag.css({&quot;visibility&quot; : &quot;visible&quot;});
                                $(stream.canvas.canvas).trigger(&quot;mousemove&quot;,
                                    [stream.coverMouse.x, stream.coverMouse.y]);
                                stream.coverMouse = undefined;
                            }
                            //if (d.labelOpacity === 1)
                            if (d.labelLoc.showLabel) {
                                d.label.show();
                            }
                        });
                    });
                }
            };

        var mousemove = function (e, pageX, pageY) {
                var stream = e.data.stream;
                var offset = $(this).parent().offset();
                var position = $(this).parent().position();
                //var offset = $(this).offset();
                var x = (e.pageX || pageX) - offset.left,
                    y = (e.pageY || pageY) - offset.top;
                var floatTag,
                    floatTagWidth,
                    floatTagHeight,
					mouseToFloatTag = {x: 20, y: 20};
                var path,
                    pathSource = stream.pathSource,
                    pathSourceP,
                    pathIndex,
                    circle;
                var i, l;
                var xIdx = Math.floor((x / (stream.defaults.width
                                / (stream.source[0].length - 1) / 2) + 1) / 2);
                var pathsourceP,
                    lineX;

                //get path
                path = undefined;
                pathSource = stream.pathSource;
                for (i = 0, l = pathSource.length; i &lt; l; i++) {
                    if (y &gt;= pathSource[i][xIdx].y0 - pathSource[i][xIdx].y &amp;&amp; y &lt;= pathSource[i][xIdx].y0) {
                        path = stream.paths[i];
                        pathIndex = i;
                        break;
                    }
                }
                if (typeof path === 'undefined') {
                    return;
                }


                //recover prepath;
                if (typeof stream.prePath !== 'undefined') {
                    stream.prePath.attr({&quot;opacity&quot;: 1, &quot;stroke-width&quot;: 1});
                    // set legend
                    stream.legends[stream.prePath.index].css({&quot;background&quot;: &quot;white&quot;});
                }
                //change new path;
                stream.prePath = path;
                path.attr({&quot;opacity&quot;: 0.5, &quot;stroke-width&quot;: 0});

                // set legend
                stream.legends[stream.prePath.index].css({&quot;background&quot;: &quot;#dddddd&quot;});

                //set indicator and highlight line
                lineX = stream.defaults.width * xIdx / (stream.source[0].length - 1);
                pathSourceP = pathSource[pathSource.length - 1][xIdx];
                stream.indicatorLine.attr({path: &quot;M&quot; + lineX
                        + &quot; &quot; + (pathSourceP.y0 - pathSourceP.y)
                        + &quot;V&quot; + pathSource[0][xIdx].y0});

                pathSourceP = pathSource[pathIndex][xIdx];
                stream.highlightLine.attr({path: &quot;M&quot; + lineX
                        + &quot; &quot; + (pathSourceP.y0 - pathSourceP.y)
                        + &quot;V&quot; + pathSourceP.y0});
                if (pathIndex === 0 &amp;&amp; path.info[0].id === -1) {
                    stream.highlightLine.attr({&quot;cursor&quot;: &quot;pointer&quot;});
                } else {
                    stream.highlightLine.attr({&quot;cursor&quot;: &quot;auto&quot;});
                }

                floatTag = stream.floatTag;
                floatTag.html(path.info[xIdx].tip);

                //axis pop bubble
                stream.axisPopText.attr({&quot;text&quot;: stream.date[xIdx + stream.timeRange[0]]})
                    .transform(&quot;t&quot; + (lineX + stream.defaults.margin[3]) + &quot;,0&quot;);
                stream.axisPopBubble.transform(&quot;t&quot; + (lineX + stream.defaults.margin[3]) + &quot;,0&quot;);

                //customevent;
                if (stream.defaults.customEventHandle.mousemove) {
                    stream.defaults.customEventHandle.mousemove.call(stream,
                            {&quot;timeIndex&quot;: xIdx, &quot;pathIndex&quot;: pathIndex});
                }
            };
        var $canvas = $(this.canvas.canvas);
        $canvas.bind(&quot;mouseenter&quot;, {&quot;stream&quot;: this}, mouseenter);
        $canvas.bind(&quot;mouseleave&quot;, {&quot;stream&quot;: this}, mouseleave);
        $canvas.bind(&quot;click&quot;, {&quot;stream&quot;: this}, click);
        $canvas.bind(&quot;mousemove&quot;, {&quot;stream&quot;: this}, mousemove);

        this.paths = paths;
        this.labels = labels;
        this.indicatorLine = canvas.path(&quot;M0 &quot; + conf.topInterval + &quot;V&quot; + (conf.height - conf.bottomInterval))
            .attr({stroke: &quot;none&quot;, &quot;stroke-width&quot;: 1, &quot;stroke-dasharray&quot;: &quot;- &quot;});
        this.highlightLine = canvas.path(&quot;M0 &quot; + conf.topInterval + &quot;V&quot; + (conf.height - conf.bottomInterval))
            .attr({stroke: &quot;none&quot;, &quot;stroke-width&quot;: 2});
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_createAxis">
    createAxis
  </h3>
  

  <p>创建坐标轴</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.createAxis()</td> 
      <td></td>
      <td>createAxis</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.createAxis = function () {
        //all date strings' format are same, string length are same
        var conf = this.defaults,
            date = this.date.slice(this.timeRange[0], this.timeRange[1] + 1),
            left = conf.margin[3],
            //left = conf.margin[3] + conf.legendWidth,
            right = conf.totalWidth - conf.margin[1] - conf.legendWidth,
            tempWord,
            tickNumber,
            getPopPath = function (El) {
                //down pop
                var x = 0,
                    y = 0,
                    size = 4,
                    cw = 23,
                    bb = {height: 8};
                if (El) {
                    bb = El.getBBox();
                    bb.height *= 0.6;
                    cw = bb.width / 2 - size;
                }
                return [
                    'M', x, y,
                    'l', size, size, cw, 0,
                    'a', size, size, 0, 0, 1, size, size,
                    'l', 0, bb.height,
                    'a', size, size, 0, 0, 1, -size, size,
                    'l', -(size * 2 + cw * 2), 0,
                    'a', size, size, 0, 0, 1, -size, -size,
                    'l', 0, -bb.height,
                    'a', size, size, 0, 0, 1, size, -size,
                    'l', cw, 0,
                    'z'
                ].join(',');
            };

        this.dateScale = d3.scale.linear()
            .domain([0, date.length - 1])
            .range([left, right]);

        tempWord = this.axisPaper.text(0, 0, date[0]);
        tickNumber = Math.floor((right - left)
                / tempWord.getBBox().width / 2) + 1;
        tempWord.remove();
        //tickNumber = 4;

        Axis().scale(this.dateScale)
            .ticks(tickNumber)
            //.ticks(conf.axisTickNumber)
            .tickSize(6, 3, 3)
            .tickAttr({&quot;stroke&quot;: &quot;none&quot;})
            .minorTickAttr({&quot;stroke&quot;: &quot;none&quot;})
            .domainAttr({&quot;stroke&quot;: &quot;none&quot;})
            //.tickTextAttr({&quot;font-size&quot;: conf.fontSize})
            .tickFormat(function (d) {
                return date[d] || &quot;&quot;;
            })(this.axisPaper);//.attr({transform: &quot;t0,&quot; + (conf.height - 0)});

        this.axisPopText = this.axisPaper.text(0, 11, date[0])
            .attr({ &quot;text-anchor&quot;: &quot;middle&quot;,
                    &quot;fill&quot;: &quot;#fff&quot;,
                    //&quot;font-size&quot;: conf.fontSize,
                    &quot;transform&quot;: &quot;t&quot; + left + &quot;,0&quot;})
            .hide();
        this.axisPopBubble = this.axisPaper.path(getPopPath(this.axisPopText))
            .attr({ &quot;fill&quot;: &quot;#000&quot;,
                    //&quot;opacity&quot;: 0,
                    &quot;transform&quot;: &quot;t&quot; + left + &quot;,0&quot;})
            .toBack()
            .hide();
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_getMaxY">
    getMaxY
  </h3>
  

  <p>获取纵轴最大值</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.getMaxY()</td> 
      <td></td>
      <td>getMaxY</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.getMaxY = function () {
        return d3.max(this.source, function (d) {
            return d3.max(d, function (d) {
                return d.y0 + d.y;
            });
        });
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_mapPathSource">
    mapPathSource
  </h3>
  

  <p>映射路径源</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.mapPathSource()</td> 
      <td></td>
      <td>mapPathSource</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.mapPathSource = function () {
        var conf = this.defaults,
            maxX = this.source[0].length - 1,//this.digitData[0].length - 1,
            maxY = this.getMaxY(),
            width = conf.width,
            height = conf.height - conf.topInterval - conf.bottomInterval;
        var i, j, l, l2, s, ps;
        this.pathSource = [];
        for (i = 0, l = this.source.length; i &lt; l; i++) {
            this.pathSource[i] = [];
            for (j = 0, l2 = this.source[0].length; j &lt; l2; j++) {
                s = this.source[i][j];
                ps = this.pathSource[i][j] = {};
                ps.x = s.x * width / maxX;
                ps.y0 = height - s.y0 * height / maxY;
                ps.y = s.y * height / maxY;
            }
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_generateArea">
    generateArea
  </h3>
  

  <p>生成区域</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.generateArea()</td> 
      <td></td>
      <td>generateArea</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.generateArea = function () {
        this.mapPathSource();
        return d3.svg.area().x(function (d) {
            return d.x;
        }).y0(function (d) {
            return d.y0;
        }).y1(function (d) {
            return d.y0 - d.y;
        });
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_clearCanvas">
    clearCanvas
  </h3>
  

  <p>清除画布</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.clearCanvas()</td> 
      <td></td>
      <td>clearCanvas</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.clearCanvas = function () {
        this.canvas.clear();
        this.legend.innerHTML = &quot;&quot;;
        this.axisPaper.clear();
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_reRender">
    reRender
  </h3>
  

  <p>重绘图表</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.reRender()</td> 
      <td></td>
      <td>reRender</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.reRender = function (options) {
        this.setOptions(options);
        this.clearCanvas();
        this.layout();
        this.generatePaths();
        this.canAnimate = true;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_render">
    render
  </h3>
  

  <p>绘制图表</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.render()</td> 
      <td></td>
      <td>render</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.render = function (options) {
        this.firstRender = true;
        this.setOptions(options);
        this.clearCanvas();
        this.layout();
        this.generatePaths();
        this.firstRender = false;
        this.canAnimate = true;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_resize">
    resize
  </h3>
  

  <p>重设图表</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.resize()</td> 
      <td></td>
      <td>resize</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.resize = function (options) {
        var conf = this.defaults;

        if (!options.width &amp;&amp; !options.height) {
            throw new Error(&quot;no width and height input&quot;);
        } else if (options.width &amp;&amp; !options.height) {
            if (conf.autoHeight) {
                this.setOptions({&quot;width&quot;: options.width});
            } else {
                this.setOptions({&quot;width&quot;: options.width, &quot;height&quot;: conf.height});
            }
        } else if (!options.width &amp;&amp; options.height) {
            this.setOptions({&quot;width&quot;: conf.totalWidth, &quot;height&quot;: options.height});
        } else {
            this.setOptions({&quot;width&quot;: options.width, &quot;height&quot;: options.height});
        }

        this.node.innerHTML = &quot;&quot;;
        this.createCanvas();
        this.reRender();
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_on">
    on
  </h3>
  

  <p>侦听自定义事件</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.on()</td> 
      <td></td>
      <td>on</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>eventName(String)</td>
      <td colspan="2">事件名</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>callback(Function)</td>
      <td colspan="2">事件回调函数</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.on = function (eventName, callback) {
        if (typeof this.defaults.customEventHandle[eventName] !== 'undefined') {
            this.defaults.customEventHandle[eventName] = callback;
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_animate">
    animate
  </h3>
  

  <p>设置动画</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Stream.prototype.animate()</td> 
      <td></td>
      <td>animate</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>options(Object)</td>
      <td colspan="2">选项对象</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>timeDuration(Number)</td>
      <td colspan="2">时间</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Stream.prototype.animate = function (options, timeDuration) {
        //must after render if new Source has been set;
        if (!this.canAnimate) {
            throw new Error(&quot;Function animate must be called after render if new Source has been set.&quot;);
        }
        var time = 0,
            area,
            color,
            i,
            l;
        if (arguments.length &gt; 1) {
            time = timeDuration;
        }

        //this.setOptions(options);
        if (options.offset || options.order) {
            this.source = this.remapSource(this.digitData);
            this.layout();
        }
        area = this.generateArea();
        color = this.getColor();
        for (i = 0, l = this.source.length; i &lt; l; i++) {
            var _area = area(this.source[i]);
            var anim = Raphael.animation({path: _area, fill: color(i)}, time);
            this.paths[i].animate(anim);
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/tree" class="api">
  <h2>charts/tree: API索引</h2>
  <ul class="indexs">
  
  </ul>
  <hr />

  

  <p>lobal EventProxy, d3, Raphael, $</p>

  <table class="table">
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>;(function (name, definition) {
    if (typeof define === 'function') {
        define(definition);
    } else {
        this[name] = definition(function (id) { return this[id];});
    }
})('Tree', function (require) {
    var DataV = require('DataV');
    var theme = DataV.Themes;

    var Tree = DataV.extend(DataV.Chart, {
        initialize: function (container, options) {
            this.type = &quot;Tree&quot;;
            this.container = container;
            this.defaults = {};

            this.addlink = {};

            // Properties
            this.treeDepth = 0;
            this.font = {};

            // Canvas
            this.defaults.width = 750;
            this.defaults.height = 760;
            this.defaults.deep = 180;
            this.defaults.radius = 15;

            this.setOptions(options);
            this.emitter = new EventProxy();
            this.createCanvas();
        }
    });

    Tree.prototype.on = function (eventName, callback) {
        this.emitter.on(eventName, callback);
    };

    Tree.prototype.setOptions = function (options) {
        var prop;
        if (options) {
            for (prop in options) {
                if (options.hasOwnProperty(prop)) {
                    this.defaults[prop] = options[prop];
                }
            }
        }
    };

    Tree.prototype.hierarchyTableToJson = function (table) {
        if (table[0][0] === &quot;ID&quot;) {
            table = table.slice(1);
        }

        var rootID;
        var hierarchy = {};
        var addlink = {}; //for multi-fathernode

        table.forEach(function (d, i) {
            if (d[0] === &quot;&quot;) {
                throw new Error(&quot;ID can not be empty(line:&quot; + (i + 1) + &quot;).&quot;);
            }
            if (!d[3]) {
                if (rootID) {
                    throw new Error(&quot;2 or more lines have an empty parentID(line:&quot; + (i + 1) + &quot;).&quot;);
                } else {
                    rootID = d[0];
                }
            }
            if (hierarchy[d[0]]) {
                throw new Error(&quot;2 or more lines have same ID: &quot; + d[0] + &quot;(line:&quot; + (i + 1) + &quot;).&quot;);
            }

            var value = &quot;&quot;;
            var j, length;
            if (d.length &gt; 4) {
                for (j = 4, length = d.length; j &lt; length; j++) {
                    if (j &lt; length - 1) {
                        value = value + d[j] + &quot;,&quot;;
                    } else {
                        value = value + d[j];
                    }
                }
            }
            hierarchy[d[0]] = {name: d[1], size: d[2], child: [], id: d[0], value: value};
        });
        if (!rootID) {
            throw new Error(&quot;No root node defined.&quot;);
        }
        table.forEach(function (d, i) {
            if (d[3]) {
                var record;
                var ids = d[3].split('.');
                if (ids.length === 1) {
                    record = hierarchy[d[3]];
                    record.child.push(d[0]);
                } else {
                    record = hierarchy[ids[0]];
                     record.child.push(d[0]);
                    addlink[d[0]] = {child: [], path: [], pnode: []};

                    var j, length;
                    for (j = 1, length = ids.length; j &lt; length;  j++) {
                        addlink[d[0]].child.push(ids[j]);
                    }
                }
                if (!record) {
                    throw new Error(&quot;Can not find parent with ID &quot; + d[3] + &quot;(line:&quot; + (i + 1) + &quot;).&quot;);
                }
            }
        });

        this.addlink = addlink;

        var recurse = function (rootID) {
            var record = hierarchy[rootID];
            if (record.child.length === 0) {
                if (isNaN(parseFloat(record.size))) {
                    throw new Error(&quot;Leaf node's size is not a number(ID:&quot; + (rootID + 1) + &quot;).&quot;);
                } else {
                    return {name: record.name, 
                        size: record.size, 
                        num: record.id, 
                        children: null, 
                        draw: false, 
                        value: record.value};
                }
            } else {
                var childNode = [];
                record.child.forEach(function (d) {
                    childNode.push(recurse(d));
                });
                return {name: record.name, children: childNode, num: record.id, draw: false, value: record.value};
            }
        };

        return recurse(rootID);
    };

    Tree.prototype.setSource = function (source) {
        var conf = this.defaults;

        this.rawData = this.hierarchyTableToJson(source);
        this.source = this.remapSource(source);
        
        this.source.x0 = conf.width / 2;
        this.source.y0 = conf.radius * 10;

        this.source.children.forEach(function collapse(d) {
            if (d.children) {
                // d._children = d.children;
                // d._children.forEach(collapse);
                // d.children = null;
                d._children = null;
                d.children.forEach(collapse);
            }
        });
    };

    Tree.prototype.remapSource = function (data) {
        return this.hierarchyTableToJson(data);
        // return data;
    };

    Tree.prototype.layout = function () {
        var conf = this.defaults;
        var tree = d3.layout.tree()
            .size([conf.width, conf.height]);

        this.nodesData = tree.nodes(this.source);

        var treedepth = 0;
        var id = 0;

        this.nodesData.forEach(function (d) {
            if (d.depth &gt; treedepth) {
                treedepth = d.depth;
            }
        });

        this.treeDepth = treedepth;
        conf.deep = conf.height / (treedepth + 1);

        this.nodesData.forEach(function (d) {
            d.y = conf.radius * 3 + d.depth * conf.deep;
            d.id = id;
            id++;
        });
    };

    Tree.prototype.getColor = function () {
        //var conf = this.defaults;
        //var treedepth = this.treeDepth;

        var colorMatrix = DataV.getColor();
        var color;
        if (colorMatrix.length &gt; 1 &amp;&amp; colorMatrix[0].length &gt; 1) {
            color = [colorMatrix[0][0], colorMatrix[1][0]];
        } else {
            color = colorMatrix[0];
        }
        //var colorRow_Num = colorRow.length - 1;

        return DataV.gradientColor(color, &quot;special&quot;);
        
        // return function(d){
        //     var color;

        //     if ((treedepth * 2 - 1 )&gt; colorRow_Num) {
        //         if (d &gt; colorRow_Num) {
        //             color = colorRow[colorRow_Num];
        //         } else {
        //             color = colorRow[d];
        //         }
        //     } else {
        //         if (d == 0) {
        //             color = colorRow[0];
        //         } else {
        //             color = colorRow[d * 2 - 1];
        //         }
        //     }

        //     return color;
        // }
    };

    // Tree.prototype.getFont = function () {
    //     //var conf = this.defaults;

    //     return DataV.getFont();
    // };

    Tree.prototype.createCanvas = function () {
        var conf = this.defaults;
        this.canvas = new Raphael(this.container, conf.width, conf.height);
        this.canvasF = document.getElementById(this.container);
        canvasStyle = this.canvasF.style;
        canvasStyle.position = &quot;relative&quot;;
        this.floatTag = DataV.FloatTag()(this.canvasF);

        this.floatTag.css({&quot;visibility&quot;: &quot;hidden&quot;});

        this.DOMNode = $(this.canvas.canvas);
        var that = this;
        this.DOMNode.click(function (event) {
            that.emitter.trigger(&quot;click&quot;, event);
        });
        this.DOMNode.dblclick(function (event) {
            that.emitter.trigger(&quot;dblclick&quot;, event);
        });

        var mousewheel = document.all ? &quot;mousewheel&quot; : &quot;DOMMouseScroll&quot;;  
        this.DOMNode.bind(mousewheel, function (event) {
            that.emitter.trigger(&quot;mousewheel&quot;, event);
        });

        this.DOMNode.bind(&quot;contextmenu&quot;, function (event) {
            that.emitter.trigger(&quot;contextmenu&quot;, event);
        });

        this.DOMNode.delegate(&quot;circle&quot;, &quot;click&quot;, function (event) {
            that.emitter.trigger(&quot;circle_click&quot;, event);
        });

        this.DOMNode.delegate(&quot;circle&quot;, &quot;mouseover&quot;, function (event) {
            that.emitter.trigger(&quot;circle_mouseover&quot;, event);
        });

        this.DOMNode.delegate(&quot;circle&quot;, &quot;mouseout&quot;, function (event) {
            that.emitter.trigger(&quot;circle_mouseout&quot;, event);
        });

    };

    Tree.prototype.zoom = function (d) {
        var multiple = 2;

        if (d !== null) {
            multiple = d;
        }

        var conf = this.defaults;

        conf.width = conf.width * multiple;

        if (conf.height &lt;= this.treeDepth * conf.deep) {
            conf.height = conf.height * multiple;
        }

        //this.createCanvas();
        this.canvas.setSize(conf.width, conf.height);
        this.canvas.setViewBox(0, 0, conf.width, 800);
        this.defaults = conf;

        this.render();
    };


    Tree.prototype.getLinkPath = function (fx, fy, tx, ty) {
        var conf = this.defaults;

        var c1x = fx;
        var c1y = fy + (ty - fy) / 2;
        var c2x = tx;
        var c2y = ty - (ty - fy) / 2;

        var link_path = [[&quot;M&quot;, fx, fy + conf.radius], 
            [&quot;C&quot;, c1x, c1y, c2x, c2y, tx, ty - conf.radius]];

        return link_path;    
    };

    Tree.prototype.generatePaths = function () {
        var canvas = this.canvas;
        var source = this.source;
        var conf = this.defaults;
        var radius = conf.radius;
        //canvas.clear();
        var color = this.getColor();
        // var font = this.getFont();
        var font_family = '微软雅黑';
        var font_size = 8;
        var treedepth = this.treeDepth;
        var nodesData = this.nodesData;

        var n = 0;

        var addlink = this.addlink;
        var node;
        var num = 0;

        var nodes = canvas.set();
        var path = [];
        var textpath = [];
        
        var tree = this;
        var nodeupdate = function () {
            tree.update(this.data(&quot;num&quot;));
        };

        $(&quot;#&quot; + this.container).append(this.floatTag);

        var i, nodesLength;
        for (i = 0, nodesLength = nodesData.length; i &lt; nodesLength;  i++) {
            var d =  nodesData[i];
            var parent = d.parent;

            if (addlink[d.num]) {
                var j, k, childLength;
                for (j = 0, childLength = addlink[d.num].child.length; j &lt; childLength; j++) {
                    for (k = 0; k &lt; nodesLength;  k++) {
                        if (nodesData[k].num === addlink[d.num].child[j]) {
                            addlink[d.num].pnode[j] = k;
                            addlink[d.num].path[j] = canvas.path()
                                .attr({ stroke:  &quot;#939598&quot;, &quot;stroke-width&quot;: 0.5});
                        }
                    }
                } 
            }

            var startX;
            var startY;

            if (parent &amp;&amp; d.draw) {
                startX = parent.x;
                startY = parent.y;
            } else {
                startX = d.x;
                startY = d.y;
            }
            if (parent) {
                path.push(canvas.path().attr({stroke:  &quot;#939598&quot;, &quot;stroke-width&quot;: 0.5}));
            }

            nodes.push(
                canvas.circle(startX, startY, radius)
                    .attr({fill: color(d.depth / treedepth), 
                        stroke:  &quot;#ffffff&quot;, 
                        &quot;stroke-width&quot;: 1, 
                        &quot;fill-opacity&quot;: 0.4, 
                        &quot;data&quot;: 12})
                    .data(&quot;num&quot;, i)
                    .animate({cx: d.x, cy: d.y}, 500, &quot;backOut&quot;)
            );

            if (d.children || d._children) {
                nodes[i].click(nodeupdate);
            }

            if (d._children) {
                nodes[i].attr({stroke:  color(d.depth / treedepth), 
                    &quot;stroke-width&quot;: radius, 
                    &quot;stroke-opacity&quot;: 0.4, 
                    &quot;fill-opacity&quot;: 1, 
                    &quot;r&quot;: radius / 2});
            }

            if (d.children) {
                textpath.push(canvas.text(d.x, d.y - radius - 7, d.name).attr({'font-size': 12}));
            } else {
                textpath.push(canvas.text(d.x, d.y + radius + 7, d.name).attr({'font-size': 12}));
            }
        }

        // var back = function(pid, x, y){
        //     s.forEach(function (d, i){
        //         if (d.data('pid') == pid){
        //             d.animate({cx: x, cy: y}, 200, &quot;backOut&quot;);
        //             if (nodes[i].children)
        //             back(d.data('num'), d.attr('cx'), d.attr('cy'));
        //         }
        //     });
        // };

        // s.forEach(function(d, i) {
        //     d.click(function(){
        //         if (nodes[i].children)
        //         back(d.data('num'), d.attr('cx'), d.attr('cy'));
        //         tree.update(d.data(&quot;num&quot;));
        //     });
        // });
        var floatTag = this.floatTag;
        nodes.forEach(function (d, i) {
            $(d.node).attr('value', nodesData[i].value);
            var textY = textpath[i].attr('y');
            var thisradius = d.attr('r');
            var thisstrokewidth = d.attr('stroke-width');
            d.mouseover(function () {
                if (!nodesData[i]._children) {
                    this.animate({r: thisradius + 2, &quot;fill-opacity&quot;: 0.75}, 100);
                } else {
                    this.animate({r: thisradius + 2, &quot;stroke-opacity&quot;: 0.75}, 100);
                } 

                textpath[i].attr({'font-size': 20});

                if (i &gt; 0) {
                    if (!nodesData[i].children) {
                        textpath[i].animate({'y': textY + 12}, 100, &quot;backOut&quot;);
                    } else {
                        textpath[i].animate({'y': textY - 12}, 100, &quot;backOut&quot;);
                    }
                }

                var getFline = function (node, num) {
                    var parent = node.parent;
                    if (parent) {
                        path[node.id - 1].attr({&quot;stroke-width&quot;: 4, &quot;stroke-opacity&quot;: num});
                        if ( num &gt; 0.5) {
                            num = num - 0.1;
                        }
                        getFline(parent, num);
                    }
                }

                getFline(nodesData[i], 0.9);

                var thisparent = nodesData[i].parent;
                var j, textpathLength;
                for (j = 0, textpathLength = textpath.length; j &lt; textpathLength; j++) {
                    var parent = nodesData[j].parent;
                    if (parent === thisparent &amp;&amp; j !== i) {
                        textpath[j].animate({'fill-opacity': 0.4});
                    }
                }

                console.log(nodesData[i]);
                floatTag.html ( '&lt;div style = &quot;text-align: center;margin:auto;color:'
                    //+ jqNode.color
                    + &quot;#ffffff&quot;
                    + '&quot;&gt;' + nodesData[i].name + '&lt;/div&gt;'
                    );
                floatTag.css({&quot;visibility&quot; : &quot;visible&quot;});
            })
            .mouseout(function () {
                floatTag.css({&quot;visibility&quot; : &quot;hidden&quot;});
                if (!nodesData[i]._children) {
                    this.animate({r: thisradius, &quot;fill-opacity&quot;: 0.4}, 100);
                } else {
                    this.animate({r: thisradius, &quot;stroke-width&quot;: thisstrokewidth, &quot;stroke-opacity&quot;: 0.4}, 100);
                } 
                textpath[i].attr({'font-size': 12});
                textpath[i].animate({'y': textY}, 100, &quot;backOut&quot;);

                var getFline = function (node) {
                    var parent = node.parent;
                    if (parent) {
                        path[node.id - 1].attr({&quot;stroke-width&quot;: 0.5, &quot;stroke-opacity&quot;: 1});
                        getFline(parent);
                    }
                }
                getFline(nodesData[i]);

                var thisparent = nodesData[i].parent;
                var j, textpathLength;
                for (j = 0, textpathLength = textpath.length; j &lt; textpathLength; j++) {
                    var parent = nodesData[j].parent;
                    if (parent === thisparent &amp;&amp; j !== i) {
                        textpath[j].animate({'fill-opacity': 1});
                    }
                }
            });
        });

        nodes.onAnimation(function () {
            var pathNum = 0;
            var i, nodeslength;
            
            for (i = 1, nodeslength = nodes.length; i &lt; nodeslength;  i++) {
                var d = nodes[i];
                var node = nodesData[i];
                var parent = node.parent;
                
                path[pathNum]
                    .attr({path: tree.getLinkPath(parent.x, parent.y, d.attr(&quot;cx&quot;), d.attr(&quot;cy&quot;))});
                    
                pathNum++;

                if (addlink[node.num]) {
                    var j, k, linkchildLength, nodesLength;
                    for (j = 0, linkchildLength = addlink[node.num].child.length; j &lt; linkchildLength; j++) {
                        for (k = 0, nodesLength = nodesData.length; k &lt; nodesLength;  k++) {
                            var anparent = nodesData[k];
                            if (anparent.num === addlink[node.num].child[j]) {
                                var link_path = tree.getLinkPath(anparent.x, anparent.y, d.attr(&quot;cx&quot;), d.attr(&quot;cy&quot;));
                                addlink[node.num].path[j].attr({path: link_path});
                            }
                        }
                    } 
                }
            }
        });
        
        this.nodes = nodes;
        this.path = path;
        this.textpath = textpath;
        // this.link_paths = link_paths;
        // this.circle_paths = circle_paths;
        // this.text_paths = text_paths;
    };
    
    Tree.prototype.update = function (i) {
        var source = this.source;
        var conf = this.defaults;

        source.children.forEach(function clearDraw(d) {
            d.draw = false;
            if (d.children) {
                d.children.forEach(clearDraw);
            }
        });

        source.children.forEach(function find(d) {
            if (d.id === i) {
                if (d.children) {
                    d._children = d.children;
                    d.children = null;
                } else {
                    d.children = d._children;
                    if (d.children) {
                        d.children.forEach(function drawn(child) {
                            child.draw = true;
                            if (child.children) {
                                child.children.forEach(drawn);
                            }
                        });
                    }
                    d._children = null;
                }
            } else {
                if (d.children) {
                    d.children.forEach(find);
                }
            }
        });
        this.source = source;
        this.source.x0 = conf.width / 2;
        this.source.y0 = conf.radius * 2;
        this.render();
    };
    


    Tree.prototype.render = function (options) {
        // var st = new Date().getTime();
        if (!this.container) {
            throw new Error(&quot;Please specify which node to render.&quot;);
        }
        this.canvas.clear();
        this.setOptions(options);
        this.layout();
        // var st2 = new Date().getTime();

        this.generatePaths();
        // var et = new Date().getTime();
        //this.canvas.renderfix();
    };

    return Tree;
});</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
        <section id="api_charts/treemap" class="api">
  <h2>charts/treemap: API索引</h2>
  <ul class="indexs">
  
    <li>
      <a href="#_Treemap">Treemap</a>
    </li>

    <li>
      <a href="#_createCanvas">createCanvas</a>
    </li>

    <li>
      <a href="#_getColor">getColor</a>
    </li>

    <li>
      <a href="#_setSource">setSource</a>
    </li>

    <li>
      <a href="#_layout">layout</a>
    </li>

    <li>
      <a href="#_generatePaths">generatePaths</a>
    </li>

    <li>
      <a href="#_clearCanvas">clearCanvas</a>
    </li>

    <li>
      <a href="#_reRender">reRender</a>
    </li>

    <li>
      <a href="#_render">render</a>
    </li>

  </ul>
  <hr />

  

  <table class="table">
  

  
  </table>
  
  
  <h3 id="_Treemap">
    Treemap
  </h3>
  

  <p>Treemap构造函数，继承自Chart</p>

<h2>Examples</h2>

<p>create treemap in a dom node with id "chart", width is 500; height is 600px;</p>

<div class="highlight"><pre lang="">var treemap = new Treemap("chart", {"width": 500, "height": 600});
</pre></div>

  <table class="table">
  
    <tr>
      <td>声明</td>
      <td>Treemap</td> 
      <td></td>
      <td>Treemap</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>node(Object)</td>
      <td colspan="2">The dom node or dom node Id</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>options(Object)</td>
      <td colspan="2">JSON object for determin treemap style</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>var Treemap = DataV.extend(DataV.Chart, {
        initialize: function (node, options) {
            this.type = &quot;Treemap&quot;;
            this.node = this.checkContainer(node);
            this.defaults = {};

            // Properties
            this.selectedTreeNodes = [];//array of nodes on the path from root to recent node
            this.treeNodeJson = {};
            this.level_ = 2;
            this.defaults.level1BorderWidth = 1;
            this.defaults.level2BorderWidth = 1;

            this.defaults.fontSizeRatio = 1.0;

            // Canvas
            this.defaults.showBackTag = true;
            this.defaults.backHeight = 20;
            this.defaults.width = 750;

            //event
            this.defaults.leafNodeClick = function () {};
            this.defaults.hoverIn = function () {};
            this.defaults.hoverOut = function () {};

            this.defaults.height = 500;
            this.setOptions(options);
            this.createCanvas();
        }
    });</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_createCanvas">
    createCanvas
  </h3>
  

  <p>Create dom node relate to treemap</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Treemap.prototype.createCanvas()</td> 
      <td></td>
      <td>createCanvas</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Treemap.prototype.createCanvas = function () {
        var conf = this.defaults,
            floatStyle,
            container = this.node,
            backStyle,
            canvasStyle;

        this.node.style.position = &quot;relative&quot;;

        if (conf.showBackTag) {
            this.backTag = document.createElement(&quot;div&quot;);
            backStyle = this.backTag.style;
            backStyle.width = conf.width + &quot;px&quot;;
            backStyle.height = conf.backHeight + &quot;px&quot;;
            backStyle.paddingLeft = &quot;5px&quot;;
            container.appendChild(this.backTag);
        }

        this.canvas = document.createElement(&quot;div&quot;);
        canvasStyle = this.canvas.style;
        canvasStyle.position = &quot;relative&quot;;
        canvasStyle.width = conf.width + &quot;px&quot;;
        canvasStyle.height = conf.height + &quot;px&quot;;
        container.appendChild(this.canvas);

        this.floatTag = DataV.FloatTag()(this.canvas);

        this.floatTag.css({&quot;visibility&quot;: &quot;hidden&quot;});

        //this.canvas.appendChild(this.floatTag);
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_getColor">
    getColor
  </h3>
  

  <p>获取颜色</p>

<h2>Examples</h2>

<div class="highlight"><pre lang="">// 获取第二种颜色的渐变色。
{mode: "gradient", index: 1}
// 获取最深的离散色。
{mode: "random", ratio: 0}
// 获取最浅的离散色。
{mode: "random", ratio: 1}
// 获取适中的离散色。
{mode: "random", ratio: 0.5}
</pre></div>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Treemap.prototype.getColor()</td> 
      <td></td>
      <td>getColor</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>colorJson(Object)</td>
      <td colspan="2">Way to get color from color theme matrix</td>
    </tr>
  

    <tr>
      <td>返回</td>
      <td>Array</td>
      <td colspan="2">返回颜色数组</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Treemap.prototype.getColor = function (colorJson) {
        var colorMatrix = DataV.getColor();
        var color;
        var colorStyle = colorJson || {};
        var colorMode = colorStyle.mode || 'default';
        var i, l;

        switch (colorMode) {
        case &quot;multiColorGradient&quot;:
            //color = d3.interpolateHsl.apply(null, [&quot;red&quot;, &quot;blue&quot;]);
            //color = d3.interpolateHsl.apply(null, [colorMatrix[0][0], colorMatrix[colorMatrix.length - 1][0]]);
            //color = DataV.gradientColor([&quot;#f5f5f6&quot;, &quot;#f6f5f5&quot;], 'special');
            //color = DataV.gradientColor([colorMatrix[0][0], colorMatrix[colorMatrix.length - 1][0]], 'special');
            //color = d3.interpolateRgb.apply(null, [colorMatrix[0][0], colorMatrix[colorMatrix.length - 1][0]]);

            color = (function () {
                var c = [];
                colorMatrix.forEach(function (d, i) {
                    c.push(d[0]);
                });
                return function (ratio) {
                    var index = (c.length - 1) * ratio;
                    var floor = Math.floor(index);
                    var ceil = Math.ceil(index);
                    if (floor === ceil) {
                        return c[floor];
                    } else {
                        return d3.interpolateRgb.apply(null, [c[floor], c[ceil]])(index - floor);
                    }
                };
            }());
            //color = d3.interpolateRgb.apply(null, [&quot;green&quot;, &quot;purple&quot;]);
            break;
        case &quot;gradient&quot;:
            var index = colorJson.index || 0;
            index = index &lt; 0 ? 0 : Math.min(index, colorMatrix.length - 1);
            color = d3.interpolateRgb.apply(null, [colorMatrix[index][0], colorMatrix[index][1]]);
            break;
        case &quot;random&quot;:
        case &quot;default&quot;:
            var ratio = colorStyle.ratio || 0;
            if (ratio &lt; 0) { ratio = 0; }
            if (ratio &gt; 1) { ratio = 1; }
            var colorArray = [];
            for (i = 0, l = colorMatrix.length; i &lt; l; i++) {
                var colorFunc = d3.interpolateRgb.apply(null, [colorMatrix[i][0], colorMatrix[i][1]]);
                colorArray.push(colorFunc(ratio));
            }
            color = d3.scale.ordinal().range(colorArray);
            break;
        }
        return color;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_setSource">
    setSource
  </h3>
  

  <p>设置数据源</p>

<h2>Examples</h2>

<p>treemap数据输入的格式可以是二维数组。例如下面的数组表示2000年4个季度的天数。<br />第1季度下面还列出了1-3月的天数。数组的第一行为四个固定的字符串"ID"，"name"，"size"和"parentID"。<br />四列数据分别表示层次数据集中各结点的ID，名称，大小和父节点ID。叶子节点必须有大小，根结点不能有父节点ID。各结点的ID、名称必须要有。</p>

<div class="highlight"><pre lang=""> [
     ["ID", "name", "size", "parentID"],
     [0, "2000",  ,  ],
     [1, "season1",  , 0],
     [2, "January", 31, 1],
     [3, "February", 29, 1],
     [4, "Match", 31, 1],
     [5, "season2", 91, 0],
     [6, "season3", 92, 0],
     [7, "season4", 92, 0]
 ]
</pre></div>

<p>数据还可以是json格式。每个结点都有<code>name</code>，如果是父节点则还有<code>children</code>，如果为叶节点则还有<code>size</code>。以上数组数据对应的json数据如下：</p>

<div class="highlight"><pre lang="">{
  "name": "2000",
  "children": [
     {
      "name": "season1",
      "children": [
           {"name": "January", "size": 31},
           {"name": "February", "size": 29},
           {"name": "Match", "size": 31}
         ]
     },
     {"name": "season2", "size": 91},
     {"name": "season3", "size": 92},
     {"name": "season4", "size": 92},
  ]
}
</pre></div>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Treemap.prototype.setSource()</td> 
      <td></td>
      <td>setSource</td>
    </tr>
  

    <tr>
      <td>参数</td>
      <td>source(Array,Object)</td>
      <td colspan="2">json or 2-d array</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Treemap.prototype.setSource = function (source) {
        if (source instanceof Array) {
            this.rawData = this._arrayToJson(source);
        } else {
            this.rawData = source;
        }
        this.source = this._remapSource(this.rawData);
        this.selectedTreeNodes = [this.source[0]];
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_layout">
    layout
  </h3>
  

  <p>d3 treemap layout</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Treemap.prototype.layout()</td> 
      <td></td>
      <td>layout</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Treemap.prototype.layout = function () {
        var treemap = this._createTreemap()
            .sort(function (a, b) { return a.value - b.value; });
        this.nodes = treemap.nodes(this.treeNodeJson);
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_generatePaths">
    generatePaths
  </h3>
  

  <p>生成绘制路径</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Treemap.prototype.generatePaths()</td> 
      <td></td>
      <td>generatePaths</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Treemap.prototype.generatePaths = function () {
        //add interactive need
        var canvas = this.canvas,
            conf = this.defaults,
            color,
            leafIndex = 0,
            leafCount,
            colorRatio,
            level1Node,
            level1NodeArray = [],
            funcArray = {},
            i,
            l,
            level1Count = 0,
            level1ColorFun,
            goIn = function (event) {
                var treemap = event.data.treemap,
                    treemapNode = event.data.treemapNode,
                    jqueryNode = event.data.jqueryNode;
                jqueryNode.css({'z-index': 30,
                            &quot;backgroundColor&quot;: jqueryNode.color})
                    .animate({
                        left : 0,
                        top : 0,
                        width : treemap.defaults.width,
                        height : treemap.defaults.height
                    }, 1000, function () {
                        treemap._goToLeaf(treemapNode);
                    });
            },

            goOut = function (event) {
                var treemap = event.data.treemap;
                if (treemap.selectedTreeNodes.length &gt; 1) {
                    treemap._goToRoot(treemap.selectedTreeNodes.length - 2);
                }
                return false;
            },

            level1HoverIn = function (index, level1NodeArray) {
                return function () {
                    level1NodeArray.forEach(function (d, i, Array) {
                        if (i === index) {
                            d.css(&quot;font-size&quot;, Array[i].fontSizeValue * 6 / 5 + &quot;px&quot;);
                            if (d.treemapNode.children) {
                                Array[i].css(&quot;backgroundColor&quot;, '');
                            }
                        } else {
                            Array[i].css(&quot;backgroundColor&quot;,
                                d3.interpolateRgb.apply(null, [Array[i].color, &quot;#fff&quot;])(0.4));
                        }
                    });
                    level1NodeArray[0].treemap.floatTag.css({&quot;visibility&quot; : &quot;visible&quot;});
                };
            },

            level1HoverOut = function (level1NodeArray) {
                return function () {
                    level1NodeArray.forEach(function (d, i, Array) {
                        Array[i].css(&quot;backgroundColor&quot;, Array[i].color)
                            .css(&quot;font-size&quot;, Array[i].fontSizeValue + &quot;px&quot;);
                    });
                    level1NodeArray[0].treemap.floatTag.css({&quot;visibility&quot; : &quot;hidden&quot;});
                };
            },

            level0HoverIn = function () {
                this.jqNode.treemap.floatTag.css({&quot;visibility&quot; : &quot;visible&quot;});
            },

            level0HoverOut = function () {
                this.jqNode.treemap.floatTag.css({&quot;visibility&quot; : &quot;hidden&quot;});
            },

            mousemove = function () {
                var jqNode = this.jqNode,
                    treemap = jqNode.treemap,
                    floatTag = treemap.floatTag;

                //set floatTag content
                floatTag.html('&lt;div style = &quot;text-align: center;margin:auto;color:' +
                    //+ jqNode.color
                    '&quot;#fff&quot;&gt;' + jqNode.treemapNode.name + '&lt;/div&gt;' +
                    '&lt;div style = &quot;text-align: center; margin:auto;color:' +
                    '&quot;#fff&quot;&gt;' + jqNode.treemapNode.value + '&lt;/div&gt;');
            },

            customEvent = function (f, o) {
                return function () {
                    f.call(o);
                };
            };

        $(canvas).append(this.floatTag);//canvas clear before draw, add floatTag.

        for (i = 0, l = this.nodes.length; i &lt; l; i++) {
            var d = this.nodes[i],//treemap node
                borderWidth,
                w,
                h,
                left,
                top,
                depthColor,
                depthColorHsl,
                jqNode = $(document.createElement(&quot;div&quot;));

            if (!(d.parent &amp;&amp; d.parent.parent)) {
                //level 0 and 1
                color = this.getColor({mode: &quot;gradient&quot;, index: this._changeLevel1NodeColorIndex(d.name)});
                leafIndex = -1;
                leafCount = d.children ? d.children.length : 0;
                colorRatio = 0.5;

                if (d.parent) {
                    //only level 1
                    level1NodeArray.push(jqNode);
                    level1Node = jqNode;
                }
                jqNode.color = color(colorRatio);
                if (d.parent) {
                    //level 1
                    if (this.selectedTreeNodes.length === 1) {
                        //root
                        if (!level1ColorFun) {
                            level1ColorFun = this.getColor({mode: &quot;multiColorGradient&quot;});
                        }
                    } else {
                        if (!level1ColorFun) {
                            depthColor = this.selectedTreeNodes[this.selectedTreeNodes.length - 1].color;
                            depthColorHsl = d3.hsl(depthColor);
                            level1ColorFun = d3.interpolateHsl.apply(null, [
                                d3.hsl((depthColorHsl.h + 180) % 360, depthColorHsl.s, depthColorHsl.l).toString(),
                                depthColor
                            ]);
                        }
                    }
                    jqNode.color = d.parent.children.length === 1 
                        ? level1ColorFun(0)
                        : level1ColorFun((level1Count++) / (d.parent.children.length - 1));
                    color = d3.interpolateRgb.apply(null, [jqNode.color,
                            d3.interpolateRgb.apply(null, [jqNode.color, &quot;#fff&quot;])(0.5)]);
                } else {
                    //level 0
                    if (this.selectedTreeNodes.length &gt; 1) {
                        jqNode.color = this.selectedTreeNodes[this.selectedTreeNodes.length - 1].color;
                    }
                }
            } else {
                //level 2
                leafIndex += 1;
                colorRatio = leafCount === 1 ? 0 : leafIndex / (leafCount - 1);
                jqNode.color = color(colorRatio);
            }
            jqNode.treemapNode = d;
            d.color = jqNode.color;
            jqNode.treemap = this;
            jqNode[0].jqNode = jqNode;
            jqNode.appendTo($(canvas));

            jqNode.css(&quot;borderStyle&quot;, &quot;solid&quot;)
                .css(&quot;borderColor&quot;, &quot;#d6d6d6&quot;)
                .css(&quot;overflow&quot;, &quot;hidden&quot;)
                .css(&quot;fontFamily&quot;, '黑体')
                //.css(&quot;fontFamily&quot;, 'sans-serif')
                .css(&quot;position&quot;, &quot;absolute&quot;)
                .css(&quot;textIndent&quot;, &quot;2px&quot;)
                .css(&quot;backgroundColor&quot;, jqNode.color)
                //.css(&quot;color&quot;, &quot;#fff&quot;);
                .css(&quot;color&quot;, &quot;white&quot;);
                //.css(&quot;textAlign&quot;, &quot;center&quot;);

            if (!d.parent) {
                // level 0 node
                if (!d.children) {
                    jqNode.html(d.name);
                }
            } else if (d.parent &amp;&amp; !d.parent.parent) {
                // level 1 node
                jqNode.html(d.name)
                    .css(&quot;zIndex&quot;, 20);
                if (d.children) {
                    //jqNode.css(&quot;backgroundColor&quot;, '');
                    jqNode.css(&quot;backgroundColor&quot;, jqNode.color);
                }
            } else {
                // level 2 node
                jqNode.css(&quot;borderColor&quot;, &quot;rgba(255, 255, 255, 0.5)&quot;);
            }

            // position
            // border do not need adjust, still 1 px;
            borderWidth = 1;
            w = Math.max(0, d.dx - borderWidth);
            h = Math.max(0, d.dy - borderWidth);
            jqNode.fontSizeValue = Math.max(conf.fontSizeRatio
                    * parseInt(60 * Math.sqrt(w * h / conf.width / conf.height), 10),
                    12);
            jqNode.css(&quot;borderWidth&quot;, borderWidth + &quot;px&quot;)
                .css(&quot;left&quot;, d.x + &quot;px&quot;)
                .css(&quot;top&quot;, d.y + &quot;px&quot;)
                .css(&quot;width&quot;, w + &quot;px&quot;)
                .css(&quot;height&quot;, h + &quot;px&quot;)
                .css(&quot;fontSize&quot;, jqNode.fontSizeValue + &quot;px&quot;);
                //.css(&quot;lineHeight&quot;, Math.max(0, d.dy - borderWidth ) + &quot;px&quot;);

            if (d.parent &amp;&amp; !d.parent.parent) {
                //level 1
                jqNode.css(&quot;cursor&quot;, &quot;pointer&quot;);
                jqNode.clone().insertBefore(jqNode).css(&quot;opacity&quot;, 0.01);
                jqNode.click({&quot;treemap&quot;: this, &quot;treemapNode&quot;: d, &quot;jqueryNode&quot;: jqNode}, goIn);
                jqNode.mouseover(level1HoverIn(level1NodeArray.length - 1, level1NodeArray));
                jqNode.mouseout(level1HoverOut(level1NodeArray));
                jqNode.mousemove(mousemove);
            }

            if (!d.parent) {
                //level 0; leaf node
                jqNode.mouseover(level0HoverIn);
                jqNode.mouseout(level0HoverOut);
                jqNode.mousemove(mousemove);
            }

            jqNode.bind(&quot;contextmenu&quot;, {&quot;treemap&quot;: this}, goOut);

            // custom interacitves
            var o = {treemapNode : d,
                node : jqNode,
                name : d.name,
                parent : d.parent,
                value : d.value
                };

            if (d.parent &amp;&amp; (!d.parent.parent) &amp;&amp; (!d.children)) {
                jqNode.click(customEvent(this.defaults.leafNodeClick, o));
            }
    
            jqNode.mouseover(customEvent(this.defaults.hoverIn, o));
    
            jqNode.mouseout(customEvent(this.defaults.hoverOut, o));

            //canvas.appendChild(jqNode[0]);
        }
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_clearCanvas">
    clearCanvas
  </h3>
  

  <p>清除画布</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Treemap.prototype.clearCanvas()</td> 
      <td></td>
      <td>clearCanvas</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Treemap.prototype.clearCanvas = function () {
        var canvas = this.canvas;
        canvas.innerHTML = &quot;&quot;;
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_reRender">
    reRender
  </h3>
  

  <p>计算布局，并重新渲染图表</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Treemap.prototype.reRender()</td> 
      <td></td>
      <td>reRender</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Treemap.prototype.reRender = function (options) {
        this.clearCanvas();
        this.setOptions(options);
        this._create2LevelJson(this.selectedTreeNodes[this.selectedTreeNodes.length - 1]);
        this.layout();
        this._setBackTag();
        this.generatePaths();
    };</code></pre></td>
    </tr>
  
  </table>
  
  
  <h3 id="_render">
    render
  </h3>
  

  <p>计算布局位置，并渲染图表</p>

  <table class="table">
  
    <tr>
      <td>方法</td>
      <td>Treemap.prototype.render()</td> 
      <td></td>
      <td>render</td>
    </tr>
  

  
    <tr>
      <td>代码</td><td colspan="3"><pre><code>Treemap.prototype.render = function (options) {
        this.clearCanvas();
        this.setOptions(options);
        this._getNodeTheme = undefined;
        this.selectedTreeNodes = this.selectedTreeNodes.slice(0, 1);
        this._create2LevelJson(this.selectedTreeNodes[0]);
        this.layout();
        this._setBackTag();
        this.generatePaths();
    };</code></pre></td>
    </tr>
  
  </table>
  
</section>
      
    </div>
  </div>
</div>
      <footer class="footer">
        <div class="container">
          <p class="pull-right">
            <a href="#">Back to top</a>
          </p>
          <p>此文档通过doxmate生成。主题借鉴Bootstrap API文档风格，注解基于<a href="https://github.com/visionmedia/dox">Dox</a>。欢迎关注doxmate作者<a href="http://weibo.com/shyvo" target="_blank">@朴灵</a></p>
          <ul class="footer-links">
            <li><a href="https://github.com/visionmedia/dox">Dox主页</a></li>
            <li><a href="http://html5ify.com/doxmate">Doxmate主页</a></li>
            <li><a href="https://github.com/JacksonTian/doxmate/issues?state=open">提交bug</a></li>
          </ul>
      </div>
    </footer>
    <script>
      $(function() {
        $('pre').addClass('prettyprint');
        $('td pre').removeClass('prettyprint');
        prettyPrint();
        var $window = $(window);
        $('.bs-docs-sidenav').affix({
          offset: {
            top: function () {
              return $window.width() <= 980 ? 290 : 210
            },
            bottom: 270
          }
        });
        $(".content").find('h1, h2, h3, h4, h5, h6').each(function () {
          var node = $(this);
          if (!node.attr("id")) {
            node.attr("id", "index_" + node.text());
          }
          node.css("paddingTop", 40);
        });
      });
    </script>
  
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-17170593-4']);
      _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  
  </body>
</html>